<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turbo Constraint Solver: include/barebones_dive_and_solve.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Turbo Constraint Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function() { init_codefold(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('barebones__dive__and__solve_8hpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">barebones_dive_and_solve.hpp</div></div>
</div><!--header-->
<div class="contents">
<a href="barebones__dive__and__solve_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">// Copyright 2025 Pierre Talbot</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span> </div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="preprocessor">#ifndef TURBO_BAREBONES_DIVE_AND_SOLVE_HPP</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#define TURBO_BAREBONES_DIVE_AND_SOLVE_HPP</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span> </div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &quot;<a class="code" href="common__solving_8hpp.html">common_solving.hpp</a>&quot;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &quot;<a class="code" href="memory__gpu_8hpp.html">memory_gpu.hpp</a>&quot;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="preprocessor">#include &quot;lala/light_branch.hpp&quot;</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment"></span> </div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment">/** This is required in order to guess the usage of global memory, and increase it. */</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno"><a class="line" href="barebones__dive__and__solve_8hpp.html#a3b4f0156ef0d54a710da4f30e39bae43">   14</a></span><span class="preprocessor">#define MAX_SEARCH_DEPTH 10000</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span> </div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="keyword">namespace </span>bt = ::battery;</div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment"></span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment">/**</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment"> * The full GPU version (`gpu_dive_and_solve`) is not compiling on modern GPU hardware (SM &gt;= 9) due to the kernel being too large.</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="comment"> * We circuvanted this issue by creating an hybrid version where only propagation is executed on the GPU (`hybrid_dive_and_solve`).</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="comment"> * This has the disadvantage of memory transfers between CPU and GPU and synchronization overheads.</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="comment"> * We propose a new &quot;barebones&quot; version which contains less abstractions than the GPU and hybrid versions, but have the same functionalities.</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="comment"> * In particular, we directly implement the branch-and-bound algorithm here and avoid using `lala::BAB` and `lala::SearchTree` which are nice from a software engineering perspective but bring significant overhead.</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="comment"> * This version is intended to reach the best possible performance.</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="comment"> *</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="comment"> * Terminology:</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="comment"> *  * unified data: data available to both the CPU and GPU.</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="comment"> *  * block data: data used within a single block.</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="comment"> *  * grid data: data shared among all blocks in the grid.</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="comment"> */</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span> </div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="preprocessor">#ifdef __CUDACC__</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span> </div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="preprocessor">#include &lt;cuda/std/chrono&gt;</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="preprocessor">#include &lt;cuda/semaphore&gt;</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span> </div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span> </div>
<div class="foldopen" id="foldopen00039" data-start="{" data-end="}">
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno"><a class="line" href="namespacebarebones.html">   39</a></span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacebarebones.html">barebones</a> {</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span> </div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="preprocessor">#ifdef __CUDACC__</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="preprocessor">#ifndef TURBO_IPC_ABSTRACT_DOMAIN</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment"></span> </div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment">/** `ConcurrentAllocator` allocates memory available both on CPU and GPU. For non-Linux systems such as Windows pinned memory must be used (see PR #19). */</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="preprocessor">#ifdef NO_CONCURRENT_MANAGED_MEMORY</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>  <span class="keyword">using </span>ConcurrentAllocator = bt::pinned_allocator;</div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>  <span class="keyword">using </span>ConcurrentAllocator = bt::managed_allocator;</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span> </div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="keyword">using </span>GridCP = <a class="code hl_struct" href="struct_abstract_domains.html">AbstractDomains</a>&lt;<a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>,</div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>  bt::statistics_allocator&lt;ConcurrentAllocator&gt;,</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>  bt::statistics_allocator&lt;UniqueLightAlloc&lt;ConcurrentAllocator, 0&gt;&gt;,</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>  bt::statistics_allocator&lt;UniqueLightAlloc&lt;ConcurrentAllocator, 1&gt;&gt;&gt;;</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"></span> </div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment">/** Data shared between CPU and GPU. */</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="keyword">struct </span>UnifiedData {<span class="comment"></span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment">  /** The root node of the problem, useful to backtrack when solving a new subproblem.</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment">   * Also contains the shared information such as statistics and solver configuration.</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment">   */</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span>  GridCP root;</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment"></span> </div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment">  /** Stop signal from the CPU because of a timeout or CTRL-C. */</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>  cuda::std::atomic_flag stop;</div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment"></span> </div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment">  /** The memory configuration of each block. */</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>  MemoryConfig mem_config;</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span> </div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>  UnifiedData(<span class="keyword">const</span> <a class="code hl_struct" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; cp, MemoryConfig mem_config)</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>   : root(GridCP::tag_gpu_block_copy{}, <span class="keyword">false</span>, cp)</div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>   , stop(<span class="keyword">false</span>)</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span>   , mem_config(mem_config)</div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>  {</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>    <span class="keywordtype">size_t</span> num_subproblems = 1;</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span>    num_subproblems &lt;&lt;= root.config.subproblems_power;</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>    root.stats.eps_num_subproblems = num_subproblems;</div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span>  }</div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>};</div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span> </div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="keyword">struct </span>GridData;</div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="keyword">using </span>IStore = VStore&lt;Itv, bt::pool_allocator&gt;;</div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="keyword">using </span>IProp = PIR&lt;IStore, bt::pool_allocator&gt;;</div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="keyword">using </span>UB = ZUB&lt;typename Itv::LB::value_type, bt::atomic_memory_grid&gt;;</div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="keyword">using </span>strategies_type = bt::vector&lt;StrategyType&lt;bt::global_allocator&gt;, bt::global_allocator&gt;;</div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment"></span> </div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="comment">/** Data private to a single block. */</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="keyword">struct </span>BlockData {<span class="comment"></span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment">  /** The store of variables at the root of the current subproblem. */</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span>  abstract_ptr&lt;VStore&lt;Itv, bt::global_allocator&gt;&gt; root_store;</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span><span class="comment"></span> </div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment">  /** The best solution found so far in this block. */</span></div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span>  abstract_ptr&lt;VStore&lt;Itv, bt::global_allocator&gt;&gt; best_store;</div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment"></span> </div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment">  /** The current store of variables.</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment">   * We use a `pool_allocator`, this allows to easily switch between global memory and shared memory, if the store of variables can fit inside.</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment">   * */</span></div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>  abstract_ptr&lt;IStore&gt; store;</div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment"></span> </div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment">  /** The propagators implemented as an array of bytecodes.</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment">   * Similarly, the propagators can be stored in the global or shared memory.</span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="comment">   * If the propagators do not fit in shared memory, the array of propagators is shared among all blocks.</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="comment">   * It is possible because the propagators are state-less, we avoid duplicating them in each block.</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span><span class="comment">   * */</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>  abstract_ptr&lt;IProp&gt; iprop;</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment"></span> </div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment">  /** The statistics of the current block. */</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span>  <a class="code hl_struct" href="struct_statistics.html">Statistics&lt;bt::global_allocator&gt;</a> stats;</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment"></span> </div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment">  /** The path from `UnifiedData::root` to the current subproblem `root_store`. */</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>  <span class="keywordtype">size_t</span> subproblem_idx;</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment"></span> </div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment">  /** The best bound found so far by this block.</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment">   * We always seek to minimize.</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment">   * Invariant: `best_bound == best_store.project(obj_var).lb()`</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment">   */</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>  UB best_bound;</div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment"></span> </div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment">  /** The current strategy being used to split the store.</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment">   * It is an index into `GridData::strategies`.</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment">   */</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span>  <span class="keywordtype">int</span> current_strategy;</div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment"></span> </div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment">  /** The next unassigned variable in the current strategy.</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment">   * It is an index into `GridData::strategies.vars`.</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment">   */</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>  <span class="keywordtype">int</span> next_unassigned_var;</div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment"></span> </div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment">  /** On backtracking, the value to restore `current_strategy`. */</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>  <span class="keywordtype">int</span> snapshot_root_strategy;</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment"></span> </div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment">  /** On backtracking, the value to restore `next_unassigned_var`. */</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>  <span class="keywordtype">int</span> snapshot_next_unassigned_var;</div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment"></span> </div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment">  /** The decision taken when exploring the tree. */</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>  bt::vector&lt;LightBranch&lt;Itv&gt;, bt::global_allocator&gt; decisions;</div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment"></span> </div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment">  /** Current depth of the search tree. */</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span>  <span class="keywordtype">int</span> depth;</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment"></span> </div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment">  /** A timer used for computing time statistics. */</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span>  cuda::std::chrono::system_clock::time_point timer;</div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span> </div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span>  __device__ BlockData()</div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span>   : subproblem_idx(0)</div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span>   , current_strategy(0)</div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span>   , next_unassigned_var(0)</div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span>   , decisions(5000)</div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span>   , depth(0)</div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span>  {}</div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span> </div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>  __device__ <span class="keywordtype">void</span> allocate(<span class="keyword">const</span> UnifiedData&amp; unified_data, <span class="keyword">const</span> GridData&amp; grid_data, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* shared_mem) {</div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span>      subproblem_idx = blockIdx.x;</div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span>      <span class="keyword">const</span> MemoryConfig&amp; mem_config = unified_data.mem_config;</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; u_store = *(unified_data.root.store);</div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; u_iprop = *(unified_data.root.iprop);</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>      bt::pool_allocator shared_mem_pool(mem_config.make_shared_pool(shared_mem));</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>      bt::pool_allocator store_allocator(mem_config.make_store_pool(shared_mem_pool));</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>      bt::pool_allocator prop_allocator(mem_config.make_prop_pool(shared_mem_pool));</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span>      root_store = bt::make_shared&lt;VStore&lt;Itv, bt::global_allocator&gt;, bt::global_allocator&gt;(u_store);</div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>      best_store = bt::make_shared&lt;VStore&lt;Itv, bt::global_allocator&gt;, bt::global_allocator&gt;(u_store);</div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>      store = bt::allocate_shared&lt;IStore, bt::pool_allocator&gt;(store_allocator, u_store, store_allocator);</div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>      iprop = bt::allocate_shared&lt;IProp, bt::pool_allocator&gt;(prop_allocator, u_iprop, store, prop_allocator);</div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>    }</div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span>  }</div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment"></span> </div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment">  /** We must deallocate store and iprop inside the kernel because they might be initialized in shared memory. */</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span>  __device__ <span class="keywordtype">void</span> deallocate_shared_data() {</div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span>      <span class="comment">// NOTE: .reset() does not work because it does not reset the allocator, which is itself allocated in global memory.</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>      store = abstract_ptr&lt;IStore&gt;();</div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>      iprop = abstract_ptr&lt;IProp&gt;();</div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>    }</div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span>  }</div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment"></span> </div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">  /** Add a new decision on the `decisions` stack and increase depth.</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment">   * \param has_changed: A Boolean in shared memory.</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment">   * \param strategies: A sequence of strategies.</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment">   * \precondition: We must not be on a leaf node.</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment">   */</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span>  __device__ INLINE <span class="keywordtype">void</span> split(<span class="keywordtype">bool</span>&amp; has_changed, <span class="keyword">const</span> strategies_type&amp; strategies) {</div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>    <span class="keyword">using </span>LB2 = <span class="keyword">typename</span> Itv::LB::local_type;</div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>    <span class="keyword">using </span>UB2 = <span class="keyword">typename</span> Itv::UB::local_type;</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span>    __shared__ local::ZUB idx;</div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>    decisions[depth].var = AVar{};</div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>    <span class="keywordtype">int</span> currentDepth = depth;</div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span>    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = current_strategy; i &lt; strategies.size(); ++i) {</div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span>      <span class="keywordflow">switch</span>(strategies[i].var_order) {</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>        <span class="keywordflow">case</span> VariableOrder::INPUT_ORDER: {</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>          input_order_split(has_changed, idx, strategies[i]);</div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span>        }</div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span>        <span class="keywordflow">case</span> VariableOrder::FIRST_FAIL: {</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span>          lattice_smallest_split(has_changed, idx, strategies[i],</div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span>            [](<span class="keyword">const</span> <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>&amp; u) { <span class="keywordflow">return</span> UB2(u.ub().value() - u.lb().value()); });</div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>        }</div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span>        <span class="keywordflow">case</span> VariableOrder::ANTI_FIRST_FAIL: {</div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span>          lattice_smallest_split(has_changed, idx, strategies[i],</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span>            [](<span class="keyword">const</span> <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>&amp; u) { <span class="keywordflow">return</span> LB2(u.ub().value() - u.lb().value()); });</div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span>        }</div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span>        <span class="keywordflow">case</span> VariableOrder::LARGEST: {</div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span>          lattice_smallest_split(has_changed, idx, strategies[i],</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span>            [](<span class="keyword">const</span> <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>&amp; u) { <span class="keywordflow">return</span> LB2(u.ub().value()); });</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span>        }</div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span>        <span class="keywordflow">case</span> VariableOrder::SMALLEST: {</div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>          lattice_smallest_split(has_changed, idx, strategies[i],</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span>            [](<span class="keyword">const</span> <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>&amp; u) { <span class="keywordflow">return</span> UB2(u.lb().value()); });</div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span>        }</div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>        <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>      }</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>      __syncthreads();</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>      <span class="comment">// If we could find a variable with the current strategy, we return.</span></div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>      <span class="keywordflow">if</span>(!decisions[currentDepth].var.is_untyped()) {</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>      }</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>        current_strategy++;</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span>        next_unassigned_var = 0;</div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>      }</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>      <span class="comment">// `input_order_split` and `lattice_smallest_split` have a `__syncthreads()` before reading next_unassigned_var.</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span>    }</div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span>  }</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment"></span> </div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment">  /** Select the next unassigned variable with a finite interval in the array `strategy.vars()` or `store` if the previous one is empty.</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment">   * We ignore infinite variables as splitting on them do not guarantee termination.</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment">   * \param has_changed is a Boolean in shared memory.</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment">   * \param idx is a decreasing integer in shared memory.</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment">   */</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>  __device__ INLINE <span class="keywordtype">void</span> input_order_split(<span class="keywordtype">bool</span>&amp; has_changed, local::ZUB&amp; idx, <span class="keyword">const</span> StrategyType&lt;bt::global_allocator&gt;&amp; strategy)</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>  {</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>    <span class="keywordtype">bool</span> split_in_store = strategy.vars.empty();</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>    <span class="keywordtype">int</span> n = split_in_store ? store-&gt;vars() : strategy.vars.size();</div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>    has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>      idx = n;</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>    }</div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span>    <span class="keywordflow">while</span>(has_changed) {</div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>      __syncthreads();</div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span>      <span class="comment">// int n = idx.value();</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>      <span class="comment">// __syncthreads();</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span>      has_changed = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = next_unassigned_var + threadIdx.x; i &lt; n; i += blockDim.x) {</div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dom = (*store)[split_in_store ? i : strategy.vars[i].vid()];</div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>        <span class="keywordflow">if</span>(dom.lb().value() != dom.ub().value() &amp;&amp; !dom.lb().is_top() &amp;&amp; !dom.ub().is_top()) {</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span>          <span class="keywordflow">if</span>(idx.meet(local::ZUB(i))) {</div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>            has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>          }</div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>        }</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>      }</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>      __syncthreads();</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>    }</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>      next_unassigned_var = idx.value();</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>    }</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>    <span class="keywordflow">if</span>(idx.value() != n) {</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>      push_decision(strategy.val_order, split_in_store ? AVar{store-&gt;aty(), idx.value()} : strategy.vars[idx.value()]);</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>    }</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>  }</div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment"></span> </div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment">  /** Given an array of variable, select the variable `x` with the smallest value `f(store[x])` where &quot;smallest&quot; is defined according to the lattice order of the return type of `f`.</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment">   * \param has_changed is a Boolean in shared memory.</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span><span class="comment">   * \param idx is a decreasing integer in shared memory.</span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="comment">   * */</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>  <span class="keyword">template</span> &lt;<span class="keyword">class</span> F&gt;</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>  __device__ INLINE <span class="keywordtype">void</span> lattice_smallest_split(<span class="keywordtype">bool</span>&amp; has_changed, local::ZUB&amp; idx,</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>    <span class="keyword">const</span> StrategyType&lt;bt::global_allocator&gt;&amp; strategy, F f)</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>  {</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>    <span class="keyword">using </span>T = <span class="keyword">decltype</span>(f(<a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>{}));</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>    __shared__ T value;</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span>    <span class="keywordtype">bool</span> split_in_store = strategy.vars.empty();</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span>    <span class="keywordtype">int</span> n = split_in_store ? store-&gt;vars() : strategy.vars.size();</div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span>    has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span>      value = T::top();</div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>      idx = n;</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>    }<span class="comment"></span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment">    /** This fixpoint loop seeks for the smallest `x` according to `f(x)` and the next unassigned variable. */</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span>    <span class="keywordflow">while</span>(has_changed) {</div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span>      __syncthreads();</div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span>      has_changed = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = next_unassigned_var + threadIdx.x; i &lt; n; i += blockDim.x) {</div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dom = (*store)[split_in_store ? i : strategy.vars[i].vid()];</div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span>        <span class="keywordflow">if</span>(dom.lb().value() != dom.ub().value() &amp;&amp; !dom.lb().is_top() &amp;&amp; !dom.ub().is_top()) {</div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span>          <span class="keywordflow">if</span>(value.meet(f(dom))) {</div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span>            has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>          }</div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span>          <span class="keywordflow">if</span>(idx.meet(local::ZUB(i))) {</div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span>            has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span>          }</div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span>        }</div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span>      }</div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span>      __syncthreads();</div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span>    }<span class="comment"></span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment">    /** If we found a value, we traverse again the variables&#39; array to find its index. */</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>    <span class="keywordflow">if</span>(!value.is_top()) {</div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span>        next_unassigned_var = idx.value();</div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span>        idx = n;</div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span>      }</div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span>      __syncthreads();</div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span>      has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span>      <span class="comment">// This fixpoint loop is not strictly necessary.</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span>      <span class="comment">// We keep it for determinism: the variable with the smallest index is selected first.</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span>      <span class="keywordflow">while</span>(has_changed) {</div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span>        <span class="keywordtype">int</span> n = idx.value();</div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span>        __syncthreads();</div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span>        has_changed = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span>        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = next_unassigned_var + threadIdx.x; i &lt; n; i += blockDim.x) {</div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span>          <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dom = (*store)[split_in_store ? i : strategy.vars[i].vid()];</div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span>          <span class="keywordflow">if</span>(dom.lb().value() != dom.ub().value() &amp;&amp; !dom.lb().is_top() &amp;&amp; !dom.ub().is_top() &amp;&amp; f(dom) == value) {</div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span>            <span class="keywordflow">if</span>(idx.meet(local::ZUB(i))) {</div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span>              has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span>            }</div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span>          }</div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span>        }</div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span>        __syncthreads();</div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span>      }</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span>      assert(idx.value() &lt; n);</div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span>      push_decision(strategy.val_order, split_in_store ? AVar{store-&gt;aty(), idx.value()} : strategy.vars[idx.value()]);</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>    }</div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span>  }</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span><span class="comment"></span> </div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="comment">  /** Push a new decision onto the decisions stack.</span></div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span><span class="comment">   *  \precondition The domain of the variable `var` must not be empty, be a singleton or contain infinite bounds.</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment">  */</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>  __device__ INLINE <span class="keywordtype">void</span> push_decision(ValueOrder val_order, AVar var) {</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>    <span class="keyword">using </span>value_type = <span class="keyword">typename</span> Itv::LB::value_type;</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>      decisions[depth].var = var;</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>      decisions[depth].current_idx = -1;</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dom = store-&gt;project(decisions[depth].var);</div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>      assert(dom.lb().value() != dom.ub().value());</div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>      <span class="keywordflow">switch</span>(val_order) {</div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>        <span class="keywordflow">case</span> ValueOrder::MIN: {</div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>          decisions[depth].children[0] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.lb().value());</div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span>          decisions[depth].children[1] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.lb().value() + value_type{1}, dom.ub());</div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span>        }</div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span>        <span class="keywordflow">case</span> ValueOrder::MAX: {</div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span>          decisions[depth].children[0] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.ub().value());</div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span>          decisions[depth].children[1] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.lb(), dom.ub().value() - value_type{1});</div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span>        }</div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span>        <span class="keywordflow">case</span> ValueOrder::SPLIT: {</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span>          <span class="keyword">auto</span> mid = dom.lb().value() +  (dom.ub().value() - dom.lb().value()) / value_type{2};</div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span>          decisions[depth].children[0] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.lb(), mid);</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>          decisions[depth].children[1] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(mid + value_type{1}, dom.ub());</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span>        }</div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span>        <span class="keywordflow">case</span> ValueOrder::REVERSE_SPLIT: {</div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>          <span class="keyword">auto</span> mid = dom.lb().value() +  (dom.ub().value() - dom.lb().value()) / value_type{2};</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span>          decisions[depth].children[0] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(mid + value_type{1}, dom.ub());</div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span>          decisions[depth].children[1] = <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(dom.lb(), mid);</div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span>        }</div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span>        <span class="comment">// ValueOrder::MEDIAN is not possible with interval.</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span>        <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);</div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span>      }<span class="comment"></span></div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment">      /** Ropes are a mechanism for fast backtracking.</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment">       * The rope of a left node is always the depth of the right node (also its depth), because after completing the exploration of the left subtree, we must visit the right subtree (rooted at the current depth).</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment">       * The rope of the right node is inherited from its parent, we set -1 if there is no next node to visit.</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment">       */</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span>      decisions[depth].ropes[0] = depth + 1;</div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span>      decisions[depth].ropes[1] = depth &gt; 0 ? decisions[depth-1].ropes[decisions[depth-1].current_idx] : -1;</div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span>      ++depth;</div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span>      <span class="comment">// Reallocate decisions if needed.</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span>      <span class="keywordflow">if</span>(decisions.size() == depth) {</div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span>        printf(<span class="stringliteral">&quot;resize to %d\n&quot;</span>, (<span class="keywordtype">int</span>)decisions.size() * 2);</div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span>        decisions.resize(decisions.size() * 2);</div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span>      }</div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span>    }</div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span>  }</div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span>};</div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment"></span> </div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment">/** Data shared among all blocks. */</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="keyword">struct </span>GridData {<span class="comment"></span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment">  /** The private data of each block. */</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span>  bt::vector&lt;BlockData, bt::global_allocator&gt; blocks;</div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment"></span> </div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment">  /** We generate the subproblems lazily.</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment">   * Suppose we generate `2^3` subproblems, we represent the first subproblem as `000`, the second as `001`, the third as `010`, and so on.</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment">   * A `0` means to turn left in the search tree, and a `1` means to turn right.</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment">   * Incrementing this integer will generate the path of the next subproblem.</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment">   */</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span>  ZLB&lt;size_t, bt::atomic_memory_grid&gt; next_subproblem;</div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment"></span> </div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment">  /** This is an approximation of the best bound found so far, globally, across all threads.</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment">   * It is not necessarily the true best bound at each time `t`.</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment">   * The true best bound is obtained by `meet` over all block&#39;s best bounds.</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment">   * It is used to share information among blocks.</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment">   * We always seek to minimize.</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment">   */</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span>  UB appx_best_bound;</div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment"></span> </div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment">  /** Due to multithreading, we must protect `stdout` when printing.</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment">   * The model of computation in this work is lock-free, but it seems unavoidable for printing.</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment">  */</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span>  cuda::binary_semaphore&lt;cuda::thread_scope_device&gt; print_lock;</div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment"></span> </div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment">  /** The search strategy is immutable and shared among the blocks. */</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span>  strategies_type search_strategies;</div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment"></span> </div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment">  /** The objective variable to minimize.</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment">   * Maximization problem are transformed into minimization problems by negating the objective variable.</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment">   * Equal to -1 if the problem is a satisfaction problem.</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment">   */</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span>  AVar obj_var;</div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span> </div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span>  __device__ GridData(<span class="keyword">const</span> GridCP&amp; root)</div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span>   : blocks(root.stats.num_blocks)</div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span>   , next_subproblem(root.stats.num_blocks)</div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span>   , print_lock(1)</div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span>   , search_strategies(root.split-&gt;strategies_())</div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span>   , obj_var(root.minimize_obj_var)</div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span>  {}</div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span>};</div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span> </div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span>MemoryConfig configure_gpu_barebones(<a class="code hl_struct" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp;);</div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span>__global__ <span class="keywordtype">void</span> initialize_global_data(UnifiedData*, bt::unique_ptr&lt;GridData, bt::global_allocator&gt;*);</div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span>__global__ <span class="keywordtype">void</span> gpu_barebones_solve(UnifiedData*, GridData*);</div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> FPEngine&gt;</div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span>__device__ INLINE <span class="keywordtype">void</span> propagate(UnifiedData&amp; unified_data, GridData&amp; grid_data, BlockData&amp; block_data,</div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span>   FPEngine&amp; fp_engine, <span class="keywordtype">bool</span>&amp; stop, <span class="keywordtype">bool</span>&amp; has_changed, <span class="keywordtype">bool</span>&amp; is_leaf_node);</div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span>__global__ <span class="keywordtype">void</span> reduce_blocks(UnifiedData*, GridData*);</div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span>__global__ <span class="keywordtype">void</span> deallocate_global_data(bt::unique_ptr&lt;GridData, bt::global_allocator&gt;*);</div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span> </div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacebarebones.html#adbbbe7794d4c328585fc96380c262334">barebones_dive_and_solve</a>(<span class="keyword">const</span> <a class="code hl_struct" href="struct_configuration.html">Configuration&lt;battery::standard_allocator&gt;</a>&amp; config) {</div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span>  <span class="keywordflow">if</span>(config.<a class="code hl_variable" href="struct_configuration.html#a1e28a838055718bee138fc096d43696e">print_intermediate_solutions</a>) {</div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span>    printf(<span class="stringliteral">&quot;%% WARNING: -arch barebones is incompatible with -i and -a (it cannot print intermediate solutions).&quot;</span>);</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>  }</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>  <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>  check_support_managed_memory();</div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span>  check_support_concurrent_managed_memory();<span class="comment"></span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment">  /** We start with some preprocessing to reduce the number of variables and constraints. */</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>  <a class="code hl_struct" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a> cp(config);</div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span>  cp.<a class="code hl_function" href="struct_abstract_domains.html#a9ab2a88ebb928131d7392df6c2613ddc">preprocess</a>();</div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>  <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#ad066915b4e82fb68f8a4c9a38e159d3b">iprop</a>-&gt;is_bot()) {</div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>    cp.<a class="code hl_function" href="struct_abstract_domains.html#a1ba9490f8b7b9a1f9058ca5c7352c1e7">print_final_solution</a>();</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span>    cp.<a class="code hl_function" href="struct_abstract_domains.html#af512dd0701e97987346dbc2cb2319922">print_mzn_statistics</a>();</div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>  }</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>  MemoryConfig mem_config = configure_gpu_barebones(cp);</div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span>  <span class="keyword">auto</span> unified_data = bt::make_unique&lt;UnifiedData, ConcurrentAllocator&gt;(cp, mem_config);</div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span>  <span class="keyword">auto</span> grid_data = bt::make_unique&lt;bt::unique_ptr&lt;GridData, bt::global_allocator&gt;, ConcurrentAllocator&gt;();</div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span>  initialize_global_data&lt;&lt;&lt;1,1&gt;&gt;&gt;(unified_data.get(), grid_data.get());</div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span>  CUDAEX(cudaDeviceSynchronize());<span class="comment"></span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment">  /** We wait that either the solving is interrupted, or that all threads have finished. */</span><span class="comment"></span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment">  /** Block the signal CTRL-C to notify the threads if we must exit. */</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span>  <a class="code hl_function" href="common__solving_8hpp.html#ad04619f00eb1d7deacc6f2326f0ace5e">block_signal_ctrlc</a>();</div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span>  gpu_barebones_solve</div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span>    &lt;&lt;&lt;<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a>),</div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span>      CUDA_THREADS_PER_BLOCK,</div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span>      mem_config.shared_bytes&gt;&gt;&gt;</div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span>    (unified_data.get(), grid_data-&gt;get());</div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span>  <span class="keywordtype">bool</span> interrupted = wait_solving_ends(unified_data-&gt;stop, unified_data-&gt;root, start);</div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span>  CUDAEX(cudaDeviceSynchronize());</div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span>  reduce_blocks&lt;&lt;&lt;1,1&gt;&gt;&gt;(unified_data.get(), grid_data-&gt;get());</div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span>  CUDAEX(cudaDeviceSynchronize());</div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span>  <span class="keyword">auto</span>&amp; uroot = unified_data-&gt;root;</div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span>  <span class="keywordflow">if</span>(uroot.stats.solutions &gt; 0) {</div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span>    cp.<a class="code hl_function" href="struct_abstract_domains.html#ad390e307245412ec0baee7f802d56b6d">print_solution</a>(*uroot.best);</div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span>  }</div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span>  uroot.stats.print_mzn_final_separator();</div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span>  <span class="keywordflow">if</span>(uroot.config.print_statistics) {</div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span>    uroot.config.print_mzn_statistics();</div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span>    uroot.stats.print_mzn_statistics(uroot.config.verbose_solving);</div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span>    <span class="keywordflow">if</span>(uroot.bab-&gt;is_optimization() &amp;&amp; uroot.stats.solutions &gt; 0) {</div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span>      uroot.stats.print_mzn_objective(uroot.best-&gt;project(uroot.bab-&gt;objective_var()), uroot.bab-&gt;is_minimization());</div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span>    }</div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span>    unified_data-&gt;root.stats.print_mzn_end_stats();</div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span>  }</div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span>  deallocate_global_data&lt;&lt;&lt;1,1&gt;&gt;&gt;(grid_data.get());</div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span>  CUDAEX(cudaDeviceSynchronize());</div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span>}</div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment"></span> </div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment">/** We configure the GPU according to the user configuration:</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment"> * 1) Guess the &quot;best&quot; number of blocks per SM, if not provided.</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment"> * 2) Configure the size of the shared memory.</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment"> * 3) Increase the global heap memory.</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment"> * 4) Increase the stack size if requested by the user.</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="comment"> */</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span>MemoryConfig configure_gpu_barebones(<a class="code hl_struct" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; cp) {</div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span>  <span class="keyword">auto</span>&amp; config = cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>;</div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment"></span> </div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment">  /** I. Number of blocks per SM. */</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span> </div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span>  cudaDeviceProp deviceProp;</div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span>  cudaGetDeviceProperties(&amp;deviceProp, 0);</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span>  <span class="keywordtype">int</span> max_block_per_sm;</div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span>  cudaOccupancyMaxActiveBlocksPerMultiprocessor(&amp;max_block_per_sm, (<span class="keywordtype">void</span>*) gpu_barebones_solve, CUDA_THREADS_PER_BLOCK, 0);</div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>  <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>) {</div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span>    printf(<span class="stringliteral">&quot;%% max_blocks_per_sm=%d\n&quot;</span>, max_block_per_sm);</div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span>  }</div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span>  <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">or_nodes</a> != 0) {</div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span>    cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> = std::min(max_block_per_sm * deviceProp.multiProcessorCount, (<span class="keywordtype">int</span>)cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">or_nodes</a>);</div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span>    <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a> &gt;= 1 &amp;&amp; cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> &lt; cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">or_nodes</a>) {</div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span>      printf(<span class="stringliteral">&quot;%% WARNING: -or %d is too high on your GPU architecture, it has been reduced to %d.\n&quot;</span>, (<span class="keywordtype">int</span>)cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">or_nodes</a>, cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a>);</div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span>    }</div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span>  }</div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span>  <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span>    cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> = max_block_per_sm * deviceProp.multiProcessorCount;</div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span>  }</div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment"></span> </div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">  /** II. Configure the shared memory size. */</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span>  <span class="keywordtype">size_t</span> store_bytes = gpu_sizeof&lt;IStore&gt;() + gpu_sizeof&lt;abstract_ptr&lt;IStore&gt;&gt;() + cp.<a class="code hl_variable" href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">store</a>-&gt;vars() * gpu_sizeof&lt;Itv&gt;();</div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span>  <span class="keywordtype">size_t</span> iprop_bytes = gpu_sizeof&lt;IProp&gt;() + gpu_sizeof&lt;abstract_ptr&lt;IProp&gt;&gt;() + cp.<a class="code hl_variable" href="struct_abstract_domains.html#ad066915b4e82fb68f8a4c9a38e159d3b">iprop</a>-&gt;num_deductions() * gpu_sizeof&lt;bytecode_type&gt;() + gpu_sizeof&lt;typename IProp::bytecodes_type&gt;();</div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span>  <span class="comment">// If large problem, minimal amount of blocks.</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span>  <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#ad066915b4e82fb68f8a4c9a38e159d3b">iprop</a>-&gt;num_deductions() + cp.<a class="code hl_variable" href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">store</a>-&gt;vars() &gt; 1000000) {</div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>    cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> = deviceProp.multiProcessorCount;</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>    printf(<span class="stringliteral">&quot;%% WARNING: Large problem detected, reducing to 1 block per SM.\n&quot;</span>);</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span>  }</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>  <span class="keywordtype">int</span> blocks_per_sm = (cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> + deviceProp.multiProcessorCount - 1) / deviceProp.multiProcessorCount;</div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>  MemoryConfig mem_config;</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>  <span class="keywordflow">if</span>(config.<a class="code hl_variable" href="struct_configuration.html#aae1fab75cbb6561fa2d07eb7ed8c8b97">only_global_memory</a>) {</div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>    mem_config = MemoryConfig(store_bytes, iprop_bytes);</div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span>  }</div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span>  <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span>    mem_config = MemoryConfig((<span class="keywordtype">void</span>*) gpu_barebones_solve, config.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>, blocks_per_sm, store_bytes, iprop_bytes);</div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span>  }</div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span>  mem_config.print_mzn_statistics(config, cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>);</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment"></span> </div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment">  /** III. Size of the heap global memory.</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment">   * The estimation is very conservative, normally we should not run out of memory.</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment">   * */</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span>  <span class="keywordtype">size_t</span> nblocks = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a>);</div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span>  <span class="keywordtype">size_t</span> estimated_global_mem = gpu_sizeof&lt;UnifiedData&gt;() + store_bytes * <span class="keywordtype">size_t</span>{5} + iprop_bytes +</div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span>    gpu_sizeof&lt;GridData&gt;() +</div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span>    nblocks * gpu_sizeof&lt;BlockData&gt;() +</div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span>    nblocks * store_bytes * <span class="keywordtype">size_t</span>{3} + <span class="comment">// current, root, best.</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span>    nblocks * iprop_bytes * <span class="keywordtype">size_t</span>{2} +</div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span>    nblocks * cp.<a class="code hl_variable" href="struct_abstract_domains.html#ad066915b4e82fb68f8a4c9a38e159d3b">iprop</a>-&gt;num_deductions() * <span class="keywordtype">size_t</span>{4} * gpu_sizeof&lt;int&gt;()  + <span class="comment">// fixpoint engine</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span>    nblocks * (gpu_sizeof&lt;int&gt;() + gpu_sizeof&lt;LightBranch&lt;Itv&gt;&gt;()) * <span class="keywordtype">size_t</span>{<a class="code hl_define" href="barebones__dive__and__solve_8hpp.html#a3b4f0156ef0d54a710da4f30e39bae43">MAX_SEARCH_DEPTH</a>};</div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span>  <span class="keywordtype">size_t</span> required_global_mem = std::max(deviceProp.totalGlobalMem / 2, estimated_global_mem);</div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span>  <span class="keywordflow">if</span>(estimated_global_mem &gt; deviceProp.totalGlobalMem / 2) {</div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span>    printf(<span class="stringliteral">&quot;%% WARNING: The estimated global memory is larger than half of the total global memory.\n\</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="stringliteral">    We reduce the number of blocks to avoid running out of memory.\n&quot;</span>);</div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span>    cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a> = deviceProp.multiProcessorCount;</div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>  }</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span>  CUDAEX(cudaDeviceSetLimit(cudaLimitMallocHeapSize, required_global_mem));</div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span>  cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_function" href="struct_statistics.html#aff81b0a36139e1a90001ddcceffa617c">print_memory_statistics</a>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>, <span class="stringliteral">&quot;heap_memory&quot;</span>, required_global_mem);</div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span>  <span class="keywordflow">if</span>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>) {</div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span>    printf(<span class="stringliteral">&quot;%% estimated_global_mem=%zu\n&quot;</span>, estimated_global_mem);</div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span>    printf(<span class="stringliteral">&quot;%% num_blocks=%d\n&quot;</span>, cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_variable" href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">num_blocks</a>);</div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span>  }</div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span>  <span class="keywordflow">if</span>(deviceProp.totalGlobalMem &lt; required_global_mem) {</div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span>    printf(<span class="stringliteral">&quot;%% WARNING: The total global memory available is less than the required global memory.\n\</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="stringliteral">    As our memory estimation is very conservative, it might still work, but it is not guaranteed.\n&quot;</span>);</div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span>  }</div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment"></span> </div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment">  /** IV. Increase the stack if requested by the user. */</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span>  <span class="keywordflow">if</span>(config.<a class="code hl_variable" href="struct_configuration.html#a7bf2a5f05f6e8b1ebcfabcb786bea386">stack_kb</a> != 0) {</div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span>    CUDAEX(cudaDeviceSetLimit(cudaLimitStackSize, config.<a class="code hl_variable" href="struct_configuration.html#a7bf2a5f05f6e8b1ebcfabcb786bea386">stack_kb</a>*1000));</div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span>    <span class="comment">// The stack allocated depends on the maximum number of threads per SM, not on the actual number of threads per block.</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span>    <span class="keywordtype">size_t</span> total_stack_size = deviceProp.multiProcessorCount * deviceProp.maxThreadsPerMultiProcessor * config.<a class="code hl_variable" href="struct_configuration.html#a7bf2a5f05f6e8b1ebcfabcb786bea386">stack_kb</a> * 1000;</div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span>    cp.<a class="code hl_variable" href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">stats</a>.<a class="code hl_function" href="struct_statistics.html#aff81b0a36139e1a90001ddcceffa617c">print_memory_statistics</a>(cp.<a class="code hl_variable" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>, <span class="stringliteral">&quot;stack_memory&quot;</span>, total_stack_size);</div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span>  }</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>  <span class="keywordflow">return</span> mem_config;</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>}</div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span> </div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>__global__ <span class="keywordtype">void</span> initialize_global_data(</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span>  UnifiedData* unified_data,</div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span>  bt::unique_ptr&lt;GridData, bt::global_allocator&gt;* grid_data_ptr)</div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>{</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span>  *grid_data_ptr = bt::make_unique&lt;GridData, bt::global_allocator&gt;(unified_data-&gt;root);</div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>}</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span> </div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="preprocessor">#define TIMEPOINT(KIND) \</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="preprocessor">  if(threadIdx.x == 0) { \</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span><span class="preprocessor">    block_data.timer = block_data.stats.stop_timer(Timer::KIND, block_data.timer); \</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="preprocessor">  }</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span> </div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span>__global__ <span class="keywordtype">void</span> gpu_barebones_solve(UnifiedData* unified_data, GridData* grid_data) {</div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span>  <span class="keyword">extern</span> __shared__ <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> shared_mem[];</div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span>  <span class="keyword">auto</span>&amp; config = unified_data-&gt;root.config;</div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span>  BlockData&amp; block_data = grid_data-&gt;blocks[blockIdx.x];</div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>  <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; blockIdx.x == 0 &amp;&amp; config.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a>) {</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span>    printf(<span class="stringliteral">&quot;%% GPU kernel started, starting solving...\n&quot;</span>);</div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>  }</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment"></span> </div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment">  /** A. Initialization the block data and the fixpoint engine. */</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span> </div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>  block_data.allocate(*unified_data, *grid_data, shared_mem);</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>  __syncthreads();</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>  IProp&amp; iprop = *block_data.iprop;</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="preprocessor">#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>  __shared__ BlockAsynchronousFixpointGPU&lt;true&gt; fp_engine;</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>  __shared__ FixpointSubsetGPU&lt;BlockAsynchronousFixpointGPU&lt;true&gt;, bt::global_allocator, CUDA_THREADS_PER_BLOCK&gt; fp_engine;</div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span>  fp_engine.init(iprop.num_deductions());</div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="preprocessor">#endif</span><span class="comment"></span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment">  /** This shared variable is necessary to avoid multiple threads to read into `unified_data.stop.test()`,</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="comment">   * potentially reading different values and leading to deadlock. */</span><span class="preprocessor"></span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>  __shared__ <span class="keywordtype">bool</span> stop;</div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>  __shared__ <span class="keywordtype">bool</span> has_changed;</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span>  __shared__ <span class="keywordtype">bool</span> is_leaf_node;</div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span>  __shared__ <span class="keywordtype">int</span> remaining_depth;</div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span>  stop = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>  <span class="keyword">auto</span> group = cooperative_groups::this_thread_block();</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span>  <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span>    block_data.timer = block_data.stats.start_timer_device();</div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>  }</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>  __syncthreads();</div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment"></span> </div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment">  /** B. Start the main dive and solve loop. */</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span> </div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>  <span class="keywordtype">size_t</span> num_subproblems = unified_data-&gt;root.stats.eps_num_subproblems;</div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span>  <span class="keywordflow">while</span>(block_data.subproblem_idx &lt; num_subproblems &amp;&amp; !stop) {</div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>    <span class="keywordflow">if</span>(config.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a> &gt;= 2 &amp;&amp; threadIdx.x == 0) {</div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span>      grid_data-&gt;print_lock.acquire();</div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span>      printf(<span class="stringliteral">&quot;%% Block %d solves subproblem num %&quot;</span> PRIu64 <span class="stringliteral">&quot;\n&quot;</span>, blockIdx.x, block_data.subproblem_idx);</div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span>      grid_data-&gt;print_lock.release();</div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>    }</div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span> </div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span>    <span class="comment">// C. Restoring the current state to the root node.</span></div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span> </div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>    block_data.current_strategy = 0;</div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span>    block_data.next_unassigned_var = 0;</div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span>    block_data.depth = 0;</div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span>    unified_data-&gt;root.store-&gt;copy_to(group, *block_data.store);</div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="preprocessor">#ifndef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span>    fp_engine.reset(iprop.num_deductions());</div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span>    __syncthreads();</div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span> </div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span>    <span class="comment">// D. Dive into the search tree until we reach the target subproblem.</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span> </div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span>    remaining_depth = config.<a class="code hl_variable" href="struct_configuration.html#afb757200eb840ef0b0c908827ab77d88">subproblems_power</a>;</div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span>    is_leaf_node = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span>    <span class="keywordflow">while</span>(remaining_depth &gt; 0 &amp;&amp; !is_leaf_node &amp;&amp; !stop) {</div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span>      propagate(*unified_data, *grid_data, block_data, fp_engine, stop, has_changed, is_leaf_node);</div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span>      __syncthreads();</div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span>      <span class="keywordflow">if</span>(!is_leaf_node) {</div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span>        block_data.split(has_changed, grid_data-&gt;search_strategies);</div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>        __syncthreads();</div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span>        <span class="comment">// Split was not able to split a domain. It means that the search strategy is not complete due to unsplittable infinite domains.</span></div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span>        <span class="comment">// We skip the subtree, and set exhaustive to `false`.</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span>        <span class="keywordflow">if</span>(block_data.decisions[0].var.is_untyped()) {</div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span>          is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span>          block_data.stats.exhaustive = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span>        }</div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span>          --remaining_depth;</div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span>          <span class="comment">// We do not record the decisions when diving.</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span>          --block_data.depth;<span class="comment"></span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span><span class="comment">          /** We commit to one of the branches depending on the current value on the path.</span></div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span><span class="comment">           * Suppose the depth is 3, the path is &quot;010&quot; we are currently at `remaining_depth = 1`.</span></div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span><span class="comment">           * We must extract the bit &quot;1&quot;, and we do so by standard bitwise manipulation.</span></div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span><span class="comment">           * Whenever the branch_idx is 0 means to take the left branch, and 1 means to take the right branch.</span></div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span><span class="comment">           */</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span>          <span class="keywordtype">size_t</span> branch_idx = (block_data.subproblem_idx &amp; (<span class="keywordtype">size_t</span>{1} &lt;&lt; remaining_depth)) &gt;&gt; remaining_depth;<span class="comment"></span></div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span><span class="comment">          /** We immediately commit to the branch. */</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span>          block_data.store-&gt;embed(block_data.decisions[0].var, block_data.decisions[0].children[branch_idx]);</div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span>        }</div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span>      }</div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span>      __syncthreads();</div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span>    }</div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span> </div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span>    <span class="comment">// E. Skip subproblems that are not reachable.</span></div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment"></span> </div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment">    /** If we reached a leaf node before the subproblem was reached, then it means a whole subtree should be skipped. */</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span>    <span class="keywordflow">if</span>(is_leaf_node &amp;&amp; !stop) {<span class="comment"></span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment">       /** To skip all the paths of the subtree obtained, we perform bitwise operations.</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment">       * Suppose the current path is &quot;00&quot; turn left two times, and the following search tree:</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="comment">       *         *         depth = 0</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment">       *        / \</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment">       *      0    1       depth = 1</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment">       *    / \   / \</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span><span class="comment">       *   00 01 10 11     depth = 2</span></div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span><span class="comment">       *</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span><span class="comment">       * If we detect a leaf node at depth 1, after only one left turn, we must skip the remaining of the subtree, in particular to avoid exploring the path &quot;01&quot;.</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span><span class="comment">       * To achieve that, we take the current path &quot;00&quot;, shift it to the right by 1 (essentially erasing the path that has not been explored), increment it to go to the next subtree (at the same depth), and shift it back to the left to reach the first subproblem of the subtree.</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span><span class="comment">       * Cool huh?</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span><span class="comment">       */</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span>        <span class="keywordtype">size_t</span> next_subproblem_idx = ((block_data.subproblem_idx &gt;&gt; remaining_depth) + <span class="keywordtype">size_t</span>{1}) &lt;&lt; remaining_depth;</div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span>        <span class="comment">// Make sure the subtree is skipped.</span></div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span>        <span class="keywordflow">while</span>(grid_data-&gt;next_subproblem.meet(ZLB&lt;size_t, bt::local_memory&gt;(next_subproblem_idx))) {}<span class="comment"></span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="comment">        /** It is possible that other blocks skip similar subtrees.</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span><span class="comment">          * Hence, we only count the subproblems skipped by the block solving the left most subproblem. */</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>        <span class="keywordflow">if</span>((block_data.subproblem_idx &amp; ((<span class="keywordtype">size_t</span>{1} &lt;&lt; remaining_depth) - <span class="keywordtype">size_t</span>{1})) == <span class="keywordtype">size_t</span>{0}) {</div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>          block_data.stats.eps_skipped_subproblems += next_subproblem_idx - block_data.subproblem_idx;</div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span>        }</div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>      }</div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span>    }</div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!stop) {</div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span> </div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span>      <span class="comment">// F. Solve the current subproblem.</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span> </div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span>      <span class="keywordflow">while</span>(!stop) {</div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span> </div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span>        <span class="comment">// I. Propagate the current node.</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span> </div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span>        propagate(*unified_data, *grid_data, block_data, fp_engine, stop, has_changed, is_leaf_node);</div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span>        __syncthreads();</div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span> </div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span>        <span class="comment">// II. Branching</span></div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span> </div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span>        <span class="keywordflow">if</span>(!is_leaf_node) {</div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span>          <span class="comment">// If we are at the root of the current subproblem, we create a snapshot for future backtracking.</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span>          <span class="keywordflow">if</span>(block_data.depth == 0) {</div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span>            block_data.store-&gt;copy_to(group, *block_data.root_store);</div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span>          }</div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span>          block_data.split(has_changed, grid_data-&gt;search_strategies);</div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span>          __syncthreads();</div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span>          <span class="comment">// Split was not able to split a domain. It means that the search strategy is not complete due to unsplittable infinite domains.</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span>          <span class="comment">// We trigger backtracking, and set exhaustive to `false`.</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span>          <span class="keywordflow">if</span>(block_data.decisions[block_data.depth - 1].var.is_untyped()) {</div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span>            is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span>            block_data.stats.exhaustive = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span>          }</div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span>          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span>            <span class="comment">// depth == 1 for root node because we just increased it in `block_data.split`.</span></div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>            <span class="keywordflow">if</span>(block_data.depth == 1) {</div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span>              block_data.snapshot_root_strategy = block_data.current_strategy;</div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span>              block_data.snapshot_next_unassigned_var = block_data.next_unassigned_var;</div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span>            }</div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span>            <span class="comment">// Apply the decision.</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span>            block_data.store-&gt;embed(block_data.decisions[block_data.depth-1].var, block_data.decisions[block_data.depth-1].next());</div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span>            <span class="comment">// printf(&quot;left decision: %d [&quot;, block_data.decisions[block_data.depth - 1].var.vid()); block_data.decisions[block_data.depth - 1].current().print(); printf(&quot;]\n&quot;);</span></div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span>          }</div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span>        }</div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span> </div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span>        <span class="comment">// III. Backtracking</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span> </div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span>        <span class="keywordflow">if</span>(is_leaf_node) {</div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span> </div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span>          <span class="comment">// if(threadIdx.x == 0) {</span></div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span>          <span class="comment">//   printf(&quot;backtracking\n&quot;);</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span>          <span class="comment">// }</span></div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span>          <span class="comment">// Leaf node at root.</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span>          <span class="keywordflow">if</span>(block_data.depth == 0) {</div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span>          }</div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span>          <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span>            block_data.depth = block_data.decisions[block_data.depth-1].ropes[block_data.decisions[block_data.depth-1].current_idx];</div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span>          }</div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span>          __syncthreads();</div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span>          <span class="comment">// Check if there is no more node to visit.</span></div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span>          <span class="keywordflow">if</span>(block_data.depth == -1) {</div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span>          }</div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span>          <span class="comment">// Restore from root by copying the store and re-applying all decisions from root to block_data.depth-1.</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="preprocessor">#ifndef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span>          fp_engine.reset(iprop.num_deductions());</div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span>          block_data.root_store-&gt;copy_to(group, *block_data.store);</div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span>          has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span>          <span class="keywordflow">while</span>(has_changed) {</div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span>            __syncthreads();</div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span>            has_changed = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span>            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = threadIdx.x; i &lt; block_data.depth - 1; i += blockDim.x) {</div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span>              <span class="keywordflow">if</span>(block_data.store-&gt;embed(block_data.decisions[i].var, block_data.decisions[i].current())) {</div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span>                has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span>              }</div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span>            }</div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span>            __syncthreads();</div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span>          }</div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span>          <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span>            block_data.store-&gt;embed(block_data.decisions[block_data.depth - 1].var, block_data.decisions[block_data.depth - 1].next());</div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span>            <span class="comment">// printf(&quot;right decision: %d [&quot;, block_data.decisions[block_data.depth - 1].var.vid()); block_data.decisions[block_data.depth - 1].current().print(); printf(&quot;]\n&quot;);</span></div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span>            block_data.current_strategy = block_data.snapshot_root_strategy;</div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span>            block_data.next_unassigned_var = block_data.snapshot_next_unassigned_var;</div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span>          }</div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span>        }</div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span>      }<span class="comment"></span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment">      /** If we didn&#39;t stop solving because of an external interruption, we increase the number of subproblems solved. */</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span>      <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; block_data.stats.nodes &lt; config.<a class="code hl_variable" href="struct_configuration.html#a02b9174886f673d82253debae3e21f8b">stop_after_n_nodes</a></div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span>        &amp;&amp; !unified_data-&gt;stop.test())</div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>      {</div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span>        block_data.stats.eps_solved_subproblems += 1;</div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span>      }</div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span>    }</div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span> </div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span>    <span class="comment">// G. Move to the next subproblem.</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment"></span> </div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment">    /** We prepare the block to solve the next problem.</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">     * We update the subproblem index to the next subproblem to solve. */</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span>    <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; !stop) {<span class="comment"></span></div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment">      /** To avoid that several blocks solve the same subproblem, we use an atomic post-increment. */</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span>      block_data.subproblem_idx = grid_data-&gt;next_subproblem.atomic()++;<span class="comment"></span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment">      /** The following commented code is completely valid and does not use atomic post-increment.</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment">       * But honestly, we kinda need more performance so... let&#39;s avoid reexploring subproblems. */</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span>      <span class="comment">// subproblem_idx = grid_data-&gt;next_subproblem.value();</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span>      <span class="comment">// grid_data-&gt;next_subproblem.meet(ZLB&lt;size_t, bt::local_memory&gt;(subproblem_idx + size_t{1}));</span></div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span>    }</div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span>    __syncthreads();</div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span>  }</div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span>  <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; block_data.stats.nodes &lt; config.<a class="code hl_variable" href="struct_configuration.html#a02b9174886f673d82253debae3e21f8b">stop_after_n_nodes</a></div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span>      &amp;&amp; !unified_data-&gt;stop.test())</div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span>  {</div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span>    block_data.stats.num_blocks_done = 1;</div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span>  }</div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span>  __syncthreads();</div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span><span class="preprocessor">#ifndef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span>  fp_engine.destroy();</div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span>  block_data.deallocate_shared_data();</div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span>  __syncthreads();</div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span>}</div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span> </div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> FPEngine&gt;</div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span>__device__ INLINE <span class="keywordtype">void</span> propagate(UnifiedData&amp; unified_data, GridData&amp; grid_data, BlockData&amp; block_data,</div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span>   FPEngine&amp; fp_engine, <span class="keywordtype">bool</span>&amp; stop, <span class="keywordtype">bool</span>&amp; has_changed, <span class="keywordtype">bool</span>&amp; is_leaf_node)</div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span>{</div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span>  __shared__ <span class="keywordtype">int</span> warp_iterations[CUDA_THREADS_PER_BLOCK/32];</div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span>  warp_iterations[threadIdx.x / 32] = 0;</div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span>  <span class="keyword">auto</span>&amp; config = unified_data.root.config;</div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span>  IProp&amp; iprop = *block_data.iprop;</div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span>  <span class="keyword">auto</span> group = cooperative_groups::this_thread_block();</div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span> </div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span>  <span class="comment">// I. Optimize the objective variable.</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span> </div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span>  <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; !grid_data.obj_var.is_untyped()) {<span class="comment"></span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span><span class="comment">    /** Before propagating, we update the local bound with the best known global bound.</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment">     * Strenghten the objective variable to get a better objective next time.</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span><span class="comment">     */</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span>    <span class="keywordflow">if</span>(!grid_data.appx_best_bound.is_top()) {</div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span>      block_data.store-&gt;embed(grid_data.obj_var,</div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span>        <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(Itv::LB::top(), Itv::UB(grid_data.appx_best_bound.value() - 1)));</div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span>      block_data.store-&gt;embed(grid_data.obj_var,</div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span>        <a class="code hl_typedef" href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a>(Itv::LB::top(), Itv::UB(block_data.best_bound.value() - 1)));</div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>    }</div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>  }</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span>  __syncthreads();</div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span>  <span class="comment">// Unconstrained objective, can terminate, we will not find a better solution.</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span>  <span class="keywordflow">if</span>(grid_data.appx_best_bound.is_bot()) {</div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span>    stop = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span>  }</div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span>  TIMEPOINT(<a class="code hl_enumvalue" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">SEARCH</a>);</div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span>  is_leaf_node = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span> </div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span>  <span class="comment">// II. Compute the fixpoint of the current node.</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span>  <span class="keywordtype">int</span> fp_iterations;</div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span><span class="preprocessor">#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span>  <span class="keywordtype">int</span> num_active = iprop.num_deductions();</div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span>  <span class="keywordtype">int</span> num_active = fp_engine.num_active();</div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span>  <span class="keywordflow">switch</span>(config.<a class="code hl_variable" href="struct_configuration.html#ad4cca6861f2269be0f65d9d331a5aedd">fixpoint</a>) {</div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558">FixpointKind::AC1</a>: {</div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span>      fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span>#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span>        iprop.num_deductions(),</div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span>#endif</div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span>        [&amp;](<span class="keywordtype">int</span> i){ return iprop.deduce(i); },</div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span>        [&amp;](){ return iprop.is_bot(); });</div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span>        block_data.stats.num_deductions += fp_iterations * num_active;</div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span>      }</div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span>    }</div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb">FixpointKind::WAC1</a>: {</div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span>      <span class="keywordflow">if</span>(num_active &lt;= config.<a class="code hl_variable" href="struct_configuration.html#ad83964f3057297a5fa72be9a1b63a80b">wac1_threshold</a>) {</div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span>        fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span>#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span>        iprop.num_deductions(),</div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>#endif</div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span>          [&amp;](<span class="keywordtype">int</span> i){ return iprop.deduce(i); },</div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span>          [&amp;](){ return iprop.is_bot(); });</div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span>        <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span>          block_data.stats.num_deductions += fp_iterations * num_active;</div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>        }</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span>      }</div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>      <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>        fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>          iprop.num_deductions(),</div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>#endif</div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>          [&amp;](<span class="keywordtype">int</span> i){ return warp_fixpoint&lt;CUDA_THREADS_PER_BLOCK&gt;(iprop, i, warp_iterations); },</div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>          [&amp;](){ return iprop.is_bot(); });</div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span>        <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span>          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; CUDA_THREADS_PER_BLOCK/32; ++i) {</div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span>            block_data.stats.num_deductions += warp_iterations[i] * 32;</div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span>          }</div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span>        }</div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span>      }</div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span>    }</div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span>  }</div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span>  TIMEPOINT(<a class="code hl_enumvalue" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89">FIXPOINT</a>);</div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span> </div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span>  <span class="comment">// III. Analyze the result of propagation</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span> </div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span>  <span class="keywordflow">if</span>(!iprop.is_bot()) {</div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span><span class="preprocessor">#ifdef TURBO_NO_ENTAILED_PROP_REMOVAL</span></div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span>    has_changed = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span>    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = threadIdx.x; !has_changed &amp;&amp; i &lt; iprop.num_deductions(); i += blockDim.x) {</div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span>      <span class="keywordflow">if</span>(!iprop.ask(i)) {</div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span>        has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span>      }</div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span>    }</div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span>    __syncthreads();</div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span>    num_active = has_changed;</div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span>    fp_engine.select([&amp;](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> !iprop.ask(i); });</div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span>    num_active = fp_engine.num_active();</div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span>    TIMEPOINT(<a class="code hl_enumvalue" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df">SELECT_FP_FUNCTIONS</a>);</div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span>    <span class="keywordflow">if</span>(num_active == 0) {</div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span>      is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span>        block_data.best_bound.meet(Itv::UB(block_data.store-&gt;project(grid_data.obj_var).lb().value()));</div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span>        grid_data.appx_best_bound.meet(block_data.best_bound);</div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span>      }</div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span>      block_data.store-&gt;copy_to(group, *block_data.best_store);</div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span>      <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span>        block_data.stats.solutions++;</div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span>        <span class="keywordflow">if</span>(config.<a class="code hl_variable" href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">verbose_solving</a> &gt;= 2) {</div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span>          grid_data.print_lock.acquire();</div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span>          printf(<span class="stringliteral">&quot;%% objective=&quot;</span>); block_data.best_bound.print(); printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span>          grid_data.print_lock.release();</div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span>        }</div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span>      }</div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span>    }</div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span>  }</div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span>  <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span>    is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span>  }</div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span> </div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span>  <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>    block_data.stats.fixpoint_iterations += fp_iterations;</div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span>    block_data.stats.nodes++;</div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span>    block_data.stats.fails += (iprop.is_bot() ? 1 : 0);</div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span>    block_data.stats.depth_max = battery::max(block_data.stats.depth_max, block_data.depth);</div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span> </div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span>    <span class="comment">// IV. Checking stopping conditions.</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span> </div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span>    <span class="keywordflow">if</span>(block_data.stats.nodes &gt;= config.<a class="code hl_variable" href="struct_configuration.html#a02b9174886f673d82253debae3e21f8b">stop_after_n_nodes</a></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span>      || unified_data.stop.test())</div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span>    {</div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span>      block_data.stats.exhaustive = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span>      stop = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span>    }</div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span>  }</div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span>}</div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span> </div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span>__global__ <span class="keywordtype">void</span> reduce_blocks(UnifiedData* unified_data, GridData* grid_data) {</div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span>  <span class="keyword">auto</span>&amp; root = unified_data-&gt;root;</div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span>  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; grid_data-&gt;blocks.size(); ++i) {</div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span>    root.stats.meet(grid_data-&gt;blocks[i].stats);</div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span>  }</div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span>  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; grid_data-&gt;blocks.size(); ++i) {</div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span>    <span class="keyword">auto</span>&amp; block = grid_data-&gt;blocks[i];</div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span>    <span class="keywordflow">if</span>(block.stats.solutions &gt; 0) {</div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span>      <span class="keywordflow">if</span>(root.bab-&gt;is_satisfaction()) {</div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span>        block.best_store-&gt;extract(*root.best);</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span>      }</div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span>      <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span>        grid_data-&gt;appx_best_bound.meet(block.best_bound);</div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span>      }</div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span>    }</div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span>  }</div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span>  <span class="comment">// If we found a bound, we copy the best store into the unified data.</span></div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span>  <span class="keywordflow">if</span>(!grid_data-&gt;appx_best_bound.is_top()) {</div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span>    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; grid_data-&gt;blocks.size(); ++i) {</div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span>      <span class="keyword">auto</span>&amp; block = grid_data-&gt;blocks[i];</div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span>      <span class="keywordflow">if</span>(block.best_bound == grid_data-&gt;appx_best_bound</div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span>       &amp;&amp; block.best_store-&gt;project(grid_data-&gt;obj_var).lb() == block.best_bound)</div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>      {</div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>        block.best_store-&gt;copy_to(*root.best);</div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span>      }</div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span>    }</div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span>  }</div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span>}</div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span> </div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span>__global__ <span class="keywordtype">void</span> deallocate_global_data(bt::unique_ptr&lt;GridData, bt::global_allocator&gt;* grid_data) {</div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span>  grid_data-&gt;reset();</div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span>}</div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span> </div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span><span class="preprocessor">#endif </span><span class="comment">// TURBO_IPC_ABSTRACT_DOMAIN</span></div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span><span class="preprocessor">#endif </span><span class="comment">// __CUDACC__</span></div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span> </div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span><span class="preprocessor">#if defined(TURBO_IPC_ABSTRACT_DOMAIN) || !defined(__CUDACC__)</span></div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span> </div>
<div class="foldopen" id="foldopen00982" data-start="{" data-end="}">
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno"><a class="line" href="namespacebarebones.html#adbbbe7794d4c328585fc96380c262334">  982</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacebarebones.html#adbbbe7794d4c328585fc96380c262334">barebones_dive_and_solve</a>(<span class="keyword">const</span> <a class="code hl_struct" href="struct_configuration.html">Configuration&lt;battery::standard_allocator&gt;</a>&amp; config) {</div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span><span class="preprocessor">#ifdef TURBO_IPC_ABSTRACT_DOMAIN</span></div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span>  std::cerr &lt;&lt; <span class="stringliteral">&quot;-arch barebones does not support IPC abstract domain.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span><span class="preprocessor">#else</span></div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span>  std::cerr &lt;&lt; <span class="stringliteral">&quot;You must use a CUDA compiler (nvcc or clang) to compile Turbo on GPU.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span>}</div>
</div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span> </div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span> </div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span>} <span class="comment">// namespace barebones</span></div>
</div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span> </div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span><span class="preprocessor">#endif </span><span class="comment">// TURBO_BAREBONES_DIVE_AND_SOLVE_HPP</span></div>
<div class="ttc" id="abarebones__dive__and__solve_8hpp_html_a3b4f0156ef0d54a710da4f30e39bae43"><div class="ttname"><a href="barebones__dive__and__solve_8hpp.html#a3b4f0156ef0d54a710da4f30e39bae43">MAX_SEARCH_DEPTH</a></div><div class="ttdeci">#define MAX_SEARCH_DEPTH</div><div class="ttdef"><b>Definition</b> barebones_dive_and_solve.hpp:14</div></div>
<div class="ttc" id="acommon__solving_8hpp_html"><div class="ttname"><a href="common__solving_8hpp.html">common_solving.hpp</a></div></div>
<div class="ttc" id="acommon__solving_8hpp_html_a966a2ced54ee4b3a3259c28649c1fa39"><div class="ttname"><a href="common__solving_8hpp.html#a966a2ced54ee4b3a3259c28649c1fa39">Itv</a></div><div class="ttdeci">Interval&lt; ZLB&lt; bound_value_type, battery::local_memory &gt; &gt; Itv</div><div class="ttdef"><b>Definition</b> common_solving.hpp:53</div></div>
<div class="ttc" id="acommon__solving_8hpp_html_ad04619f00eb1d7deacc6f2326f0ace5e"><div class="ttname"><a href="common__solving_8hpp.html#ad04619f00eb1d7deacc6f2326f0ace5e">block_signal_ctrlc</a></div><div class="ttdeci">void block_signal_ctrlc()</div><div class="ttdef"><b>Definition</b> common_solving.hpp:72</div></div>
<div class="ttc" id="aconfig_8hpp_html_a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558"><div class="ttname"><a href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558">FixpointKind::AC1</a></div><div class="ttdeci">@ AC1</div></div>
<div class="ttc" id="aconfig_8hpp_html_a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb"><div class="ttname"><a href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb">FixpointKind::WAC1</a></div><div class="ttdeci">@ WAC1</div></div>
<div class="ttc" id="amemory__gpu_8hpp_html"><div class="ttname"><a href="memory__gpu_8hpp.html">memory_gpu.hpp</a></div></div>
<div class="ttc" id="anamespacebarebones_html"><div class="ttname"><a href="namespacebarebones.html">barebones</a></div><div class="ttdef"><b>Definition</b> barebones_dive_and_solve.hpp:39</div></div>
<div class="ttc" id="anamespacebarebones_html_adbbbe7794d4c328585fc96380c262334"><div class="ttname"><a href="namespacebarebones.html#adbbbe7794d4c328585fc96380c262334">barebones::barebones_dive_and_solve</a></div><div class="ttdeci">void barebones_dive_and_solve(const Configuration&lt; battery::standard_allocator &gt; &amp;config)</div><div class="ttdef"><b>Definition</b> barebones_dive_and_solve.hpp:982</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a></div><div class="ttdeci">@ SEARCH</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89">Timer::FIXPOINT</a></div><div class="ttdeci">@ FIXPOINT</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df">Timer::SELECT_FP_FUNCTIONS</a></div><div class="ttdeci">@ SELECT_FP_FUNCTIONS</div></div>
<div class="ttc" id="astruct_abstract_domains_html"><div class="ttname"><a href="struct_abstract_domains.html">AbstractDomains</a></div><div class="ttdef"><b>Definition</b> common_solving.hpp:144</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a0aa5ac01e4f4a2a8b2811edca6eb8ef9"><div class="ttname"><a href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">AbstractDomains::config</a></div><div class="ttdeci">Configuration&lt; BasicAllocator &gt; config</div><div class="ttdef"><b>Definition</b> common_solving.hpp:278</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a1ba9490f8b7b9a1f9058ca5c7352c1e7"><div class="ttname"><a href="struct_abstract_domains.html#a1ba9490f8b7b9a1f9058ca5c7352c1e7">AbstractDomains::print_final_solution</a></div><div class="ttdeci">CUDA void print_final_solution()</div><div class="ttdef"><b>Definition</b> common_solving.hpp:830</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a4079f4eda90c5a3162357423aedae435"><div class="ttname"><a href="struct_abstract_domains.html#a4079f4eda90c5a3162357423aedae435">AbstractDomains::stats</a></div><div class="ttdeci">Statistics&lt; BasicAllocator &gt; stats</div><div class="ttdef"><b>Definition</b> common_solving.hpp:279</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a6163aae266ebdf3370b3fedc63c150a3"><div class="ttname"><a href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">AbstractDomains::store</a></div><div class="ttdeci">abstract_ptr&lt; IStore &gt; store</div><div class="ttdef"><b>Definition</b> common_solving.hpp:260</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a9ab2a88ebb928131d7392df6c2613ddc"><div class="ttname"><a href="struct_abstract_domains.html#a9ab2a88ebb928131d7392df6c2613ddc">AbstractDomains::preprocess</a></div><div class="ttdeci">void preprocess()</div><div class="ttdef"><b>Definition</b> common_solving.hpp:591</div></div>
<div class="ttc" id="astruct_abstract_domains_html_ad066915b4e82fb68f8a4c9a38e159d3b"><div class="ttname"><a href="struct_abstract_domains.html#ad066915b4e82fb68f8a4c9a38e159d3b">AbstractDomains::iprop</a></div><div class="ttdeci">abstract_ptr&lt; IProp &gt; iprop</div><div class="ttdef"><b>Definition</b> common_solving.hpp:261</div></div>
<div class="ttc" id="astruct_abstract_domains_html_ad390e307245412ec0baee7f802d56b6d"><div class="ttname"><a href="struct_abstract_domains.html#ad390e307245412ec0baee7f802d56b6d">AbstractDomains::print_solution</a></div><div class="ttdeci">CUDA void print_solution()</div><div class="ttdef"><b>Definition</b> common_solving.hpp:793</div></div>
<div class="ttc" id="astruct_abstract_domains_html_af512dd0701e97987346dbc2cb2319922"><div class="ttname"><a href="struct_abstract_domains.html#af512dd0701e97987346dbc2cb2319922">AbstractDomains::print_mzn_statistics</a></div><div class="ttdeci">CUDA void print_mzn_statistics()</div><div class="ttdef"><b>Definition</b> common_solving.hpp:837</div></div>
<div class="ttc" id="astruct_configuration_html"><div class="ttname"><a href="struct_configuration.html">Configuration</a></div><div class="ttdef"><b>Definition</b> config.hpp:34</div></div>
<div class="ttc" id="astruct_configuration_html_a02b9174886f673d82253debae3e21f8b"><div class="ttname"><a href="struct_configuration.html#a02b9174886f673d82253debae3e21f8b">Configuration::stop_after_n_nodes</a></div><div class="ttdeci">size_t stop_after_n_nodes</div><div class="ttdef"><b>Definition</b> config.hpp:38</div></div>
<div class="ttc" id="astruct_configuration_html_a1e28a838055718bee138fc096d43696e"><div class="ttname"><a href="struct_configuration.html#a1e28a838055718bee138fc096d43696e">Configuration::print_intermediate_solutions</a></div><div class="ttdeci">bool print_intermediate_solutions</div><div class="ttdef"><b>Definition</b> config.hpp:36</div></div>
<div class="ttc" id="astruct_configuration_html_a6400dfba9cd09ea3050d18c71c8d47fb"><div class="ttname"><a href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">Configuration::or_nodes</a></div><div class="ttdeci">size_t or_nodes</div><div class="ttdef"><b>Definition</b> config.hpp:48</div></div>
<div class="ttc" id="astruct_configuration_html_a7bf2a5f05f6e8b1ebcfabcb786bea386"><div class="ttname"><a href="struct_configuration.html#a7bf2a5f05f6e8b1ebcfabcb786bea386">Configuration::stack_kb</a></div><div class="ttdeci">size_t stack_kb</div><div class="ttdef"><b>Definition</b> config.hpp:50</div></div>
<div class="ttc" id="astruct_configuration_html_aae1fab75cbb6561fa2d07eb7ed8c8b97"><div class="ttname"><a href="struct_configuration.html#aae1fab75cbb6561fa2d07eb7ed8c8b97">Configuration::only_global_memory</a></div><div class="ttdeci">bool only_global_memory</div><div class="ttdef"><b>Definition</b> config.hpp:43</div></div>
<div class="ttc" id="astruct_configuration_html_ad4cca6861f2269be0f65d9d331a5aedd"><div class="ttname"><a href="struct_configuration.html#ad4cca6861f2269be0f65d9d331a5aedd">Configuration::fixpoint</a></div><div class="ttdeci">FixpointKind fixpoint</div><div class="ttdef"><b>Definition</b> config.hpp:52</div></div>
<div class="ttc" id="astruct_configuration_html_ad5efde0c72659262ea39f0001976db8f"><div class="ttname"><a href="struct_configuration.html#ad5efde0c72659262ea39f0001976db8f">Configuration::verbose_solving</a></div><div class="ttdeci">int verbose_solving</div><div class="ttdef"><b>Definition</b> config.hpp:41</div></div>
<div class="ttc" id="astruct_configuration_html_ad83964f3057297a5fa72be9a1b63a80b"><div class="ttname"><a href="struct_configuration.html#ad83964f3057297a5fa72be9a1b63a80b">Configuration::wac1_threshold</a></div><div class="ttdeci">size_t wac1_threshold</div><div class="ttdef"><b>Definition</b> config.hpp:53</div></div>
<div class="ttc" id="astruct_configuration_html_afb757200eb840ef0b0c908827ab77d88"><div class="ttname"><a href="struct_configuration.html#afb757200eb840ef0b0c908827ab77d88">Configuration::subproblems_power</a></div><div class="ttdeci">size_t subproblems_power</div><div class="ttdef"><b>Definition</b> config.hpp:49</div></div>
<div class="ttc" id="astruct_statistics_html"><div class="ttname"><a href="struct_statistics.html">Statistics</a></div><div class="ttdef"><b>Definition</b> statistics.hpp:110</div></div>
<div class="ttc" id="astruct_statistics_html_ac0bca55a06fb5e994cbd29d9d8140f30"><div class="ttname"><a href="struct_statistics.html#ac0bca55a06fb5e994cbd29d9d8140f30">Statistics::num_blocks</a></div><div class="ttdeci">int num_blocks</div><div class="ttdef"><b>Definition</b> statistics.hpp:117</div></div>
<div class="ttc" id="astruct_statistics_html_aff81b0a36139e1a90001ddcceffa617c"><div class="ttname"><a href="struct_statistics.html#aff81b0a36139e1a90001ddcceffa617c">Statistics::print_memory_statistics</a></div><div class="ttdeci">CUDA void print_memory_statistics(int verbose, const char *key, size_t bytes) const</div><div class="ttdef"><b>Definition</b> statistics.hpp:256</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="barebones__dive__and__solve_8hpp.html">barebones_dive_and_solve.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
