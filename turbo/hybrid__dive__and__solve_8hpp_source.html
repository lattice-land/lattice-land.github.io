<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turbo Constraint Solver: include/hybrid_dive_and_solve.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turbo Constraint Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('hybrid__dive__and__solve_8hpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">hybrid_dive_and_solve.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="hybrid__dive__and__solve_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Copyright 2024 Pierre Talbot</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#ifndef TURBO_HYBRID_DIVE_AND_SOLVE_HPP</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#define TURBO_HYBRID_DIVE_AND_SOLVE_HPP</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="common__solving_8hpp.html">common_solving.hpp</a>&quot;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">namespace </span>bt = ::battery;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> * &quot;Dive and solve&quot; is a new algorithm to parallelize the standard &quot;propagate and search&quot; algorithm of constraint programming.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> * Given a depth `d`, we create `2^d` subproblems that we solve in parallel.</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * We create as many CPU threads as blocks on the GPU (option `config.or_nodes`).</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * A CPU thread takes the next subproblem available and run the &quot;propagate and search&quot; algorithm on it.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * The CPU thread offloads the propagation to the GPU, but take care of splitting and backtracking in the search tree, as well as maintaining the best bound found, and the statistics.</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * Therefore, a kernel with only 1 block is executed each time we propagate a node.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> * Since many CPU threads execute in parallel, there are many kernels running in parallel.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * We call a task solving a subproblem a &quot;cube&quot; (this loosely follows the terminology of SAT solving with &quot;cube and conquer&quot;).</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * By CPU cube, we refer to the local state of a CPU thread for solving a subproblem.</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * By GPU cube, we refer to the local state of a GPU block for solving a subproblem.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * Note that at each moment, there are at most `config.or_nodes` cubes active in parallel.</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#ifdef __CUDACC__</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">/** By default, we don&#39;t need dynamic shared memory. */</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#define DEFAULT_SHARED_MEM_BYTES 0</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">/** A CPU cube is the data used by a CPU thread to solve a subproblem. */</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keyword">struct </span>CPUCube {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keyword">using</span> cube_type = <a class="code" href="struct_abstract_domains.html">AbstractDomains</a>&lt;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a>, bt::standard_allocator, <a class="code" href="struct_unique_light_alloc.html">UniqueLightAlloc&lt;bt::standard_allocator,0&gt;</a>, bt::pinned_allocator&gt;;<span class="comment"></span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">  /** A CPU cube is fully allocated on the CPU, but for the store of variables `cube.store` which is allocated in managed memory.</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">   * Indeed, when exchanging information between a GPU cube and a CPU cube, only the store of variables need to be transfered.</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  cube_type cube;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">  /** We keep a snapshot of the root to reinitialize the CPU cube after each subproblem has been solved. */</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="keyword">typename</span> cube_type::IST::snapshot_type&lt;bt::standard_allocator&gt; root_snapshot;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">  /** This flag becomes `true` when the thread has finished its execution (it exits `dive_and_solve` function). */</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  std::atomic_flag finished;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">  /** This is the path to the subproblem needed to be solved by this cube.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">   * This member is initialized in `CPUData` constructor.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordtype">size_t</span> subproblem_idx;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  CPUCube(<span class="keyword">const</span> <a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; root)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;   : cube(root)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;   , root_snapshot(cube.search_tree-&gt;template snapshot&lt;bt::standard_allocator&gt;())</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  {}</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;};</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">/** A GPU cube is the data used by a GPU block to solve a subproblem.</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"> * We only allocate the necessary structures to perform propagation: the store of variables and the propagators.</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="keyword">struct </span>GPUCube {<span class="comment"></span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">  /** We use atomic to store the interval&#39;s lower and upper bounds. */</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="comment">// using Itv1 = Interval&lt;ZLB&lt;int, bt::atomic_memory_block&gt;&gt;;</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="keyword">using</span> Itv1 = Interval&lt;ZLB&lt;int, bt::local_memory&gt;&gt;;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">  /** We use a `pool_allocator`, this allows to easily switch between global memory and shared memory, if the store of variables can fit inside. */</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keyword">using</span> IStore = VStore&lt;Itv1, bt::pool_allocator&gt;;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">  /** The store of propagators also uses a `pool_allocator` of global memory. This was necessary due to the slow copy of propagators between CPU and GPU.</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">   * Indeed, a propagator is a tree-shaped object (like an AST) that contain many pointers, and thus the copy calls the allocation function a lot. */</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keyword">using</span> IPC = PIR&lt;IStore, bt::pool_allocator&gt;;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">  /** The store of variables is only accessible on GPU. */</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  abstract_ptr&lt;IStore&gt; store_gpu;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">  /** The propagators is only accessible on GPU but the array of propagators is shared among all blocks.</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">   * Since the propagators are state-less, we avoid duplicating them in each block.</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  abstract_ptr&lt;IPC&gt; ipc_gpu;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">  /** `events` is used in the fixpoint loop to know which variables have been modified between two iterations. */</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// battery::vector&lt;local::B, bt::global_allocator&gt; events;</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// battery::vector&lt;local::B, bt::global_allocator&gt; events2;</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="comment">// battery::vector&lt;local::B, bt::pinned_allocator&gt; events_cpu;</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">  /** We also have a store of variables in managed memory to communicate the results of the propagation to the CPU.</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">   * Note that this store is the same than the one in the corresponding CPU cube (`cube.store`).</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">   * This member is initialized in `CPUData` constructor.</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  abstract_ptr&lt;VStore&lt;Itv, bt::pinned_allocator&gt;&gt; store_cpu;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">  /** This Boolean is used to communicate to the CPU the current node is a solution. */</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  cuda::std::atomic_flag solution_found;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">  /** The cumulative number of iterations required to reach a fixpoint.</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">   * By dividing this statistic by the number of nodes, we get the average number of iterations per node.</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keywordtype">size_t</span> fp_iterations;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">  /** From config. */</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <a class="code" href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751b">FixpointKind</a> fp_kind;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keywordtype">size_t</span> wac1_threshold;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <a class="code" href="struct_timing_statistics.html">TimingStatistics&lt;bt::managed_allocator&gt;</a> timers;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">  /** The CPU thread and the GPU block use those two flags to signal to each other when to work and when to wait.</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">   * This is necessary due to the persistent kernel design of this algorithm.</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  cuda::std::atomic_flag ready_to_propagate;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  cuda::std::atomic_flag ready_to_search;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">  /** A flag to notify the kernel it must stop. */</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  cuda::std::atomic_flag stop;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  GPUCube() {<span class="comment"></span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">    /** Initially, we are not ready to propagate or to search. */</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    ready_to_search.clear();</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    ready_to_propagate.clear();</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    stop.clear();</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    solution_found.clear();</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  }</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">  /** Initialize the store of variables and propagators from existing store and propagators.</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">   * If `pc_shared` is `true`, the propagators if this cube will be shared with `pc`.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">   * Otherwise, a full copy of the propagators is made.</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">   * We generally want to share the propagators, hence the cube 0 copies the propagators, and all other cubes share them.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">class</span> StoreType, <span class="keyword">class</span> PCType&gt;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  __device__ <span class="keywordtype">void</span> allocate(StoreType&amp; store, PCType&amp; pc, <span class="keywordtype">size_t</span> bytes, <span class="keywordtype">bool</span> pc_shared) {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordtype">int</span> n = pc.num_deductions();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    bytes += 100; <span class="comment">// for alignment padding.</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordtype">void</span>* mem_pool = bt::global_allocator{}.allocate(bytes);</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    bt::pool_allocator pool(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(mem_pool), bytes);</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    AbstractDeps&lt;bt::global_allocator, bt::pool_allocator&gt; deps(pc_shared, bt::global_allocator{}, pool);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    ipc_gpu = bt::allocate_shared&lt;IPC, bt::pool_allocator&gt;(pool, pc, deps);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    store_gpu = deps.template extract&lt;IStore&gt;(store.aty());</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="comment">// events.resize(store.vars());</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">// events2.resize(store.vars());</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  }</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160; </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  __device__ <span class="keywordtype">void</span> deallocate() {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="comment">// NOTE: .reset() does not work because it does not reset the allocator, which is itself allocated in global memory.</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    store_gpu = abstract_ptr&lt;IStore&gt;();</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    ipc_gpu = abstract_ptr&lt;IPC&gt;();</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// events = battery::vector&lt;local::B, bt::global_allocator&gt;();</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// events2 = battery::vector&lt;local::B, bt::global_allocator&gt;();</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;};</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">/** This kernel initializes the GPU cubes. See the constructor of `CPUData` for more information. */</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Store, <span class="keyword">class</span> IPC&gt;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;__global__ <span class="keywordtype">void</span> allocate_gpu_cubes(GPUCube* gpu_cubes,</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="keywordtype">size_t</span> n, Store* store, IPC* ipc)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;{</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  assert(threadIdx.x == 0 &amp;&amp; blockIdx.x == 0);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  <span class="keywordtype">size_t</span> bytes = store-&gt;get_allocator().total_bytes_allocated()</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    + <span class="keyword">sizeof</span>(GPUCube::IStore) + <span class="keyword">sizeof</span>(GPUCube::IPC) + 1000;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  gpu_cubes[0].allocate(*store, *ipc, bytes + ipc-&gt;get_allocator().total_bytes_allocated(), <span class="keyword">false</span>);</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; n; ++i) {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    gpu_cubes[i].allocate(*gpu_cubes[0].store_gpu, *gpu_cubes[0].ipc_gpu, bytes, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  }</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160; </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;__global__ <span class="keywordtype">void</span> deallocate_gpu_cubes(GPUCube* gpu_cubes, <span class="keywordtype">size_t</span> n) {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  assert(threadIdx.x == 0 &amp;&amp; blockIdx.x == 0);</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    gpu_cubes[i].deallocate();</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  }</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">/** This is the data shared among all CPU threads. */</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="keyword">struct </span>CPUData {<span class="comment"></span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">  /** We generate the subproblems lazily.</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">   * Suppose we generate `2^3` subproblems, we represent the first subproblem as `000`, the second as `001`, the third as `010`, and so on.</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">   * A `0` means to turn left in the search tree, and a `1` means to turn right.</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">   * Incrementing this integer will generate the path of the next subproblem.</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  ZLB&lt;size_t, bt::atomic_memory&lt;&gt;&gt; next_subproblem;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">  /** This is the best bound found so far, globally, across all threads. */</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a> best_bound;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">  /** A flag to stop the threads, for example because of a timeout or CTRL-C. */</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  std::atomic_flag cpu_stop;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">  /** Due to multithreading, we must protect `stdout` when printing.</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">   * The model of computation in this work is lock-free, but it seems unavoidable for printing.</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  std::mutex print_lock;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">  /** The initial problem is only accessible from the CPU.</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">   * It is used at the beginning to count the bytes used by the store and propagators.</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">   * And at the end, to merge all the statistics and solutions from all threads, and print them.</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a> root;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">  /** For each block, how much shared memory are we using? */</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="keywordtype">size_t</span> shared_mem_bytes;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">  /** Each CPU thread has its own local state to solve a subproblem, called a cube. */</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  bt::vector&lt;CPUCube&gt; cpu_cubes;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">  /** Each GPU block has its own local state to solve a subproblem, called a cube. */</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  bt::vector&lt;GPUCube, bt::managed_allocator&gt; gpu_cubes;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">  /** We create as many cubes as CPU threads and GPU blocks (option `config.or_nodes`).</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">   * All CPU cubes are initialized to different subproblems, from 0 to `config.or_nodes - 1`.</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">   * Hence the next subproblem to solve is `config.or_nodes`.</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">   * The GPU cubes are initialized to the same state than the CPU cubes.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">   * Further, we connect the CPU and GPU cubes by sharing their store of variables (`gpu_cubes[i].store_cpu` and `cpu_cubes[i].cube.store`).</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">   * Also, we share the propagators of `gpu_cubes[0].ipc_gpu` with all other cubes `gpu_cubes[i].ipc_gpu` (with i &gt;= 1).</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  CPUData(<span class="keyword">const</span> <a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; root, <span class="keywordtype">size_t</span> shared_mem_bytes)</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;   : next_subproblem(root.config.or_nodes)</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;   , best_bound(<a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a>::top())</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;   , root(root)</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;   , shared_mem_bytes(shared_mem_bytes)</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;   , cpu_cubes(root.config.or_nodes, this-&gt;root)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;   , gpu_cubes(root.config.or_nodes)</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    cpu_stop.clear();</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; root.<a class="code" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code" href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">or_nodes</a>; ++i) {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      cpu_cubes[i].subproblem_idx = i;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      gpu_cubes[i].store_cpu = cpu_cubes[i].cube.<a class="code" href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">store</a>;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      gpu_cubes[i].fp_kind = root.<a class="code" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code" href="struct_configuration.html#ad4cca6861f2269be0f65d9d331a5aedd">fixpoint</a>;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      gpu_cubes[i].wac1_threshold = root.<a class="code" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>.<a class="code" href="struct_configuration.html#ad83964f3057297a5fa72be9a1b63a80b">wac1_threshold</a>;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    }<span class="comment"></span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">    /** This is a temporary object to initialize the first cube with the store and propagators. */</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <a class="code" href="struct_abstract_domains.html">AbstractDomains</a>&lt;<a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a>, bt::standard_allocator,</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      bt::statistics_allocator&lt;UniqueLightAlloc&lt;bt::managed_allocator, 0&gt;&gt;,</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      bt::statistics_allocator&lt;UniqueLightAlloc&lt;bt::managed_allocator, 1&gt;&gt;&gt;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    managed_cp(root);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    printf(<span class="stringliteral">&quot;%%%%%%mzn-stat: store_mem=%&quot;</span> PRIu64 <span class="stringliteral">&quot;\n&quot;</span>, managed_cp.store.get_allocator().total_bytes_allocated());</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    printf(<span class="stringliteral">&quot;%%%%%%mzn-stat: propagator_mem=%&quot;</span> PRIu64 <span class="stringliteral">&quot;\n&quot;</span>, managed_cp.ipc.get_allocator().total_bytes_allocated());</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    allocate_gpu_cubes&lt;&lt;&lt;1, 1&gt;&gt;&gt;(gpu_cubes.data(), gpu_cubes.size(), managed_cp.store.get(), managed_cp.ipc.get());</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    CUDAEX(cudaDeviceSynchronize());</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  }</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160; </div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  ~CPUData() {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    deallocate_gpu_cubes&lt;&lt;&lt;1, 1&gt;&gt;&gt;(gpu_cubes.data(), gpu_cubes.size());</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    CUDAEX(cudaDeviceSynchronize());</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  }</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160; </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  CPUData() = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  CPUData(<span class="keyword">const</span> CPUData&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  CPUData(CPUData&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;};</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160; </div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="keywordtype">void</span> dive_and_solve(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="keywordtype">size_t</span> dive(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="keywordtype">void</span> solve(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="keywordtype">bool</span> propagate(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="keywordtype">bool</span> update_global_best_bound(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="keywordtype">void</span> update_local_best_bound(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="keywordtype">void</span> reduce_cubes(CPUData&amp; global);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="keywordtype">size_t</span> configure_gpu(<a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; cp);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;__global__ <span class="keywordtype">void</span> gpu_propagate(GPUCube* cube, <span class="keywordtype">size_t</span> shared_bytes);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160; </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="preprocessor">#endif </span><span class="comment">// __CUDACC__</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">/** This is the point of entry, we preprocess the problem, create the threads solving the problem, wait for their completion or an interruption, merge and print the statistics. */</span></div>
<div class="line"><a name="l00264"></a><span class="lineno"><a class="line" href="hybrid__dive__and__solve_8hpp.html#ab002d8e461e9e10df5c63ee20a3e33a6">  264</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="hybrid__dive__and__solve_8hpp.html#ab002d8e461e9e10df5c63ee20a3e33a6">hybrid_dive_and_solve</a>(<span class="keyword">const</span> <a class="code" href="struct_configuration.html">Configuration&lt;battery::standard_allocator&gt;</a>&amp; config)</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;{</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="preprocessor">#ifndef __CUDACC__</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  std::cerr &lt;&lt; <span class="stringliteral">&quot;You must use a CUDA compiler (nvcc or clang) to compile Turbo on GPU.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="keyword">auto</span> start = std::chrono::steady_clock::now();<span class="comment"></span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">  /** We start with some preprocessing to reduce the number of variables and constraints. */</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a> cp(config);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  cp.<a class="code" href="struct_abstract_domains.html#a9ab2a88ebb928131d7392df6c2613ddc">preprocess</a>();</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="keywordtype">size_t</span> shared_mem_bytes = configure_gpu(cp);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">  /** Block the signal CTRL-C to notify the threads if we must exit. */</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <a class="code" href="common__solving_8hpp.html#ad04619f00eb1d7deacc6f2326f0ace5e">block_signal_ctrlc</a>();</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">  /** This is the main data structure, we create all the data for each thread and GPU block. */</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  CPUData global(cp, shared_mem_bytes);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">  /** Start the algorithm in parallel with as many CPU threads as GPU blocks. */</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  std::vector&lt;std::thread&gt; threads;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; global.root.config.or_nodes; ++i) {</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    threads.push_back(std::thread(dive_and_solve, std::ref(global), i));</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  }</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">  /** We start the persistent kernel, that will perform the propagation. */</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  gpu_propagate&lt;&lt;&lt;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(global.root.config.or_nodes),</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      CUDA_THREADS_PER_BLOCK,</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      global.shared_mem_bytes&gt;&gt;&gt;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    (global.gpu_cubes.data(), global.shared_mem_bytes);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">  /** We wait that either the solving is interrupted, or that all threads have finished. */</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="keywordtype">size_t</span> terminated = 0;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="keywordflow">while</span>(terminated &lt; threads.size()) {</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="common__solving_8hpp.html#aceec23d67eb8f6c24010f377a52aee98">must_quit</a>() || !<a class="code" href="common__solving_8hpp.html#ae74627056bb5f54434f23cc94f5ae732">check_timeout</a>(global.root, start)) {</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      global.cpu_stop.test_and_set();</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    terminated = 0;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; global.cpu_cubes.size(); ++i) {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      <span class="keywordflow">if</span>(global.cpu_cubes[i].finished.test()) {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        ++terminated;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  }</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; t : threads) {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    t.join();</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  }</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  CUDAEX(cudaDeviceSynchronize());<span class="comment"></span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">  /** We reduce all the statistics of all threads. */</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  reduce_cubes(global);</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  global.root.print_final_solution();</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  global.root.print_mzn_statistics();</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;}</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="preprocessor">#ifdef __CUDACC__</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">/** This is the main algorithm.</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment"> * Each CPU thread will run one instance of this algorithm with a different `cube_idx`.</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment"> * It interleaves two steps until all subproblems have been solved or we reached another stopping condition (timeout, CTRL-C, pruning conditions):</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment"> *  1) Dive (function `dive`): Given a root node, follow a path in the search tree to reach a subproblem.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment"> *  2) Solve (function `solve`): Solve the subproblem using the propagate and search algorithm.</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="keywordtype">void</span> dive_and_solve(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx)</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;{</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="keyword">auto</span>&amp; cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keyword">auto</span> solving_start = cube.stats.start_timer_host();</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="keywordtype">size_t</span> num_subproblems = global.root.stats.eps_num_subproblems;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  <span class="keywordtype">size_t</span>&amp; subproblem_idx = global.cpu_cubes[cube_idx].subproblem_idx;<span class="comment"></span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">  /** In each iteration, we will solve one subproblem obtained after a diving phase. */</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <span class="keywordflow">while</span>(subproblem_idx &lt; num_subproblems &amp;&amp; !global.cpu_stop.test()) {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="keywordflow">if</span>(global.root.config.verbose_solving) {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;      std::lock_guard&lt;std::mutex&gt; print_guard(global.print_lock);</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      printf(<span class="stringliteral">&quot;%% Cube %zu solves subproblem num %zu\n&quot;</span>, cube_idx, subproblem_idx);</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    }<span class="comment"></span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">    /** The first step is to &quot;dive&quot; by committing to a search path. */</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keyword">auto</span> dive_start = cube.stats.start_timer_host();</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordtype">size_t</span> remaining_depth = dive(global, cube_idx);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a345c2df90fed0e74ea3c8926e13e5f12">Timer::DIVE</a>, dive_start);<span class="comment"></span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">    /** If we reached the subproblem without reaching a leaf node, we start the solving phase. */</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">if</span>(remaining_depth == 0) {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      solve(global, cube_idx);<span class="comment"></span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">      /** If we didn&#39;t stop solving because of an external interruption, we increase the number of subproblems solved. */</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;      <span class="keywordflow">if</span>(!global.cpu_stop.test()) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        cube.stats.eps_solved_subproblems += 1;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;      }</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    }<span class="comment"></span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">    /** We reached a leaf node before the subproblem was reached, it means a whole subtree should be skipped. */</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!global.cpu_stop.test()) {<span class="comment"></span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">      /** To skip all the paths of the subtree obtained, we perform bitwise operations.</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">       * Suppose the current path is &quot;00&quot; turn left two times, and the following search tree:</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">       *         *         depth = 0</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">       *        / \</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">       *      0    1       depth = 1</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">       *    / \   / \</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">       *   00 01 10 11     depth = 2</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">       *</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">       * If we detect a leaf node at depth 1, after only one left turn, we must skip the remaining of the subtree, in particular to avoid exploring the path &quot;01&quot;.</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">       * To achieve that, we take the current path &quot;00&quot;, shift it to the right by 1 (essentially erasing the path that has not been explored), increment it to go to the next subtree (at the same depth), and shift it back to the left to reach the first subproblem of the subtree.</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment">       * Cool huh?</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">       */</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="keywordtype">size_t</span> next_subproblem_idx = ((subproblem_idx &gt;&gt; remaining_depth) + <span class="keywordtype">size_t</span>{1}) &lt;&lt; remaining_depth;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;      global.next_subproblem.meet(ZLB&lt;size_t, bt::local_memory&gt;(next_subproblem_idx));<span class="comment"></span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment">      /** It is possible that other threads skip similar subtrees.</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment">        * Hence, we only count the subproblems skipped by the thread solving the left most subproblem. */</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="keywordflow">if</span>((subproblem_idx &amp; ((<span class="keywordtype">size_t</span>{1} &lt;&lt; remaining_depth) - <span class="keywordtype">size_t</span>{1})) == <span class="keywordtype">size_t</span>{0}) {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        cube.stats.eps_skipped_subproblems += next_subproblem_idx - subproblem_idx;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      }</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    }<span class="comment"></span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">    /** We prepare the cube to solve the next problem.</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">     * We restore the search tree to the root, and reset the EPS search strategy.</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">     * We also update the subproblem index to the next subproblem to solve. */</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">if</span>(!global.cpu_stop.test()) {<span class="comment"></span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">      /** To avoid that several cubes solve the same subproblem, we use an atomic post-increment. */</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;      subproblem_idx = global.next_subproblem.atomic()++;<span class="comment"></span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">      /** The following commented code is completely valid and does not use atomic post-increment.</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">       * But honestly, we kinda need more performance so... let&#39;s avoid reexploring subproblems. */</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      <span class="comment">// subproblem_idx = global.next_subproblem.value();</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;      <span class="comment">// global.next_subproblem.meet(ZLB&lt;size_t, bt::local_memory&gt;(subproblem_idx + size_t{1}));</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;      <span class="keywordflow">if</span>(subproblem_idx &lt; num_subproblems) {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="keyword">auto</span> start = cube.stats.start_timer_host();</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        cube.search_tree-&gt;restore(global.cpu_cubes[cube_idx].root_snapshot);</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        cube.eps_split-&gt;reset();</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a>, start);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      }</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    }</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  }<span class="comment"></span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">  /** If we did not get interrupted, this thread has explored all available subproblems.</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">   * We record this information in `num_blocks_done` simply because it helps to detect unbalanced workloads (many threads finished but not some others).</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <span class="keywordflow">if</span>(!global.cpu_stop.test()) {</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    cube.stats.num_blocks_done = 1;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  }<span class="comment"></span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">  /** We signal to the GPU kernel that this block must terminate.</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">   * The GPU block is necessarily waiting on `ready_to_propagate`, hence by setting `stop` first, using a memory fence, we ensure the GPU block is going to see it must stop.</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  global.gpu_cubes[cube_idx].stop.test_and_set();</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;  global.gpu_cubes[cube_idx].ready_to_propagate.test_and_set(cuda::std::memory_order_seq_cst);</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  global.gpu_cubes[cube_idx].ready_to_propagate.notify_one();</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160; </div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80abf61c5b43708f01f5a198843f93e521a">Timer::SOLVE</a>, solving_start);<span class="comment"></span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">  /** We signal to the main thread that we have finished our work. */</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  global.cpu_cubes[cube_idx].finished.test_and_set();</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;}</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">/** Given a root problem, we follow a predefined path in the search tree to reach a subproblem.</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment"> * This is call the &quot;dive&quot; operation.</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment"> * The path is given by `subproblem_idx` in the CPU cube (see `CPUData::next_subproblem` for more info).</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment"> * For all dives, the initial problem must be the same and the EPS search strategy must be static (always splitting the tree in the same way).</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment"> * Therefore, don&#39;t be tempted to add the objective to the initial problem because it might lead to ignoring some subproblems since the splitting decisions will differ.</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment"> * \return The remaining depth of the path if we reach a leaf node before the end of the path.</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="keywordtype">size_t</span> dive(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <span class="keyword">auto</span>&amp; cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  <span class="keywordtype">bool</span> stop_diving = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordtype">size_t</span> remaining_depth = cube.config.subproblems_power;<span class="comment"></span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">  /** The number of iterations depends on the length of the diving path. */</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  <span class="keywordflow">while</span>(remaining_depth &gt; 0 &amp;&amp; !stop_diving &amp;&amp; !global.cpu_stop.test()) {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordtype">bool</span> is_leaf_node = propagate(global, cube_idx);</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keyword">auto</span> start = cube.stats.start_timer_host();<span class="comment"></span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">    /** If we reach a leaf node before the end of the path, we stop and the remaining depth is reported to the caller. */</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">if</span>(is_leaf_node) {</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;      stop_diving = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      remaining_depth--;<span class="comment"></span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">      /** We create two branches according to the EPS search strategy. */</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;      <span class="keyword">auto</span> branches = cube.eps_split-&gt;split();</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      assert(branches.size() == 2);<span class="comment"></span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment">      /** We commit to one of the branches depending on the current value on the path.</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment">       * Suppose the depth is 3, the path is &quot;010&quot; we are currently at `remaining_depth = 1`.</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">       * We must extract the bit &quot;1&quot;, and we do so by standard bitwise manipulation.</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">       * Whenever the branch_idx is 0 means to take the left branch, and 1 means to take the right branch.</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">       */</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      <span class="keywordtype">size_t</span> branch_idx = (global.cpu_cubes[cube_idx].subproblem_idx &amp; (<span class="keywordtype">size_t</span>{1} &lt;&lt; remaining_depth)) &gt;&gt; remaining_depth;<span class="comment"></span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">      /** We immediately commit to the branch.</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">       * It has the effect of reducing the domain of the variables in `cube.store` (and `gpu_cube.store_cpu` since they are aliased).</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">       */</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      cube.ipc-&gt;deduce(branches[branch_idx]);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    }</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a>, start);</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  }</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;  <span class="keywordflow">return</span> remaining_depth;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;}</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">/** We solve a cube using the propagate and search algorithm.</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment"> * We explore the whole search tree of the cube, only stopping earlier due to pruning conditions or external stop signal (e.g. `global.cpu_stop`).</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="keywordtype">void</span> solve(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx) {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="keyword">auto</span>&amp; cpu_cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="keywordtype">bool</span> has_changed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="keyword">auto</span> start = cpu_cube.stats.start_timer_host();</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <span class="keywordflow">while</span>(has_changed &amp;&amp; !global.cpu_stop.test()) {<span class="comment"></span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">    /** Before propagating, we update the local bound with the best known global bound. */</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    update_local_best_bound(global, cube_idx);</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    cpu_cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a>, start);<span class="comment"></span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">    /** We propagate on GPU, and manage the leaf nodes (solution and failed nodes). */</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    propagate(global, cube_idx);<span class="comment"></span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">    /** We pop a new node from the search tree, ready to explore.</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">     * If the search tree becomes empty, `has_changed` will be `false`.</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    start = cpu_cube.stats.start_timer_host();</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    has_changed = cpu_cube.search_tree-&gt;deduce();</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  }</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;}</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment">/** Propagate the cube `cube_idx` on the GPU.</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment"> * Check if we reached a leaf node (solution or failed) on the CPU.</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment"> * Branching on unknown nodes is a task left to the caller.</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment"> * \return `true` if we reached a leaf node.</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="keywordtype">bool</span> propagate(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx) {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  <span class="keyword">auto</span>&amp; cpu_cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  <span class="keyword">auto</span>&amp; gpu_cube = global.gpu_cubes[cube_idx];</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  <span class="keywordtype">bool</span> is_leaf_node = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160; </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  gpu_cube.store_cpu-&gt;prefetch(0);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">  /** We signal to the GPU that it can propagate the current node.</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">   * Thereafter, we immediately wait for the GPU to finish the propagation before performing the search step.</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system);</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  gpu_cube.ready_to_propagate.test_and_set(cuda::std::memory_order_seq_cst);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  gpu_cube.ready_to_propagate.notify_one();</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  gpu_cube.ready_to_search.wait(<span class="keyword">false</span>, cuda::std::memory_order_seq_cst);</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  gpu_cube.ready_to_search.clear();</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160; </div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  <span class="keyword">auto</span> start = cpu_cube.stats.start_timer_host();</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  gpu_cube.store_cpu-&gt;prefetch(cudaCpuDeviceId);</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">  /** `on_node` updates the statistics and verifies whether we should stop (e.g. option `--cutnodes`). */</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  <span class="keywordtype">bool</span> is_pruned = cpu_cube.on_node();<span class="comment"></span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">  /** If the abstract domain is `bottom`, we reached a leaf node where the problem is unsatisfiable. */</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="keywordflow">if</span>(cpu_cube.ipc-&gt;is_bot()) {</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    cpu_cube.on_failed_node();</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  }<span class="comment"></span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment">  /** When the problem is &quot;extractable&quot;, then all variables are assigned to a single value.</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">   * It means that we have reached a solution.</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(gpu_cube.solution_found.test()) {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    is_leaf_node = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    gpu_cube.solution_found.clear();<span class="comment"></span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">    /** We save the new best solution found.</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">     * The &quot;branch-and-bound&quot; (bab) abstract domain has a local store of variable to store the best solution.</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">     * It adds a new bound constraint to the root of the search tree, such that, on backtracking the best bound is enforced.</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="keywordflow">if</span>(cpu_cube.bab-&gt;is_satisfaction() || cpu_cube.bab-&gt;compare_bound(*cpu_cube.store, cpu_cube.bab-&gt;optimum())) {</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      cpu_cube.bab-&gt;deduce();</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160; </div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      <span class="keywordtype">bool</span> print_solution = cpu_cube.is_printing_intermediate_sol();</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <span class="keywordflow">if</span>(cpu_cube.bab-&gt;is_optimization()) {<span class="comment"></span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment">        /** We share the new best bound with the other cubes. */</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        print_solution &amp;= update_global_best_bound(global, cube_idx);</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      }<span class="comment"></span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment">      /** If we print all intermediate solutions, and really found a better bound (no other thread found a better one meanwhile), we print the current solution. */</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;      <span class="keywordflow">if</span>(print_solution) {</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        std::lock_guard&lt;std::mutex&gt; print_guard(global.print_lock);</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        cpu_cube.print_solution();</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;      }<span class="comment"></span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">      /** We update the statistics, and check if we must terminate (e.g. we stop after N solutions). */</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;      is_pruned |= cpu_cube.update_solution_stats();</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    }</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  <span class="keywordflow">if</span>(is_pruned) {<span class="comment"></span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment">    /** We notify all threads that we must stop. */</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    global.cpu_stop.test_and_set();</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  }</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  cpu_cube.stats.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a>, start);</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keywordflow">return</span> is_leaf_node;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;}</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">/** Each block of this kernel executes the propagation loop on the GPU until a fixpoint is reached.</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment"> * 1) Transfer the store of variables from the CPU to the GPU.</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment"> * 2) Execute the fixpoint engine.</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment"> * 3) Transfer the store of variables from the GPU to the CPU.</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment"> * These three steps are repeated until `cpu_stop` becomes `true`.</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment"> * Each block is continuously processing a stream of nodes coming from the CPU.</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment"> * The size of `gpu_cubes` must be equal to the number of blocks.</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;__global__ <span class="keywordtype">void</span> gpu_propagate(GPUCube* gpu_cubes, <span class="keywordtype">size_t</span> shared_bytes) {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="keyword">extern</span> __shared__ <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> shared_mem[];</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  GPUCube&amp; cube = gpu_cubes[blockIdx.x];</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  GPUCube::IPC&amp; ipc = *cube.ipc_gpu;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">  /** We start by initializing the structures in shared memory (fixpoint loop engine, store of variables). */</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  __shared__ FixpointSubsetGPU&lt;BlockAsynchronousFixpointGPU&lt;true&gt;, bt::global_allocator, CUDA_THREADS_PER_BLOCK&gt; fp_engine;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  fp_engine.init(ipc.num_deductions());<span class="comment"></span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">  /** This shared variable is necessary to avoid multiple threads to read into `cube.stop.test()`,</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">   * potentially reading different values and leading to deadlock. */</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  __shared__ <span class="keywordtype">bool</span> stop;</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160; </div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  <span class="comment">// If we booked more than the default shared memory, it means we allocate the store in shared memory.</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; shared_bytes &gt; DEFAULT_SHARED_MEM_BYTES) {</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    bt::pool_allocator shared_mem_pool(shared_mem, shared_bytes);</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    cube.store_gpu-&gt;reset_data(shared_mem_pool);</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  }</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160; </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="keyword">auto</span> group = cooperative_groups::this_thread_block();</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  __syncthreads();</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160; </div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="keyword">auto</span> start = cube.timers.start_timer_device();</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {<span class="comment"></span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">    /** We wait that the CPU notifies us the store is ready to be copied and propagated. */</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      start = cube.timers.start_timer_device();</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      cube.ready_to_propagate.wait(<span class="keyword">false</span>, cuda::std::memory_order_seq_cst);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;      cube.timers.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a1122e495306c2edb5df9eb2a65953676">Timer::WAIT_CPU</a>, start);</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;      cube.ready_to_propagate.clear();</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      <span class="comment">// NOTE: Only one thread should read the atomic `cube.stop`, to avoid deadlock if one thread reads `true` and exits, while another thread reads `false`.</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;      stop = cube.stop.test();</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    }</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    __syncthreads();</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="keywordflow">if</span>(stop) {</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    }<span class="comment"></span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment">    /** We copy the CPU store into the GPU memory. */</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    start = cube.timers.start_timer_device();</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    cube.store_cpu-&gt;copy_to(group, *cube.store_gpu);</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="comment">// for(int i = threadIdx.x; i &lt; cube.events.size(); i += blockDim.x) {</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="comment">//   cube.events[i].join_top();</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="comment">//   // [cube.events_cpu[i].vid()].join_top();</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="comment">// }</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    __syncthreads();</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    start = cube.timers.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0cba79c41fc527a8e78600934dc7c3c6">Timer::TRANSFER_CPU2GPU</a>, start);<span class="comment"></span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment">    /** This is the main propagation algorithm: the current node is propagated in parallel. */</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keywordtype">int</span> fp_iterations;</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">switch</span>(cube.fp_kind) {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      <span class="keywordflow">case</span> <a class="code" href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558">FixpointKind::AC1</a>:</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;          [&amp;](<span class="keywordtype">int</span> i){ <span class="keywordflow">return</span> ipc.deduce(i); },</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;          [&amp;](){ <span class="keywordflow">return</span> ipc.is_bot(); });</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;      <span class="keywordflow">case</span> <a class="code" href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb">FixpointKind::WAC1</a>:</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="keywordflow">if</span>(fp_engine.num_active() &lt;= cube.wac1_threshold) {</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;          fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            [&amp;](<span class="keywordtype">int</span> i){ <span class="keywordflow">return</span> ipc.deduce(i); },</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            [&amp;](){ <span class="keywordflow">return</span> ipc.is_bot(); });</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        }</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;          fp_iterations = fp_engine.fixpoint(</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;            [&amp;](<span class="keywordtype">int</span> i){ <span class="keywordflow">return</span> warp_fixpoint&lt;CUDA_THREADS_PER_BLOCK&gt;(ipc, i); },</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            [&amp;](){ <span class="keywordflow">return</span> ipc.is_bot(); });</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        }</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    }</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    start = cube.timers.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89">Timer::FIXPOINT</a>, start);</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    cube.store_gpu-&gt;copy_to(group, *cube.store_cpu);</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    __syncthreads();</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    start = cube.timers.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a41dda7a604badd52fe521cb713e7a39f">Timer::TRANSFER_GPU2CPU</a>, start);</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      cube.fp_iterations += fp_iterations;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    }</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <span class="keywordtype">bool</span> is_leaf_node = cube.store_gpu-&gt;is_bot();</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    <span class="keywordflow">if</span>(!is_leaf_node) {</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;      fp_engine.select([&amp;](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> !ipc.ask(i); });</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;      cube.timers.stop_timer(<a class="code" href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df">Timer::SELECT_FP_FUNCTIONS</a>, start);</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;      <span class="keywordflow">if</span>(fp_engine.num_active() == 0) {</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        is_leaf_node = cube.store_gpu-&gt;template is_extractable&lt;AtomicExtraction&gt;(group);</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">if</span>(threadIdx.x == 0 &amp;&amp; is_leaf_node) {</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;          cube.solution_found.test_and_set();</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        }</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      }</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    }</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system);</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    __syncthreads();<span class="comment"></span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="comment">    /** We notify to the CPU that we have propagated the current node. */</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    <span class="keywordflow">if</span>(threadIdx.x == 0) {</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      cube.ready_to_search.test_and_set(cuda::std::memory_order_seq_cst);</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;      cube.ready_to_search.notify_one();</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    }</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    <span class="comment">// Backtrack detected.</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    <span class="keywordflow">if</span>(is_leaf_node) {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      fp_engine.reset(ipc.num_deductions());</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    }</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  }</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  fp_engine.destroy();</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;}</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment">/** We update the bound found by the current cube so it is visible to all other cubes.</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment"> * Note that this operation might not always succeed, which is okay, the best bound is still saved locally in `gpu_cubes` and then reduced at the end (in `reduce_cubes`).</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment"> * The worst that can happen is that a best bound is found twice, which does not prevent the correctness of the algorithm.</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="comment"> * \return `true` if the best bound has changed. Can return `false` if the best bound was updated by another thread meanwhile.</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="keywordtype">bool</span> update_global_best_bound(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx) {</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  assert(cube.bab-&gt;is_optimization());</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  <span class="comment">// We retrieve the best bound found by the current cube.</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  <span class="keyword">auto</span> local_best = cube.bab-&gt;optimum().project(cube.bab-&gt;objective_var());</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <span class="comment">// We update the global `best_bound`.</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  <span class="keywordflow">if</span>(cube.bab-&gt;is_maximization()) {</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keywordflow">return</span> global.best_bound.meet_lb(dual_bound&lt;Itv::LB&gt;(local_best.ub()));</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  }</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="keywordflow">return</span> global.best_bound.meet_ub(dual_bound&lt;Itv::UB&gt;(local_best.lb()));</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;}</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="comment">/** This function essentially does the converse operation of `update_global_best_bound`.</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="comment"> * We directly update the store with the global best bound.</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="comment"> * This function should be called in each node, since the best bound is erased on backtracking (it is not included in the snapshot).</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="keywordtype">void</span> update_local_best_bound(CPUData&amp; global, <span class="keywordtype">size_t</span> cube_idx) {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  <span class="keywordflow">if</span>(global.cpu_cubes[cube_idx].cube.bab-&gt;is_optimization()) {</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    <span class="keyword">auto</span>&amp; cube = global.cpu_cubes[cube_idx].cube;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    VarEnv&lt;bt::standard_allocator&gt; empty_env{};</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="keyword">auto</span> best_formula = cube.bab-&gt;template deinterpret_best_bound&lt;bt::standard_allocator&gt;(</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;      cube.bab-&gt;is_maximization()</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;      ? <a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a>(dual_bound&lt;Itv::UB&gt;(global.best_bound.lb()))</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;      : <a class="code" href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a>(dual_bound&lt;Itv::LB&gt;(global.best_bound.ub())));</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    IDiagnostics diagnostics;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    <span class="keywordtype">bool</span> r = interpret_and_tell(best_formula, empty_env, *cube.store, diagnostics);</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    assert(r);</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  }</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;}</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="comment">/** After solving, we merge all the statistics and best solutions from all cubes together, before printing them. */</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="keywordtype">void</span> reduce_cubes(CPUData&amp; global) {</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; global.cpu_cubes.size(); ++i) {<span class="comment"></span></div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment">    /** `meet` is the merge operation. */</span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    global.cpu_cubes[i].cube.stats.meet(global.gpu_cubes[i].timers);</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    global.root.meet(global.cpu_cubes[i].cube);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    global.root.stats.fixpoint_iterations += global.gpu_cubes[i].fp_iterations;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;  }</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;}</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="comment">/** We configure the GPU according to the user configuration:</span></div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="comment"> * 1) Decide the size of the shared memory and return it.</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="comment"> * 2) Increase the stack size if needed.</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment"> * 3) Increase the global memory allocation (we set the limit to around 90% of the global memory).</span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="comment"> * 4) Guess the &quot;best&quot; number of threads per block and the number of blocks per SM, if not provided.</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="keywordtype">size_t</span> configure_gpu(<a class="code" href="struct_abstract_domains.html">CP&lt;Itv&gt;</a>&amp; cp) {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  <span class="keyword">auto</span>&amp; config = cp.<a class="code" href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">config</a>;<span class="comment"></span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment">  /** Configure the shared memory size. */</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;  <span class="keywordtype">size_t</span> alignment_overhead = 200;</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  <span class="keywordtype">size_t</span> shared_mem_bytes = DEFAULT_SHARED_MEM_BYTES + alignment_overhead + (cp.<a class="code" href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">store</a>-&gt;vars() * <span class="keyword">sizeof</span>(GPUCube::Itv1));</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  cudaDeviceProp deviceProp;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  cudaGetDeviceProperties(&amp;deviceProp, 0);</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  <span class="keywordflow">if</span>(shared_mem_bytes &gt;= deviceProp.sharedMemPerBlock || config.only_global_memory) {</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    shared_mem_bytes = DEFAULT_SHARED_MEM_BYTES;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    printf(<span class="stringliteral">&quot;%%%%%%mzn-stat: memory_configuration=\&quot;global\&quot;\n&quot;</span>);</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  }</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    printf(<span class="stringliteral">&quot;%%%%%%mzn-stat: memory_configuration=\&quot;store_shared\&quot;\n&quot;</span>);</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  }</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  printf(<span class="stringliteral">&quot;%%%%%%mzn-stat: shared_mem=%&quot;</span> PRIu64 <span class="stringliteral">&quot;\n&quot;</span>, shared_mem_bytes);</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160; </div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;  <span class="keywordtype">int</span> hint_num_blocks;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  <span class="keywordtype">int</span> hint_num_threads;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  CUDAE(cudaOccupancyMaxPotentialBlockSize(&amp;hint_num_blocks, &amp;hint_num_threads, (<span class="keywordtype">void</span>*) gpu_propagate, shared_mem_bytes));</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  <span class="keywordtype">size_t</span> total_global_mem = deviceProp.totalGlobalMem;</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="keywordtype">size_t</span> num_sm = deviceProp.multiProcessorCount;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  config.or_nodes = (config.or_nodes == 0) ? hint_num_blocks : config.or_nodes;</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  <span class="comment">// The stack allocated depends on the maximum number of threads per SM, not on the actual number of threads per block.</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  <span class="keywordtype">size_t</span> total_stack_size = num_sm * deviceProp.maxThreadsPerMultiProcessor * config.stack_kb * 1000;</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;  <span class="keywordtype">size_t</span> remaining_global_mem = total_global_mem - total_stack_size;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;  remaining_global_mem -= remaining_global_mem / 10; <span class="comment">// We leave 10% of global memory free for CUDA allocations, not sure if it is useful though.</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  CUDAEX(cudaDeviceSetLimit(cudaLimitStackSize, config.stack_kb*1000));</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;  CUDAEX(cudaDeviceSetLimit(cudaLimitMallocHeapSize, remaining_global_mem));</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  <a class="code" href="statistics_8hpp.html#aa706e08664f7a52ec805a8257bcfb593">print_memory_statistics</a>(<span class="stringliteral">&quot;stack_memory&quot;</span>, total_stack_size);</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  <a class="code" href="statistics_8hpp.html#aa706e08664f7a52ec805a8257bcfb593">print_memory_statistics</a>(<span class="stringliteral">&quot;heap_memory&quot;</span>, remaining_global_mem);</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  printf(<span class="stringliteral">&quot;%% or_nodes=%zu\n&quot;</span>, config.or_nodes);</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;  <span class="keywordtype">int</span> num_blocks;</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;  cudaOccupancyMaxActiveBlocksPerMultiprocessor(&amp;num_blocks, (<span class="keywordtype">void</span>*) gpu_propagate, CUDA_THREADS_PER_BLOCK, shared_mem_bytes);</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  printf(<span class="stringliteral">&quot;%% max_blocks_per_sm=%d\n&quot;</span>, num_blocks);</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;  <span class="keywordflow">return</span> shared_mem_bytes;</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;}</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160; </div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="preprocessor">#endif </span><span class="comment">// __CUDACC__</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="preprocessor">#endif </span><span class="comment">// TURBO_HYBRID_DIVE_AND_SOLVE_HPP</span></div>
<div class="ttc" id="acommon__solving_8hpp_html"><div class="ttname"><a href="common__solving_8hpp.html">common_solving.hpp</a></div></div>
<div class="ttc" id="acommon__solving_8hpp_html_ab7cbd01c4c671c527f582fffb1125923"><div class="ttname"><a href="common__solving_8hpp.html#ab7cbd01c4c671c527f582fffb1125923">Itv</a></div><div class="ttdeci">Interval&lt; local::ZLB &gt; Itv</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:720</div></div>
<div class="ttc" id="acommon__solving_8hpp_html_aceec23d67eb8f6c24010f377a52aee98"><div class="ttname"><a href="common__solving_8hpp.html#aceec23d67eb8f6c24010f377a52aee98">must_quit</a></div><div class="ttdeci">bool must_quit()</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:89</div></div>
<div class="ttc" id="acommon__solving_8hpp_html_ad04619f00eb1d7deacc6f2326f0ace5e"><div class="ttname"><a href="common__solving_8hpp.html#ad04619f00eb1d7deacc6f2326f0ace5e">block_signal_ctrlc</a></div><div class="ttdeci">void block_signal_ctrlc()</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:77</div></div>
<div class="ttc" id="acommon__solving_8hpp_html_ae74627056bb5f54434f23cc94f5ae732"><div class="ttname"><a href="common__solving_8hpp.html#ae74627056bb5f54434f23cc94f5ae732">check_timeout</a></div><div class="ttdeci">bool check_timeout(A &amp;a, const Timepoint &amp;start)</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:101</div></div>
<div class="ttc" id="aconfig_8hpp_html_a5ee8f81cc01d530506acbb3c037a751b"><div class="ttname"><a href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751b">FixpointKind</a></div><div class="ttdeci">FixpointKind</div><div class="ttdef"><b>Definition:</b> config.hpp:23</div></div>
<div class="ttc" id="aconfig_8hpp_html_a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558"><div class="ttname"><a href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751ba06d5bf2275007ca8b3dd60a2d978e558">FixpointKind::AC1</a></div><div class="ttdeci">@ AC1</div></div>
<div class="ttc" id="aconfig_8hpp_html_a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb"><div class="ttname"><a href="config_8hpp.html#a5ee8f81cc01d530506acbb3c037a751baf7d56c9ee0b42b33964b26d10d655eeb">FixpointKind::WAC1</a></div><div class="ttdeci">@ WAC1</div></div>
<div class="ttc" id="ahybrid__dive__and__solve_8hpp_html_ab002d8e461e9e10df5c63ee20a3e33a6"><div class="ttname"><a href="hybrid__dive__and__solve_8hpp.html#ab002d8e461e9e10df5c63ee20a3e33a6">hybrid_dive_and_solve</a></div><div class="ttdeci">void hybrid_dive_and_solve(const Configuration&lt; battery::standard_allocator &gt; &amp;config)</div><div class="ttdef"><b>Definition:</b> hybrid_dive_and_solve.hpp:264</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a0cba79c41fc527a8e78600934dc7c3c6"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0cba79c41fc527a8e78600934dc7c3c6">Timer::TRANSFER_CPU2GPU</a></div><div class="ttdeci">@ TRANSFER_CPU2GPU</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a0f544d682c3a664870f025f48c4b04b5">Timer::SEARCH</a></div><div class="ttdeci">@ SEARCH</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a1122e495306c2edb5df9eb2a65953676"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a1122e495306c2edb5df9eb2a65953676">Timer::WAIT_CPU</a></div><div class="ttdeci">@ WAIT_CPU</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a345c2df90fed0e74ea3c8926e13e5f12"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a345c2df90fed0e74ea3c8926e13e5f12">Timer::DIVE</a></div><div class="ttdeci">@ DIVE</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a41dda7a604badd52fe521cb713e7a39f"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a41dda7a604badd52fe521cb713e7a39f">Timer::TRANSFER_GPU2CPU</a></div><div class="ttdeci">@ TRANSFER_GPU2CPU</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a433c1649ecd09dc6e8c965d31f830f89">Timer::FIXPOINT</a></div><div class="ttdeci">@ FIXPOINT</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80a79bde01db3ccc1f5ff856a11a34c20df">Timer::SELECT_FP_FUNCTIONS</a></div><div class="ttdeci">@ SELECT_FP_FUNCTIONS</div></div>
<div class="ttc" id="astatistics_8hpp_html_a6e0035edd58cc6ca8c94b5f9723a0d80abf61c5b43708f01f5a198843f93e521a"><div class="ttname"><a href="statistics_8hpp.html#a6e0035edd58cc6ca8c94b5f9723a0d80abf61c5b43708f01f5a198843f93e521a">Timer::SOLVE</a></div><div class="ttdeci">@ SOLVE</div></div>
<div class="ttc" id="astatistics_8hpp_html_aa706e08664f7a52ec805a8257bcfb593"><div class="ttname"><a href="statistics_8hpp.html#aa706e08664f7a52ec805a8257bcfb593">print_memory_statistics</a></div><div class="ttdeci">void print_memory_statistics(const char *key, size_t bytes)</div><div class="ttdef"><b>Definition:</b> statistics.hpp:12</div></div>
<div class="ttc" id="astruct_abstract_domains_html"><div class="ttname"><a href="struct_abstract_domains.html">AbstractDomains</a></div><div class="ttdef"><b>Definition:</b> common_solving.hpp:155</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a0aa5ac01e4f4a2a8b2811edca6eb8ef9"><div class="ttname"><a href="struct_abstract_domains.html#a0aa5ac01e4f4a2a8b2811edca6eb8ef9">AbstractDomains::config</a></div><div class="ttdeci">Configuration&lt; BasicAllocator &gt; config</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:282</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a6163aae266ebdf3370b3fedc63c150a3"><div class="ttname"><a href="struct_abstract_domains.html#a6163aae266ebdf3370b3fedc63c150a3">AbstractDomains::store</a></div><div class="ttdeci">abstract_ptr&lt; IStore &gt; store</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:267</div></div>
<div class="ttc" id="astruct_abstract_domains_html_a9ab2a88ebb928131d7392df6c2613ddc"><div class="ttname"><a href="struct_abstract_domains.html#a9ab2a88ebb928131d7392df6c2613ddc">AbstractDomains::preprocess</a></div><div class="ttdeci">void preprocess()</div><div class="ttdef"><b>Definition:</b> common_solving.hpp:568</div></div>
<div class="ttc" id="astruct_configuration_html"><div class="ttname"><a href="struct_configuration.html">Configuration</a></div><div class="ttdef"><b>Definition:</b> config.hpp:34</div></div>
<div class="ttc" id="astruct_configuration_html_a6400dfba9cd09ea3050d18c71c8d47fb"><div class="ttname"><a href="struct_configuration.html#a6400dfba9cd09ea3050d18c71c8d47fb">Configuration::or_nodes</a></div><div class="ttdeci">size_t or_nodes</div><div class="ttdef"><b>Definition:</b> config.hpp:47</div></div>
<div class="ttc" id="astruct_configuration_html_ad4cca6861f2269be0f65d9d331a5aedd"><div class="ttname"><a href="struct_configuration.html#ad4cca6861f2269be0f65d9d331a5aedd">Configuration::fixpoint</a></div><div class="ttdeci">FixpointKind fixpoint</div><div class="ttdef"><b>Definition:</b> config.hpp:51</div></div>
<div class="ttc" id="astruct_configuration_html_ad83964f3057297a5fa72be9a1b63a80b"><div class="ttname"><a href="struct_configuration.html#ad83964f3057297a5fa72be9a1b63a80b">Configuration::wac1_threshold</a></div><div class="ttdeci">size_t wac1_threshold</div><div class="ttdef"><b>Definition:</b> config.hpp:52</div></div>
<div class="ttc" id="astruct_timing_statistics_html"><div class="ttname"><a href="struct_timing_statistics.html">TimingStatistics</a></div><div class="ttdef"><b>Definition:</b> statistics.hpp:41</div></div>
<div class="ttc" id="astruct_unique_light_alloc_html"><div class="ttname"><a href="struct_unique_light_alloc.html">UniqueLightAlloc</a></div><div class="ttdef"><b>Definition:</b> common_solving.hpp:135</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="hybrid__dive__and__solve_8hpp.html">hybrid_dive_and_solve.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
