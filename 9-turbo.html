<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>v1.2.{1-3}: Open Hackathon - Lattice Land Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lattice Land Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="v12123-open-hackathon"><a class="header" href="#v12123-open-hackathon">v1.2.{1,2,3}: Open Hackathon</a></h1>
<p><em>17 October 2024.</em> We are participating in the <a href="https://www.openhackathons.org/s/siteevent/a0C5e000009W8MqEAK/se000307?p=4OVal7qBAY6%2FFLWHyETbkwh66SClhyelBl79%2FR1tID1ERZR9ly9oZEseBU%2B%2FQOAe%2B1PJ%2BAdY%2F%2F62bDJM0SlZYg%3D%3D">Poland Open Hackathon</a>.
This page summarizes our progresses and experience.
The hackathon spans 2 weeks, beginning with a meeting on 15 October to explain the GH200 architecture that powers the <a href="https://www.cyfronet.pl/en/19951,artykul,helios_supercomputer.html">Helios HPC</a>, how to connect and run jobs on it, and then discuss with our mentors: Akif Çördük (Nvidia), Alice Boucher (Nvidia), Michel Herrera Sanchez.
Among the mentors, we are fortunate to have two engineers from Nvidia working on <a href="https://developer.nvidia.com/blog/record-breaking-nvidia-cuopt-algorithms-deliver-route-optimization-solutions-100x-faster/">cuOpt</a> and a <a href="https://developer.nvidia.com/blog/accelerate-large-linear-programming-problems-with-nvidia-cuopt/">linear programming solver</a>.</p>
<p>During the first meeting, I try to compile Turbo on the Helios HPC and... boom, <code>nvcc</code> is killed by the memory manager due to excessive memory usage.
I encountered a similar problem last year and reported the bug to Nvidia.
The bug was closed as "will not fix", citing that our kernel is simply too large and needed to be split into smaller kernels.
By adding <code>__noinline__</code> attributes in key places, I could work around the bug and compile it on <code>sm_70</code> and <code>sm_86</code> architectures.
It seems that for <code>sm_90</code> architectures (of the GH200), the compiler is again doing very aggressive optimizations, and Turbo is just too large for it.</p>
<p>Although the full GPU version avoids memory transfers between the CPU and GPU, we still hit other bottlenecks due to the kernel's size such as high register pressure.
The next meeting is planned on 22 October, for the whole day, and our code is not compiling---not the best start for this hackathon.
After a few days, I developed a new hybrid algorithm where the propagation loop runs on the GPU, and the search runs on the CPU.
This solution successfully compiles on Helios.</p>
<p>The main event takes place online on 28, 29 and 30 of October and each time we stayed connected online and discussed with the mentors as needed from around 9AM to 3 or 4PM.</p>
<p>Let's see an executive summary of this hackathon:</p>
<ul>
<li><em>15 October 2024</em>: Turbo 1.2.0 is not compiling on Helios (ptxas is memkill).
<ul>
<li>Reason: Kernel is too large.</li>
</ul>
</li>
<li><em>22 October 2024</em>: New design with a smaller kernel (Turbo v1.2.1).
<ul>
<li>The CPU controls the search loop, a kernel is run each time we propagate.</li>
<li>Use <code>N</code> CPU threads, each launching a kernel with 1 block using stream.</li>
<li>Compiling, but too slow, too many streams (only <code>1628</code> nodes per second...).</li>
</ul>
</li>
<li><em>28 October 2024</em>: New design with a persistent kernel (v1.2.2).
<ul>
<li><code>N</code> CPU threads communicate with <code>N</code> blocks of a persistent kernel.</li>
<li>Compiling, on-par with the full GPU version.</li>
</ul>
</li>
<li><em>30 October 2024</em>: Deactivation of entailed propagators (v1.2.3).
<ul>
<li>Use <a href="https://nvidia.github.io/cccl/cub/api/classcub_1_1BlockScan.html">CUB scan</a> to deactivate propagators that are entailed during search.</li>
<li>Obtained 10% speed-up.</li>
</ul>
</li>
</ul>
<h2 id="hybrid-dive-and-solve-algorithm-v122"><a class="header" href="#hybrid-dive-and-solve-algorithm-v122">Hybrid Dive and Solve Algorithm (v1.2.2)</a></h2>
<p>If you don't know the "propagate-and-search" algorithm of constraint programming, please watch <a href="https://youtu.be/vAzGmkOJveY">this video</a> I made for the AAAI conference (thanks Covid), starting at 5'30'' (if you are familiar with GPUs).
It also explains how this algorithm is executed in parallel on GPU.</p>
<p>We keep the same algorithm as full-GPU Turbo (option <code>-arch=gpu</code>) but only performs the propagation on the GPU (option <code>-arch=hybrid</code>).
The algorithm consists of two parts:</p>
<ol>
<li><code>dive(root, path)</code>: From the root of the search tree, commit to the path given to reach a node <code>subroot</code> at a fixed depth.</li>
<li><code>solve(subroot)</code>: Solve the subproblem <code>subroot</code> by propagate and search.</li>
<li>When a subproblem has been completely explored, we take a new path to explore if there is any remaining.</li>
</ol>
<p>During the dive and solve operations, the propagation step is always executed on the GPU.
Starting from version 1.2.2, we execute a single kernel and each CPU thread interacts with a single block of that persistent kernel.
We compare the full-GPU architecture and this hybrid architecture in the following table (this is on my desktop computer (RTX A5000) due to 1.2.0 not compiling on Helios).</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.0</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.0</th><th>Median</th><th>Δ v1.2.0</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>93.93</td><td>-4%</td><td>7</td><td>10271.03</td><td>-1%</td><td>2519.29</td><td>-19%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>95.76</td><td>-2%</td><td>7</td><td>60155.16</td><td>-1%</td><td>31502.75</td><td>-1%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>99.76</td><td>+2%</td><td>6</td><td>16.77</td><td>+15%</td><td>9.00</td><td>0%</td></tr>
</tbody></table>
</div>
<p>The hybrid version is slightly less efficient than with the full-GPU version, but considering the number of round-trips between the CPU and GPU I was expecting worst results.
Nonetheless, because the kernel is now smaller, we can execute more blocks in parallel.
With 128 blocks, we surpass the version v1.2.0 as shown in the following table.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.0</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.0</th><th>Median</th><th>Δ v1.2.0</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>94.97</td><td>+5%</td><td>8</td><td>13475.41</td><td>+29%</td><td>3029.66</td><td>-2%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>94.53</td><td>+4%</td><td>8</td><td>81399.98</td><td>+33%</td><td>33540.01</td><td>+5%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>97.39</td><td>0%</td><td>11</td><td>15.43</td><td>+5%</td><td>9.20</td><td>+2%</td></tr>
</tbody></table>
</div>
<p>In terms of the best objectives found, the hybrid version performs better with 64 blocks than with 128 blocks.
Indeed, with 128 blocks, we explore a wider search tree at the cost of exploring fewer nodes per block.
It is known as the exploration-exploitation dilemma.
Until we implement better search strategies and test with a longer timeout, I prefer to stick to the nodes per second metric in order to compare the raw efficiency.</p>
<p><img src="turbo-v1.2/turbogpu-v1.2.0-vs-turbohybrid64-v1.2.2.png" alt="TurboGPU-v1.2.0 vs TurboHybrid64-v1.2.2" />
<img src="turbo-v1.2/turbogpu-v1.2.0-vs-turbohybrid128-v1.2.2.png" alt="TurboGPU-v1.2.0 vs TurboHybrid128-v1.2.2" /></p>
<h2 id="deactivation-of-entailed-propagators-and-no-atomic-v123"><a class="header" href="#deactivation-of-entailed-propagators-and-no-atomic-v123">Deactivation of Entailed Propagators and No Atomic (v1.2.3)</a></h2>
<p>A frequent optimization is to avoid calling propagators that are entailed in the fixpoint loop.
To illustrate with a simple example, if <code>x=[1,3]</code>, we know for certain that <code>x &gt; 0</code> is satisfied and will remain satisfy for the rest of the exploration of the current subtree.
Therefore, the propagator implementing <code>x &gt; 0</code> no longer needs to be executed.</p>
<p>To deactivate entailed propagators, we maintain an array <code>vector&lt;int&gt; indexes</code> giving the indexes of the propagators not yet entailed.
The fixpoint loop can be easily modified to iterate over <code>indexes</code> instead of iterating from <code>0</code> to <code>P</code> where <code>P</code> is the number of propagators.</p>
<p>Furthermore, it is easy to verify in parallel that each propagator is entailed, as this is a read-only check.
We can assign each thread to one propagator to check the entailment.
This step produces a mask <code>vector&lt;bool&gt; mask</code> representing which propagators are still active.
The challenging part is to create the new array <code>indexes</code> representing that subset in parallel.
This is a known problem in GPU programming and the scan algorithm (aka. prefix sum) allows to parallelize this step and to copy into a new array <code>indexes2</code> only the values <code>indexes[i]</code> such that <code>mask[indexes[i]]</code> is <code>true</code>.</p>
<p>This version comes with a more important optimization.
It is actually known that tearing on integers is not possible in CUDA (i.e., a thread writing half of an integer while the other thread write the other half).
Although it is not formally documented, much code relies on load/store atomicity of primitive types according to our mentors.
Therefore, we can safely remove the atomic unlike what I concluded in the <a href="https://lattice-land.github.io/8-turbo.html">v1.2.0 post</a>.</p>
<p>This optimization proves very useful with a 17% increase in nodes per second with 64 blocks, and a 28% increase with 128 blocks.
Previously, removing atomic variables accounted for a 13% increase, which is likely a key factor in this speed-up. Deactivating propagators does not hurt, but seems to be less critical than other optimizations.</p>
<p>(<code>-or 64 -arch hybrid</code>)</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.2</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.2</th><th>Median</th><th>Δ v1.2.2</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>99.59</td><td>+17%</td><td>14</td><td>11786.66</td><td>+15%</td><td>3252.29</td><td>+29%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>100.00</td><td>+24%</td><td>16</td><td>81532.87</td><td>+36%</td><td>43905.01</td><td>+39%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>99.08</td><td>+5%</td><td>4</td><td>18.60</td><td>+11%</td><td>9.10</td><td>+1%</td></tr>
</tbody></table>
</div>
<p>(<code>-or 128 -arch hybrid</code>)</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.2</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.2</th><th>Median</th><th>Δ v1.2.2</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>99.96</td><td>+28%</td><td>15</td><td>18543.27</td><td>+38%</td><td>4082.88</td><td>+35%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>100.00</td><td>+35%</td><td>16</td><td>129459.21</td><td>+59%</td><td>48995.62</td><td>+46%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>98.94</td><td>+5%</td><td>4</td><td>17.00</td><td>+10%</td><td>9.19</td><td>0%</td></tr>
</tbody></table>
</div>
<p>This new version also dominates the previous one in terms of objective found.
Further, we almost close the gap with the full GPU version v1.2.0 which remains better on only one problem.</p>
<p><img src="turbo-v1.2/turbohybrid64-v1.2.2-vs-turbohybrid64-v1.2.3.png" alt="TurboHybrid64-v1.2.2 vs TurboHybrid64-v1.2.3" />
<img src="turbo-v1.2/turbohybrid128-v1.2.2-vs-turbohybrid128-v1.2.3.png" alt="TurboHybrid128-v1.2.2 vs TurboHybrid128-v1.2.3" />
<img src="turbo-v1.2/turbogpu-v1.2.0-vs-turbohybrid128-v1.2.3.png" alt="TurboGPU-v1.2.0 vs TurboHybrid128-v1.2.3" /></p>
<h2 id="helios-benchmarks"><a class="header" href="#helios-benchmarks">Helios Benchmarks</a></h2>
<p>We tested the new versions on Helios which is equipped with a superchip GH200 consisting of a CPU of 72 cores and a H200 GPU with 132 SMs whereas my desktop has a CPU with 10 cores and a RTX A5000 GPU with 64 SMs.
The speedup observed with the GH200 demonstrates excellent scalability.
Doubling the number of SMs effectively doubles the number of nodes per second.
The following table compares the hybrid versions with 1 block per SM on my desktop and Helios.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.2</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.2</th><th>Median</th><th>Δ v1.2.2</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>100.00</td><td>+128%</td><td>16</td><td>33232.29</td><td>+224%</td><td>7796.88</td><td>+209%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>100.00</td><td>+137%</td><td>16</td><td>184996.45</td><td>+208%</td><td>69359.75</td><td>+120%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>98.32</td><td>+4%</td><td>6</td><td>19.11</td><td>+14%</td><td>10.03</td><td>+11%</td></tr>
</tbody></table>
</div>
<p>We have more than a linear scaling, probably due to the larger L1 cache and other improvement in the H200 GPU.
We further improve the nodes per second metric by using 2 blocks per SM (264 blocks).</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.2</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.2</th><th>Median</th><th>Δ v1.2.2</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>99.83</td><td>+21%</td><td>14</td><td>40330.87</td><td>+21%</td><td>9945.53</td><td>+28%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>98.86</td><td>+18%</td><td>15</td><td>258809.97</td><td>+40%</td><td>78749.49</td><td>+14%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>97.30</td><td>-2%</td><td>10</td><td>18.38</td><td>-4%</td><td>9.37</td><td>-7%</td></tr>
</tbody></table>
</div>
<p>Finally, the version 1.2.3 gives an additional speedup, comparable than the one obtained on my desktop, as shown in the next table.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.2</th><th>#best (_/16)</th><th>Average</th><th>Δ v1.2.2</th><th>Median</th><th>Δ v1.2.2</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>99.70</td><td>+26%</td><td>14</td><td>45520.83</td><td>+13%</td><td>15676.14</td><td>+58%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>100.00</td><td>+36%</td><td>16</td><td>360362.70</td><td>+39%</td><td>116916.62</td><td>+48%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>98.97</td><td>+7%</td><td>4</td><td>20.17</td><td>+10%</td><td>10.45</td><td>+12%</td></tr>
</tbody></table>
</div>
<h2 id="summary-hackathon"><a class="header" href="#summary-hackathon">Summary Hackathon</a></h2>
<p>This hackathon was highly productive.
It allowed me to verify the correctness of the persistent kernel design (v1.2.2) and to use CUB to eliminate entailed propagators (v1.2.3).
More importantly, I discussed the overall design of Turbo, addressing the overly generic approach (code working both on CPU and GPU, using modern C++ patterns, etc.) which hindered performance.</p>
<p>During the three days, we also discussed a new design of propagators and the result will be in a post-hackathon version 1.2.4, so stay tuned!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">short_uid</th><th style="text-align: right">avg_nodes_per_second</th><th style="text-align: right">problem_optimal</th><th style="text-align: right">problem_sat</th><th style="text-align: right">problem_unknown</th></tr></thead><tbody>
<tr><td style="text-align: left">turbo.hybrid_GH200_1.2.3_4096_264</td><td style="text-align: right">45520.8</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_GH200_1.2.2_4096_264</td><td style="text-align: right">40330.9</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_GH200_1.2.3_4096_132</td><td style="text-align: right">36589.3</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_GH200_1.2.2_4096_132</td><td style="text-align: right">33232.3</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_RTXA5000_1.2.3_4096_128</td><td style="text-align: right">18543.3</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_RTXA5000_1.2.2_4096_128</td><td style="text-align: right">13475.4</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_RTXA5000_1.2.3_4096_64</td><td style="text-align: right">11786.7</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.gpu_RTXA5000_1.2.0_4096_64_noatomics</td><td style="text-align: right">11684.4</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.gpu_RTXA5000_1.2.0_4096_64</td><td style="text-align: right">10412.7</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_RTXA5000_1.2.2_hybrid_4096_64</td><td style="text-align: right">10271</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.hybrid_RTXA5000_1.2.1_hybrid_4096_64</td><td style="text-align: right">1628.89</td><td style="text-align: right">0</td><td style="text-align: right">14</td><td style="text-align: right">2</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="8-turbo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="10-turbo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="8-turbo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="10-turbo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
