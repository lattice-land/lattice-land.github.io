<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Land Core Library: lala Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Land Core Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacelala.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lala Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelala_1_1local"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala_1_1local.html">local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_deps.html">AbstractDeps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_b.html">B</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_gauss_seidel_iteration.html">GaussSeidelIteration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_fixpoint_subset_c_p_u.html">FixpointSubsetCPU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_t_formula.html">TFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_variable.html">Variable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_list_var_index.html">ListVarIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_hash_map_var_index.html">HashMapVarIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_dispatch_index.html">DispatchIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_var_env.html">VarEnv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_sort.html">Sort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_simplifier.html">Simplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_dec.html">PreSDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_inc.html">PreSInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_n_bitset.html">NBitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_b.html">PreB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_non_atomic_extraction.html">NonAtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_atomic_extraction.html">AtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_v_store.html">VStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a609554da1e3f1cb56804fcca736e7d70"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a609554da1e3f1cb56804fcca736e7d70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a609554da1e3f1cb56804fcca736e7d70">abstract_ptr</a> = battery::shared_ptr&lt; A, typename A::allocator_type &gt;</td></tr>
<tr class="separator:a609554da1e3f1cb56804fcca736e7d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f389c51804929bfb3e6d682d77ff0"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:acb9f389c51804929bfb3e6d682d77ff0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a> = battery::string&lt; Allocator &gt;</td></tr>
<tr class="separator:acb9f389c51804929bfb3e6d682d77ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c626918dd7c19ff046f5cebaabec18f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> = int</td></tr>
<tr class="separator:a6c626918dd7c19ff046f5cebaabec18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2397fa063de70fb2241dc9ea08c47800"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2397fa063de70fb2241dc9ea08c47800">logic_bool</a> = bool</td></tr>
<tr class="separator:a2397fa063de70fb2241dc9ea08c47800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d30ab753875ab1fc49e3b4f195719"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> = long long int</td></tr>
<tr class="separator:a303d30ab753875ab1fc49e3b4f195719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08adbd4b2483ca2b14db01ba8769ef93"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a08adbd4b2483ca2b14db01ba8769ef93">logic_real</a> = battery::tuple&lt; double, double &gt;</td></tr>
<tr class="separator:a08adbd4b2483ca2b14db01ba8769ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3475914a4dbd0a377ee399dd9adaa8"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a5d3475914a4dbd0a377ee399dd9adaa8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a5d3475914a4dbd0a377ee399dd9adaa8">logic_set</a> = battery::vector&lt; battery::tuple&lt; F, F &gt;, typename F::allocator_type &gt;</td></tr>
<tr class="separator:a5d3475914a4dbd0a377ee399dd9adaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b6a9a7062df6a94c98818a9644fc74"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a14b6a9a7062df6a94c98818a9644fc74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a14b6a9a7062df6a94c98818a9644fc74">ZLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; <a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a14b6a9a7062df6a94c98818a9644fc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8692ecb588260c4eb166d85f17126b8f"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a8692ecb588260c4eb166d85f17126b8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8692ecb588260c4eb166d85f17126b8f">ZUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; <a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a8692ecb588260c4eb166d85f17126b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbb5d7b0e70749ea0b454f54223165f"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a1bbb5d7b0e70749ea0b454f54223165f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1bbb5d7b0e70749ea0b454f54223165f">FLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; <a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a1bbb5d7b0e70749ea0b454f54223165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a3dcefa8560305534a5252f3c8249e"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a57a3dcefa8560305534a5252f3c8249e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a57a3dcefa8560305534a5252f3c8249e">FUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; <a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a57a3dcefa8560305534a5252f3c8249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ac4583fa662ad654f3da34e59ed5b"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:af48ac4583fa662ad654f3da34e59ed5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af48ac4583fa662ad654f3da34e59ed5b">ZFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; <a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:af48ac4583fa662ad654f3da34e59ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117b38529d1129cdae31e00d3c802cd"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a7117b38529d1129cdae31e00d3c802cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7117b38529d1129cdae31e00d3c802cd">FFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; <a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a7117b38529d1129cdae31e00d3c802cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> { <a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60eda9fb730caf1b2d638a1dcf747f0d4207d">ASK</a>
, <a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60edaca29caf9aab7f5eb7b91a531650cb517">TELL</a>
 }</td></tr>
<tr class="separator:ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be41540c5051a480d0611a3e216b659"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> { <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82">NEG</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e">ABS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02">ADD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c">SUB</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982">MUL</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc">POW</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd">MIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0">MAX</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539">SQRT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e">EXP</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c">LN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91">NROOT</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6">LOG</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8">SIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976">COS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951">TAN</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869">ASIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d">ACOS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29">ATAN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049">SINH</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d">COSH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a">TANH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb">ASINH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd">ACOSH</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e">ATANH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0">DIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845">MOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af">TDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858">TMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503">FDIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f">FMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188">CDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187">CMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f">EDIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8">EMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1">UNION</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac">INTERSECTION</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2">DIFFERENCE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149">SYMMETRIC_DIFFERENCE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480">COMPLEMENT</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed">SUBSET</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134">SUBSETEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50">SUPSET</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc">SUPSETEQ</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4">IN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2">CARD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a">HULL</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed">CONVEX</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134">EQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6">NEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066">LEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad">GEQ</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69">LT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651">GT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e">AND</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9">OR</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd">IMPLY</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b">EQUIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e">NOT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041">XOR</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5">ITE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856">MAXIMIZE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6">MINIMIZE</a>
<br />
 }</td></tr>
<tr class="separator:a4be41540c5051a480d0611a3e216b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27d5b0b23c11433345924cf591019cf8"><td class="memTemplParams" colspan="2">template&lt;size_t i, class... As&gt; </td></tr>
<tr class="memitem:a27d5b0b23c11433345924cf591019cf8"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a27d5b0b23c11433345924cf591019cf8">project</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;cp)</td></tr>
<tr class="memdesc:a27d5b0b23c11433345924cf591019cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax.  <a href="namespacelala.html#a27d5b0b23c11433345924cf591019cf8">More...</a><br /></td></tr>
<tr class="separator:a27d5b0b23c11433345924cf591019cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ecb899ec5a8ffa195e6503fadc0969"><td class="memTemplParams" colspan="2">template&lt;size_t i, class... As&gt; </td></tr>
<tr class="memitem:a04ecb899ec5a8ffa195e6503fadc0969"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a04ecb899ec5a8ffa195e6503fadc0969">project</a> (<a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;cp)</td></tr>
<tr class="separator:a04ecb899ec5a8ffa195e6503fadc0969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa18ce0a4e561956520c626c92ff1c0"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a5aa18ce0a4e561956520c626c92ff1c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a5aa18ce0a4e561956520c626c92ff1c0">fjoin</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a5aa18ce0a4e561956520c626c92ff1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d36bec1582324133665d3bc1f44a8b"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:af2d36bec1582324133665d3bc1f44a8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af2d36bec1582324133665d3bc1f44a8b">fmeet</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:af2d36bec1582324133665d3bc1f44a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8916c6ad403391101e59fa3292d0898"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:ae8916c6ad403391101e59fa3292d0898"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae8916c6ad403391101e59fa3292d0898">operator&lt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:ae8916c6ad403391101e59fa3292d0898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#afd6379ad7a7bb2e8e51d1c137c9260d9">operator&gt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2f9ed7b6bbb550e292c2131e7fded337">operator==</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memTemplParams" colspan="2">template&lt;class A , class... As&gt; </td></tr>
<tr class="memitem:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa495590c545ec6cdb20f4ae45b1649d5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;cp)</td></tr>
<tr class="separator:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860555919eb11a23caf88c6326961127"><td class="memTemplParams" colspan="2">template&lt;class L , IKind kind, bool diagnose = false, class F &gt; </td></tr>
<tr class="memitem:a860555919eb11a23caf88c6326961127"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a860555919eb11a23caf88c6326961127">ginterpret_true</a> (const F &amp;f, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a860555919eb11a23caf88c6326961127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memTemplParams" colspan="2">template&lt;IKind kind, bool diagnose = false, class A , class F , class Env , class I &gt; </td></tr>
<tr class="memitem:ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ad43c2ef9e5728a6e1c89b7ce5ffefdce">ginterpret_in</a> (const A &amp;a, const F &amp;f, Env &amp;env, I &amp;intermediate, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c4c21442cb5e55dec7f733b5409254"><td class="memTemplParams" colspan="2">template&lt;IKind kind, bool diagnose = false, class F , class Env , class U &gt; </td></tr>
<tr class="memitem:a65c4c21442cb5e55dec7f733b5409254"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a65c4c21442cb5e55dec7f733b5409254">ginterpret_in</a> (const F &amp;f, const Env &amp;env, U &amp;value, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a65c4c21442cb5e55dec7f733b5409254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memTemplParams" colspan="2">template&lt;IKind kind, bool diagnose = false, class A , class F , class Env , class I &gt; </td></tr>
<tr class="memitem:a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a5410dc3f527e6cd2a110c6966b3de8b4">top_level_ginterpret_in</a> (const A &amp;a, const F &amp;f, Env &amp;env, I &amp;intermediate, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memTemplParams" colspan="2">template&lt;class A , class Alloc  = battery::standard_allocator, class Env &gt; </td></tr>
<tr class="memitem:a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memTemplItemLeft" align="right" valign="top">CUDA A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a431f4e6f8e78e5e31c42de55d4d3f65e">make_top</a> (Env &amp;env, Alloc alloc=Alloc{})</td></tr>
<tr class="separator:a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b931b522b200e25aaf0b5574700db9"><td class="memTemplParams" colspan="2">template&lt;bool diagnose = false, class TellAlloc  = battery::standard_allocator, class F , class Env , class L &gt; </td></tr>
<tr class="memitem:ab2b931b522b200e25aaf0b5574700db9"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ab2b931b522b200e25aaf0b5574700db9">interpret_and_tell</a> (const F &amp;f, Env &amp;env, L &amp;value, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics, TellAlloc tell_alloc=TellAlloc{})</td></tr>
<tr class="separator:ab2b931b522b200e25aaf0b5574700db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06782af2fcf7a5cbcd8a4c3a907bc54"><td class="memTemplParams" colspan="2">template&lt;class A , bool diagnose = false, class F , class Env , class TellAlloc  = typename A::allocator_type&gt; </td></tr>
<tr class="memitem:ab06782af2fcf7a5cbcd8a4c3a907bc54"><td class="memTemplItemLeft" align="right" valign="top">CUDA std::optional&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ab06782af2fcf7a5cbcd8a4c3a907bc54">create_and_interpret_and_tell</a> (const F &amp;f, Env &amp;env, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics, typename A::allocator_type alloc=typename A::allocator_type{}, TellAlloc tell_alloc=TellAlloc{})</td></tr>
<tr class="separator:ab06782af2fcf7a5cbcd8a4c3a907bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8567b4b7b672cd68c5ee007e162edd"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a5f8567b4b7b672cd68c5ee007e162edd"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; typename L::local_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a5f8567b4b7b672cd68c5ee007e162edd">fjoin</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a5f8567b4b7b672cd68c5ee007e162edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d74ae6169bdb123d1b2c3332e2c7802"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a6d74ae6169bdb123d1b2c3332e2c7802"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; typename L::local_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6d74ae6169bdb123d1b2c3332e2c7802">fmeet</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a6d74ae6169bdb123d1b2c3332e2c7802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae508a71503241549919b188c5d372194"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ae508a71503241549919b188c5d372194"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae508a71503241549919b188c5d372194">operator&lt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:ae508a71503241549919b188c5d372194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67cd603d201f2f6df30d4fe521fd427"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ac67cd603d201f2f6df30d4fe521fd427"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac67cd603d201f2f6df30d4fe521fd427">operator&gt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:ac67cd603d201f2f6df30d4fe521fd427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f62a10e87e036d30d453ad4b3f59e"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a972f62a10e87e036d30d453ad4b3f59e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a972f62a10e87e036d30d453ad4b3f59e">operator==</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a972f62a10e87e036d30d453ad4b3f59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memTemplParams" colspan="2">template&lt;class L &gt; </td></tr>
<tr class="memitem:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7ff81ccef2fad201c1b2061fbaf3ad9f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;itv)</td></tr>
<tr class="separator:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a095313c4ac1c353450411ecd930b24c9">is_v_op_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a095313c4ac1c353450411ecd930b24c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8264bf97bc739bc4ef3de14b159d4d6c">is_v_op_z</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a704b489e2f66fc4666a9d9d5dd07f0a5">is_var_equality</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f)</td></tr>
<tr class="separator:a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a92bcc6c6ade58edab3b25b01c07ceaf3">make_v_op_z</a> (<a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a>&lt; Allocator &gt; v, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> z, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#affdfb7f9d029a06bfb08f0fb9d561abc">make_v_op_z</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> v, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> z, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44fa0949aa0050534b4e5888182cf27"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:ac44fa0949aa0050534b4e5888182cf27"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac44fa0949aa0050534b4e5888182cf27">geq_of_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;f)</td></tr>
<tr class="separator:ac44fa0949aa0050534b4e5888182cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99742669495aa20254d238796f3225f9"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a99742669495aa20254d238796f3225f9"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a99742669495aa20254d238796f3225f9">leq_of_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;f)</td></tr>
<tr class="separator:a99742669495aa20254d238796f3225f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049d2d782b268501633b424c0c61b68"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:a1049d2d782b268501633b424c0c61b68"><td class="memTemplItemLeft" align="right" valign="top">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1049d2d782b268501633b424c0c61b68">var_in</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f)</td></tr>
<tr class="separator:a1049d2d782b268501633b424c0c61b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac68fae34e298f9dc08e81209a98dea89">num_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:ac68fae34e298f9dc08e81209a98dea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dda4c39e820cfd39e75737378d033e"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a66dda4c39e820cfd39e75737378d033e"><td class="memTemplItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a66dda4c39e820cfd39e75737378d033e">num_quantified_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:a66dda4c39e820cfd39e75737378d033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdf54773f9858c9ef2b06b250f3a0c3"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6fdf54773f9858c9ef2b06b250f3a0c3"><td class="memTemplItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6fdf54773f9858c9ef2b06b250f3a0c3">num_quantified_vars</a> (const F &amp;f, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty)</td></tr>
<tr class="separator:a6fdf54773f9858c9ef2b06b250f3a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3749d6ff27c5005bbbe560ede8ee98a0"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a3749d6ff27c5005bbbe560ede8ee98a0"><td class="memTemplItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a3749d6ff27c5005bbbe560ede8ee98a0">num_constraints</a> (const F &amp;f)</td></tr>
<tr class="separator:a3749d6ff27c5005bbbe560ede8ee98a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a93ff80f41d2a60ce49d9d969792f3818">type_of_conjunction</a> (const typename F::Sequence &amp;seq)</td></tr>
<tr class="separator:a93ff80f41d2a60ce49d9d969792f3818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI battery::tuple&lt; F, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2af6441863bd25ce8c40bc31a4e988d6">extract_ty</a> (const F &amp;f, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> ty)</td></tr>
<tr class="separator:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c82f922a369376733ac1ceb63f2ecc"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a61c82f922a369376733ac1ceb63f2ecc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a61c82f922a369376733ac1ceb63f2ecc">negate</a> (const F &amp;f)</td></tr>
<tr class="separator:a61c82f922a369376733ac1ceb63f2ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7903710a42f3bdc161f79c13b2d3b33e"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a7903710a42f3bdc161f79c13b2d3b33e"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7903710a42f3bdc161f79c13b2d3b33e">de_morgan_law</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig_neg, const F &amp;f)</td></tr>
<tr class="separator:a7903710a42f3bdc161f79c13b2d3b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36d1200033fd624fe0baa3632553b49"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:af36d1200033fd624fe0baa3632553b49"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af36d1200033fd624fe0baa3632553b49">negate_eq</a> (const F &amp;f)</td></tr>
<tr class="separator:af36d1200033fd624fe0baa3632553b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b1cbdaf671ada055fcddffa64786e"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#ad13b1cbdaf671ada055fcddffa64786e">negate_arithmetic_comparison</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:ad13b1cbdaf671ada055fcddffa64786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b8c9e53b51af981665045ab0ef5789"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a46b8c9e53b51af981665045ab0ef5789"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a46b8c9e53b51af981665045ab0ef5789">is_arithmetic_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:a46b8c9e53b51af981665045ab0ef5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af5ec9df0db7364e9a1d4a6cf55133bc0">is_set_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa96505876a4dc4a73e9dcac1df80ba16">is_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37723381538b58c397b57008bcc7671b"><td class="memItemLeft" align="right" valign="top">CUDA NI <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a37723381538b58c397b57008bcc7671b">converse_comparison</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a37723381538b58c397b57008bcc7671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3a823ec9c5e512892e628d8311c543"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a1c3a823ec9c5e512892e628d8311c543"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1c3a823ec9c5e512892e628d8311c543">map_avar_to_lvar</a> (F &amp;f, const Env &amp;env, bool erase_type=false)</td></tr>
<tr class="separator:a1c3a823ec9c5e512892e628d8311c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae6506d073b2c1165fa92bffeae6fd4bf">eval</a> (const F &amp;f)</td></tr>
<tr class="separator:ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505158a64e90b36755f6e84b5db6b987"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a505158a64e90b36755f6e84b5db6b987"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a505158a64e90b36755f6e84b5db6b987">normalize</a> (const F &amp;f)</td></tr>
<tr class="separator:a505158a64e90b36755f6e84b5db6b987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aed9c4d9ba677f7255545ffa2f7df3"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:af1aed9c4d9ba677f7255545ffa2f7df3"><td class="memTemplItemLeft" align="right" valign="top">CUDA F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af1aed9c4d9ba677f7255545ffa2f7df3">decompose_in_constraint</a> (const F &amp;f, const typename F::allocator_type &amp;alloc=typename F::allocator_type())</td></tr>
<tr class="separator:af1aed9c4d9ba677f7255545ffa2f7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77aa301355868d2d9458857ea2946a8"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab77aa301355868d2d9458857ea2946a8"><td class="memTemplItemLeft" align="right" valign="top">CUDA F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ab77aa301355868d2d9458857ea2946a8">decompose_arith_neq_constraint</a> (const F &amp;f, const typename F::allocator_type &amp;alloc=typename F::allocator_type())</td></tr>
<tr class="separator:ab77aa301355868d2d9458857ea2946a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e4cd05f6c827108d47c98443be639e"><td class="memItemLeft" align="right" valign="top">CUDA NI const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a23e4cd05f6c827108d47c98443be639e">string_of_sig</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a23e4cd05f6c827108d47c98443be639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b298de3e0cbb50bbc02bc606b7c56a"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#af2b298de3e0cbb50bbc02bc606b7c56a">is_prefix</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:af2b298de3e0cbb50bbc02bc606b7c56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf05545f06bb4e74db05c3c520cb31e8"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#abf05545f06bb4e74db05c3c520cb31e8">is_division</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:abf05545f06bb4e74db05c3c520cb31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff9ae908dd0eed685d87631506b3eb"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a97ff9ae908dd0eed685d87631506b3eb">is_modulo</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a97ff9ae908dd0eed685d87631506b3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b055c3c2499841f43012304df8c0686"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6b055c3c2499841f43012304df8c0686">is_associative</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a6b055c3c2499841f43012304df8c0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36870240eda9c7f0b1d4a3c063e10cd"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa36870240eda9c7f0b1d4a3c063e10cd">is_arithmetic_comparison</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:aa36870240eda9c7f0b1d4a3c063e10cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b74d0fad8edd85cd73c0b82b0df6345"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a5b74d0fad8edd85cd73c0b82b0df6345">is_logical</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a5b74d0fad8edd85cd73c0b82b0df6345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a0c6edcd92ebf5d23f69e8b9211fb9"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a18a0c6edcd92ebf5d23f69e8b9211fb9">is_predicate</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a18a0c6edcd92ebf5d23f69e8b9211fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa035eb336900b61d13e7f0dbc517d334">operator==</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;lhs, const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;rhs)</td></tr>
<tr class="separator:aa035eb336900b61d13e7f0dbc517d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1362bc0d6ef66f109c173073a12d63c2"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a1362bc0d6ef66f109c173073a12d63c2"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; std::reference_wrapper&lt; const typename Env::variable_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1362bc0d6ef66f109c173073a12d63c2">var_in</a> (const F &amp;f, const Env &amp;env)</td></tr>
<tr class="separator:a1362bc0d6ef66f109c173073a12d63c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplParams" colspan="2">template&lt;class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a06f3e5ada938781bdb8c667a159242fe">operator==</a> (const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;lhs, const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a06f3e5ada938781bdb8c667a159242fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f36a358eb1db17dc852e6bb2bf314"><td class="memTemplParams" colspan="2">template&lt;class F , class Env  = VarEnv&lt;battery::standard_allocator&gt;&gt; </td></tr>
<tr class="memitem:ad33f36a358eb1db17dc852e6bb2bf314"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ad33f36a358eb1db17dc852e6bb2bf314">ternarize</a> (const F &amp;f, const Env &amp;env=Env(), bool ternarize_all=false)</td></tr>
<tr class="separator:ad33f36a358eb1db17dc852e6bb2bf314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memTemplParams" colspan="2">template&lt;class A , class R  = A&gt; </td></tr>
<tr class="memitem:a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a4a8490aa25a4cc0da52f96a42f15ad70">project_fun</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> fun, const A &amp;a, const A &amp;b)</td></tr>
<tr class="separator:a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf205cdf4c3b33d9ea65f971b991d889"><td class="memTemplParams" colspan="2">template&lt;class A , class R  = A&gt; </td></tr>
<tr class="memitem:aaf205cdf4c3b33d9ea65f971b991d889"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aaf205cdf4c3b33d9ea65f971b991d889">project_fun</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> fun, const A &amp;a)</td></tr>
<tr class="separator:aaf205cdf4c3b33d9ea65f971b991d889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f1397076bb29c788d18a0fb7026cf"><td class="memTemplParams" colspan="2">template&lt;class LDual , class L &gt; </td></tr>
<tr class="memitem:a420f1397076bb29c788d18a0fb7026cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA LDual&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a420f1397076bb29c788d18a0fb7026cf">dual_bound</a> (const L &amp;x)</td></tr>
<tr class="separator:a420f1397076bb29c788d18a0fb7026cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef2677570c6f6ec0d7a1e2cdb2ab9ce"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:acef2677570c6f6ec0d7a1e2cdb2ab9ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#acef2677570c6f6ec0d7a1e2cdb2ab9ce">fjoin</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:acef2677570c6f6ec0d7a1e2cdb2ab9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e07ba657ba73aaedcc78067610995b"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a06e07ba657ba73aaedcc78067610995b"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a06e07ba657ba73aaedcc78067610995b">fmeet</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a06e07ba657ba73aaedcc78067610995b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde3a19b9b8c0771697b998e73b6b3b4"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:abde3a19b9b8c0771697b998e73b6b3b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#abde3a19b9b8c0771697b998e73b6b3b4">operator&lt;</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:abde3a19b9b8c0771697b998e73b6b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cf5cb9621c122f5d07f984c6068400"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:af5cf5cb9621c122f5d07f984c6068400"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af5cf5cb9621c122f5d07f984c6068400">operator&gt;</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:af5cf5cb9621c122f5d07f984c6068400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f237b352671c72809dad61c4497fced"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a8f237b352671c72809dad61c4497fced"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8f237b352671c72809dad61c4497fced">operator==</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a8f237b352671c72809dad61c4497fced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab763178be18bb44d0b87b0238b5ed640"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:ab763178be18bb44d0b87b0238b5ed640"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ab763178be18bb44d0b87b0238b5ed640">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M &gt; &amp;a)</td></tr>
<tr class="separator:ab763178be18bb44d0b87b0238b5ed640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb47c1e9ba853b1aa9957c719b2bfa4"><td class="memTemplParams" colspan="2">template&lt;class Pre &gt; </td></tr>
<tr class="memitem:aefb47c1e9ba853b1aa9957c719b2bfa4"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aefb47c1e9ba853b1aa9957c719b2bfa4">fjoin</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;b)</td></tr>
<tr class="separator:aefb47c1e9ba853b1aa9957c719b2bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc376306287a55597f33c913258b968"><td class="memTemplParams" colspan="2">template&lt;class Pre &gt; </td></tr>
<tr class="memitem:a6bc376306287a55597f33c913258b968"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6bc376306287a55597f33c913258b968">fmeet</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;b)</td></tr>
<tr class="separator:a6bc376306287a55597f33c913258b968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1760bbb14c23377e4be9f1ddedffb5f6">operator&lt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1047b3d6574fcae4465468ba6e419ba3"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a1047b3d6574fcae4465468ba6e419ba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1047b3d6574fcae4465468ba6e419ba3">operator&gt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a1047b3d6574fcae4465468ba6e419ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c07b747cf648832084c3fa1f89aa7"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a751c07b747cf648832084c3fa1f89aa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a751c07b747cf648832084c3fa1f89aa7">operator==</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a751c07b747cf648832084c3fa1f89aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547ed695047c53bc105eea3fe6ec28e5"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:a547ed695047c53bc105eea3fe6ec28e5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a547ed695047c53bc105eea3fe6ec28e5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;a)</td></tr>
<tr class="separator:a547ed695047c53bc105eea3fe6ec28e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073e87bc30d52a9329b59939cce2392"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:ac073e87bc30d52a9329b59939cce2392"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac073e87bc30d52a9329b59939cce2392">fjoin</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:ac073e87bc30d52a9329b59939cce2392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bd6c20fd135c37a166cf466824aa02"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a85bd6c20fd135c37a166cf466824aa02"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a85bd6c20fd135c37a166cf466824aa02">fmeet</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a85bd6c20fd135c37a166cf466824aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4afb1e07ef7fded7169167039a9f3e"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:aca4afb1e07ef7fded7169167039a9f3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aca4afb1e07ef7fded7169167039a9f3e">operator&lt;</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:aca4afb1e07ef7fded7169167039a9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9288ef392ccc3f0ebb6c3cf7dc2dec"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a1a9288ef392ccc3f0ebb6c3cf7dc2dec"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1a9288ef392ccc3f0ebb6c3cf7dc2dec">operator&gt;</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a1a9288ef392ccc3f0ebb6c3cf7dc2dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bec15dd642120a7e93033c3ebaeeaf"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a04bec15dd642120a7e93033c3ebaeeaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a04bec15dd642120a7e93033c3ebaeeaf">operator==</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a04bec15dd642120a7e93033c3ebaeeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7828840d9064772b024638e0e9aba5ce"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M , class T &gt; </td></tr>
<tr class="memitem:a7828840d9064772b024638e0e9aba5ce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7828840d9064772b024638e0e9aba5ce">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M, T &gt; &amp;a)</td></tr>
<tr class="separator:a7828840d9064772b024638e0e9aba5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215c5410b2314e5aa2b4566c459f0aa"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a0215c5410b2314e5aa2b4566c459f0aa"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a0215c5410b2314e5aa2b4566c459f0aa">fmeet</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a0215c5410b2314e5aa2b4566c459f0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8c34bdae41587c8c7dd9264fde5d2f4a">fjoin</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a09d08be75dca11487b354fa4bdea0c87">operator&lt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a09d08be75dca11487b354fa4bdea0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a511f6fbe14852b39dd74918800f04441">operator&gt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a511f6fbe14852b39dd74918800f04441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af527b0d9cb84ef22cddd191486265146">operator==</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:af527b0d9cb84ef22cddd191486265146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memTemplParams" colspan="2">template&lt;class L , class Alloc &gt; </td></tr>
<tr class="memitem:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a9009ac0a37e31306fe8bd5fd738eb469">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;vstore)</td></tr>
<tr class="separator:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides an extended interface to interpret formulas in abstract domains and abstract universes. It also provides a unified interface for tell and ask interpretation using a template parameter <code>IKind</code>.</p>
<p>A pre-abstract universe is a lattice (with usual operations join, order, ...) equipped with a simple logical interpretation function and a next/prev functions. We consider totally ordered pre-abstract universes with a downset semantics. For any lattice \( L \), we consider an element \( a \in L \) to represent all the concrete elements equal to or below it. This set is called the downset of \( a \) and is denoted \( \mathord{\downarrow}{a} \). The concretization function \( \gamma \) formalizes this idea: \( \gamma(a) = \{x \mapsto b \;|\; b \in \mathord{\downarrow}{a} \cap U \} \) where \( U \) is the universe of discourse. The intersection with \( U \) is necessary to remove potential elements in the abstract universe that are not in the concrete universe of discourse (e.g., \( -\infty, \infty \) below).</p>
<p>The downset semantics associates each element of a lattice to its concrete downset. It is possible to decide that each element is associated to the concrete upset instead. Doing so will reverse our usage of the lattice-theoretic operations (join instead of meet, &lt;= instead of &gt;=, etc.). Instead of considering the upset semantics, it is more convenient to consider the downset semantics of the dual lattice.</p>
<p>Example: The lattice of increasing integer \( \mathit{ZUB} = \langle \{-\infty, \ldots, -2, -1, 0, 1, 2, \ldots, \infty\}, \leq \rangle \) is ordered by the natural arithmetic comparison operator, it represents an upper bound on the set of integers represented. Using the downset semantics, we can represent simple constraints such as \( x \leq 3 \), in which case the downset \( \mathord{\downarrow}{3} = \{\ldots, 1, 2, 3\} \) represents all the values of \( x \) satisfying the constraints \( x \leq 3 \), that is, the solutions of the constraints. By taking the upset semantics of \( \mathit{ZUB} \), we can represent constraints such as \( x \geq 3 \). Alternatively, we can take the dual lattice of decreasing integers \( \mathit{ZLB} = \langle \{\infty, \ldots, 2, 1, 0, -1, -2, \ldots, -\infty\}, \geq \rangle \). The downset semantics of \( \mathit{ZLB} \) corresponds to the upset semantics of \( \mathit{ZUB} \).</p>
<p>From a pre-abstract universe, we obtain an abstract universe using the <code>Universe</code> class below. We also define various aliases to abstract universes such as <code>ZLB</code>, <code>ZUB</code>, etc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a609554da1e3f1cb56804fcca736e7d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609554da1e3f1cb56804fcca736e7d70">&#9670;&nbsp;</a></span>abstract_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a609554da1e3f1cb56804fcca736e7d70">lala::abstract_ptr</a> = typedef battery::shared_ptr&lt;A, typename A::allocator_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb9f389c51804929bfb3e6d682d77ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9f389c51804929bfb3e6d682d77ff0">&#9670;&nbsp;</a></span>LVar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">lala::LVar</a> = typedef battery::string&lt;Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "logical variable" is just the name of the variable. </p>

</div>
</div>
<a id="a6c626918dd7c19ff046f5cebaabec18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c626918dd7c19ff046f5cebaabec18f">&#9670;&nbsp;</a></span>AType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">lala::AType</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each abstract domain is uniquely identified by an UID. We call it an <em>abstract type</em>. Each formula (and recursively, its subformulas) is assigned to an abstract type indicating in what abstract domain this formula should be interpreted. </p>

</div>
</div>
<a id="a2397fa063de70fb2241dc9ea08c47800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2397fa063de70fb2241dc9ea08c47800">&#9670;&nbsp;</a></span>logic_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a2397fa063de70fb2241dc9ea08c47800">lala::logic_bool</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of Boolean used in logic formulas. </p>

</div>
</div>
<a id="a303d30ab753875ab1fc49e3b4f195719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d30ab753875ab1fc49e3b4f195719">&#9670;&nbsp;</a></span>logic_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">lala::logic_int</a> = typedef long long int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of integers used in logic formulas. Integers are represented by the set \( \{-\infty, \infty\} \cup Z (\text{ with} Z \subset \mathbb{Z}) \). The minimal and maximal values of <code>logic_int</code> represents \( -\infty \) and \( \infty \) respectively. </p>

</div>
</div>
<a id="a08adbd4b2483ca2b14db01ba8769ef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08adbd4b2483ca2b14db01ba8769ef93">&#9670;&nbsp;</a></span>logic_real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a08adbd4b2483ca2b14db01ba8769ef93">lala::logic_real</a> = typedef battery::tuple&lt;double, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of real numbers used in logic formulas. Real numbers are approximated by the set \( \mathbb{F} \times \mathbb{F} \). When a real number \( r \in \mathbb{R} \) is also a floating-point number, then it is represented by \( (r, r) \), otherwise it is represented by \( (\lfloor r \rfloor, \lceil r \rceil) \) such that \( \lfloor r \rfloor &lt; r &lt; \lceil r \rceil \) and there is no floating-point number \( f \) such that \( \lfloor r \rfloor &lt; f &lt; \lceil r \rceil \). </p>

</div>
</div>
<a id="a5d3475914a4dbd0a377ee399dd9adaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3475914a4dbd0a377ee399dd9adaa8">&#9670;&nbsp;</a></span>logic_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a5d3475914a4dbd0a377ee399dd9adaa8">lala::logic_set</a> = typedef battery::vector&lt;battery::tuple&lt;F, F&gt;, typename F::allocator_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set is parametric in a universe of discourse. For instance, <code>logic_set&lt;F&gt;</code>, with F representing an integer constant, is a set of integers. Sets are defined in extension: we explicitly list the values belonging to the set. To avoid using too much memory with large sets, we use an interval representation, e.g., \( \{1..3, 5..5, 10..12\} = \{1, 2, 3, 5, 10, 11, 12\} \). When sets occur in intervals, they are ordered by set inclusion, e.g., \( \{\{1..2\}..\{1..4\}\} = \{\{1,2\}, \{1,2,3\}, \{1,2,4\}, \{1,2,3,4\}\} \). </p>

</div>
</div>
<a id="a14b6a9a7062df6a94c98818a9644fc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b6a9a7062df6a94c98818a9644fc74">&#9670;&nbsp;</a></span>ZLB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a14b6a9a7062df6a94c98818a9644fc74">lala::ZLB</a> = typedef <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of integer lower bounds. </p>

</div>
</div>
<a id="a8692ecb588260c4eb166d85f17126b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8692ecb588260c4eb166d85f17126b8f">&#9670;&nbsp;</a></span>ZUB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a8692ecb588260c4eb166d85f17126b8f">lala::ZUB</a> = typedef <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of integer upper bounds. </p>

</div>
</div>
<a id="a1bbb5d7b0e70749ea0b454f54223165f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbb5d7b0e70749ea0b454f54223165f">&#9670;&nbsp;</a></span>FLB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a1bbb5d7b0e70749ea0b454f54223165f">lala::FLB</a> = typedef <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of floating-point lower bounds. </p>

</div>
</div>
<a id="a57a3dcefa8560305534a5252f3c8249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a3dcefa8560305534a5252f3c8249e">&#9670;&nbsp;</a></span>FUB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a57a3dcefa8560305534a5252f3c8249e">lala::FUB</a> = typedef <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of floating-point upper bounds. </p>

</div>
</div>
<a id="af48ac4583fa662ad654f3da34e59ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48ac4583fa662ad654f3da34e59ed5b">&#9670;&nbsp;</a></span>ZFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#af48ac4583fa662ad654f3da34e59ed5b">lala::ZFlat</a> = typedef <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat integers. </p>

</div>
</div>
<a id="a7117b38529d1129cdae31e00d3c802cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117b38529d1129cdae31e00d3c802cd">&#9670;&nbsp;</a></span>FFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a7117b38529d1129cdae31e00d3c802cd">lala::FFlat</a> = typedef <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat floating-point numbers. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">&#9670;&nbsp;</a></span>IKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">lala::IKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The kind of interpretation operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60eda9fb730caf1b2d638a1dcf747f0d4207d"></a>ASK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60edaca29caf9aab7f5eb7b91a531650cb517"></a>TELL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4be41540c5051a480d0611a3e216b659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be41540c5051a480d0611a3e216b659">&#9670;&nbsp;</a></span>Sig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">lala::Sig</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A first-order signature is a triple \( (X, F, P) \) where \( X \) is the set of variables, \( F \) the set of function symbols and \( P \) the set of predicates. We represent \( X \) by strings (see <code>LVar</code>), while \( F \) and \( P \) are described in the following enumeration <code>Sig</code>. For programming conveniency, we suppose that logical connectors are included in the set of predicates and thus are in the signature as well. Finally, function symbols and predicates are at the "same level". Hence a predicate can occur as the argument of a function, which is convenient when modelling, consider for example a cardinality constraint: \( ((x &gt; 4) + (y &lt; 4) + (z = 3)) \neq 2 \).</p>
<p>Symbols are sometimes overloaded across different universe of discourse. For instance, <code>ADD</code> can be used over integers, reals and even set of integers (pairwise addition).</p>
<p>Division and modulus are defined as usual over continuous domains such as rational and real numbers. However, it gets more tricky when defined over discrete domains such as integers and floating-point numbers, since there is not a single definition of division and modulus. The various kinds of discrete divisions are explained in (Leijend D. (2003). Division and Modulus for Computer Scientists), and we add four of those definitions to the logical signature. There are several use-cases of modulus and division: If you write a constraint model, you probably want to use euclidean division and modulus (EDIV, EMOD) as this is the most "mathematical" definition. If you intend to model the semantics of a programming language, you should use the same kind of division as the one present in your programming language (most likely truncated division). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82"></a>NEG&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e"></a>ABS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02"></a>ADD&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c"></a>SUB&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982"></a>MUL&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc"></a>POW&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd"></a>MIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0"></a>MAX&#160;</td><td class="fielddoc"><p>Binary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539"></a>SQRT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e"></a>EXP&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c"></a>LN&#160;</td><td class="fielddoc"><p>Square root, natural exponential and natural logarithm function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91"></a>NROOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6"></a>LOG&#160;</td><td class="fielddoc"><p>nth root and logarithm to base (both binary function symbols). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8"></a>SIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976"></a>COS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951"></a>TAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869"></a>ASIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d"></a>ACOS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29"></a>ATAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049"></a>SINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d"></a>COSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a"></a>TANH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb"></a>ASINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd"></a>ACOSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e"></a>ATANH&#160;</td><td class="fielddoc"><p>Trigonometric unary function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0"></a>DIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845"></a>MOD&#160;</td><td class="fielddoc"><p>Division and modulus over continuous domains (e.g., floating-point numbers and rational). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af"></a>TDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858"></a>TMOD&#160;</td><td class="fielddoc"><p>Truncated division, present in most programming languages, is defined as \( a\,\mathbf{tdiv}\,b = \mathit{trunc}(a/b) \), i.e., it rounds towards zero. Modulus is defined as \( a\,\mathbf{tmod}\,b = a - b * (a\,\mathbf{tdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503"></a>FDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f"></a>FMOD&#160;</td><td class="fielddoc"><p>Floor division (Knuth D. (1972). The Art of Computer Programming, Vol 1, Fundamental Algorithms), is defined as \( a\,\mathbf{fdiv}\,b = \lfloor a/b \rfloor \), i.e., it rounds towards negative infinity. Modulus is defined as \( a\,\mathbf{fmod}\,b = a - b * (a\,\mathbf{fdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188"></a>CDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187"></a>CMOD&#160;</td><td class="fielddoc"><p>Ceil division is defined as \( a\,\mathbf{cdiv}\,b = \lceil a/b \rceil \). Modulus is defined as \( a\,\mathbf{cmod}\,b = a - b * (a\,\mathbf{cdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f"></a>EDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8"></a>EMOD&#160;</td><td class="fielddoc"><p>Euclidean division (Boute T. R. (1992). The Euclidean definition of the functions div and mod). The properties satisfy by this division are: (1) \( a\,\mathbf{ediv}\,b \in \mathbb{Z} \), (2) \( a = b * (a\,\mathbf{ediv}\,b) + (a\,\mathbf{emod}\,b) \) and (3) \( 0 \leq a\,\mathbf{emod}\,b &lt; |b|\). Further, note that Euclidean division satisfies \( a\,\mathbf{ediv}\,(-b) = -(a\,\mathbf{ediv}\,b) \) and \( a\,\mathbf{emod}\,(-b) = a\,\mathbf{emod}\,b \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1"></a>UNION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac"></a>INTERSECTION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2"></a>DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149"></a>SYMMETRIC_DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480"></a>COMPLEMENT&#160;</td><td class="fielddoc"><p>Set functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed"></a>SUBSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134"></a>SUBSETEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50"></a>SUPSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc"></a>SUPSETEQ&#160;</td><td class="fielddoc"><p>Set inclusion predicates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4"></a>IN&#160;</td><td class="fielddoc"><p>Set membership predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2"></a>CARD&#160;</td><td class="fielddoc"><p>Cardinality function from set to integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a"></a>HULL&#160;</td><td class="fielddoc"><p>Unary function performing the convex hull of a set, e.g., \( \mathit{hull}(s) = \{x \;|\; \mathit{min}(s) \leq x \leq \mathit{max}(s) \} \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed"></a>CONVEX&#160;</td><td class="fielddoc"><p>Unary predicate, requiring \( s = \mathit{hull}(s) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134"></a>EQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6"></a>NEQ&#160;</td><td class="fielddoc"><p>Equality relations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066"></a>LEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad"></a>GEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69"></a>LT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651"></a>GT&#160;</td><td class="fielddoc"><p>Arithmetic comparison predicates. When applied to set, it corresponds to the lexicographic ordering of the sorted set according the underlying natural ordering of the elements in the set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e"></a>AND&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9"></a>OR&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd"></a>IMPLY&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b"></a>EQUIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e"></a>NOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041"></a>XOR&#160;</td><td class="fielddoc"><p>Logical connector. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5"></a>ITE&#160;</td><td class="fielddoc"><p>If-then-else. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856"></a>MAXIMIZE&#160;</td><td class="fielddoc"><p>Unary "meta-predicate" indicating that its argument must be maximized, according to the increasing ordering of the underlying universe of discourse. This is not a predicate because it is defined on the solutions space of the whole formulas. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6"></a>MINIMIZE&#160;</td><td class="fielddoc"><p>Same as MAXIMIZE, but for minimization. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27d5b0b23c11433345924cf591019cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d5b0b23c11433345924cf591019cf8">&#9670;&nbsp;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t i, class... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt;As...&gt;::template type_of&lt;i&gt;&amp; lala::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax. </p>

</div>
</div>
<a id="a04ecb899ec5a8ffa195e6503fadc0969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ecb899ec5a8ffa195e6503fadc0969">&#9670;&nbsp;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t i, class... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt;As...&gt;::template type_of&lt;i&gt;&amp; lala::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aa18ce0a4e561956520c626c92ff1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa18ce0a4e561956520c626c92ff1c0">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcup (b_1, \ldots, b_n) = (a_1 \sqcup_1 b_1, \ldots, a_n \sqcup_n b_n) \) </p>

</div>
</div>
<a id="af2d36bec1582324133665d3bc1f44a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d36bec1582324133665d3bc1f44a8b">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcap (b_1, \ldots, b_n) = (a_1 \sqcap_1 b_1, \ldots, a_n \sqcap_n b_n) \) </p>

</div>
</div>
<a id="ae8916c6ad403391101e59fa3292d0898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8916c6ad403391101e59fa3292d0898">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd6379ad7a7bb2e8e51d1c137c9260d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6379ad7a7bb2e8e51d1c137c9260d9">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f9ed7b6bbb550e292c2131e7fded337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9ed7b6bbb550e292c2131e7fded337">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa495590c545ec6cdb20f4ae45b1649d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa495590c545ec6cdb20f4ae45b1649d5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class... As&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a860555919eb11a23caf88c6326961127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860555919eb11a23caf88c6326961127">&#9670;&nbsp;</a></span>ginterpret_true()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , IKind kind, bool diagnose = false, class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_true </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpret <code>true</code> in the lattice <code>L</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>L</code> preserves the top element w.r.t. the concrete domain or if <code>true</code> is interpreted by under-approximation (kind == ASK). </dd></dl>

</div>
</div>
<a id="ad43c2ef9e5728a6e1c89b7ce5ffefdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c2ef9e5728a6e1c89b7ce5ffefdce">&#9670;&nbsp;</a></span>ginterpret_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IKind kind, bool diagnose = false, class A , class F , class Env , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>intermediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides an extended and unified interface to ask and tell interpretation of formula in abstract domains. It provides default interpretation for common formulas such as <code>true</code>, <code>false</code> and conjunction of formulas whenever <code>A</code> satisfies some lattice-theoretic conditions. </p>

</div>
</div>
<a id="a65c4c21442cb5e55dec7f733b5409254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c4c21442cb5e55dec7f733b5409254">&#9670;&nbsp;</a></span>ginterpret_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IKind kind, bool diagnose = false, class F , class Env , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides an extended and unified interface to ask and tell interpretation of formula in abstract universes. It provides default interpretation for common formulas such as <code>true</code>, <code>false</code>, conjunction and disjunction of formulas whenever <code>U</code> satisfies some lattice-theoretic conditions. </p>

</div>
</div>
<a id="a5410dc3f527e6cd2a110c6966b3de8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5410dc3f527e6cd2a110c6966b3de8b4">&#9670;&nbsp;</a></span>top_level_ginterpret_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IKind kind, bool diagnose = false, class A , class F , class Env , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::top_level_ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>intermediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Top-level version of <code>ginterpret_in</code>, we restore <code>env</code> and <code>intermediate</code> in case of failure. </p>

</div>
</div>
<a id="a431f4e6f8e78e5e31c42de55d4d3f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431f4e6f8e78e5e31c42de55d4d3f65e">&#9670;&nbsp;</a></span>make_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Alloc  = battery::standard_allocator, class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA A lala::make_top </td>
          <td>(</td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2b931b522b200e25aaf0b5574700db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b931b522b200e25aaf0b5574700db9">&#9670;&nbsp;</a></span>interpret_and_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool diagnose = false, class TellAlloc  = battery::standard_allocator, class F , class Env , class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::interpret_and_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TellAlloc&#160;</td>
          <td class="paramname"><em>tell_alloc</em> = <code>TellAlloc{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab06782af2fcf7a5cbcd8a4c3a907bc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06782af2fcf7a5cbcd8a4c3a907bc54">&#9670;&nbsp;</a></span>create_and_interpret_and_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , bool diagnose = false, class F , class Env , class TellAlloc  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA std::optional&lt;A&gt; lala::create_and_interpret_and_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename A::allocator_type&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>typename&#160;A::allocator_type{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TellAlloc&#160;</td>
          <td class="paramname"><em>tell_alloc</em> = <code>TellAlloc{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f8567b4b7b672cd68c5ee007e162edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8567b4b7b672cd68c5ee007e162edd">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt;typename L::local_type&gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d74ae6169bdb123d1b2c3332e2c7802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d74ae6169bdb123d1b2c3332e2c7802">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt;typename L::local_type&gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae508a71503241549919b188c5d372194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae508a71503241549919b188c5d372194">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac67cd603d201f2f6df30d4fe521fd427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67cd603d201f2f6df30d4fe521fd427">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a972f62a10e87e036d30d453ad4b3f59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972f62a10e87e036d30d453ad4b3f59e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ff81ccef2fad201c1b2061fbaf3ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff81ccef2fad201c1b2061fbaf3ad9f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>itv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a095313c4ac1c353450411ecd930b24c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095313c4ac1c353450411ecd930b24c9">&#9670;&nbsp;</a></span>is_v_op_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable &lt;sig&gt; constant</code>. </dd></dl>

</div>
</div>
<a id="a8264bf97bc739bc4ef3de14b159d4d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8264bf97bc739bc4ef3de14b159d4d6c">&#9670;&nbsp;</a></span>is_v_op_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_z </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable op integer constant</code>, e.g., <code>x &lt; 4</code>. </dd></dl>

</div>
</div>
<a id="a704b489e2f66fc4666a9d9d5dd07f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704b489e2f66fc4666a9d9d5dd07f0a5">&#9670;&nbsp;</a></span>is_var_equality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_var_equality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable = variable</code> or <code>variable &lt;=&gt; variable</code>. </dd></dl>

</div>
</div>
<a id="a92bcc6c6ade58edab3b25b01c07ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bcc6c6ade58edab3b25b01c07ceaf3">&#9670;&nbsp;</a></span>make_v_op_z() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator&gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a>&lt; Allocator &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em> = <code><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affdfb7f9d029a06bfb08f0fb9d561abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdfb7f9d029a06bfb08f0fb9d561abc">&#9670;&nbsp;</a></span>make_v_op_z() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator&gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em> = <code><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44fa0949aa0050534b4e5888182cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44fa0949aa0050534b4e5888182cf27">&#9670;&nbsp;</a></span>geq_of_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::geq_of_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99742669495aa20254d238796f3225f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99742669495aa20254d238796f3225f9">&#9670;&nbsp;</a></span>leq_of_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::leq_of_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1049d2d782b268501633b424c0c61b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049d2d782b268501633b424c0c61b68">&#9670;&nbsp;</a></span>var_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator, ExtendedSig&gt;&amp; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first variable occurring in the formula, or any other subformula if the formula does not contain a variable. It returns either a logical variable, an abstract variable or a quantifier. </dd></dl>

</div>
</div>
<a id="ac68fae34e298f9dc08e81209a98dea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68fae34e298f9dc08e81209a98dea89">&#9670;&nbsp;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI int lala::num_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in the formula <code>F</code> including existential quantifier, logical variables and abstract variables. Each occurrence of a variable is added up (duplicates are counted). </dd></dl>

</div>
</div>
<a id="a66dda4c39e820cfd39e75737378d033e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dda4c39e820cfd39e75737378d033e">&#9670;&nbsp;</a></span>num_quantified_vars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of existential quantifiers. </dd></dl>

</div>
</div>
<a id="a6fdf54773f9858c9ef2b06b250f3a0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdf54773f9858c9ef2b06b250f3a0c3">&#9670;&nbsp;</a></span>num_quantified_vars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in an existential quantifier that have type <code>aty</code>. </dd></dl>

</div>
</div>
<a id="a3749d6ff27c5005bbbe560ede8ee98a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3749d6ff27c5005bbbe560ede8ee98a0">&#9670;&nbsp;</a></span>num_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t lala::num_constraints </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93ff80f41d2a60ce49d9d969792f3818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff80f41d2a60ce49d9d969792f3818">&#9670;&nbsp;</a></span>type_of_conjunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> lala::type_of_conjunction </td>
          <td>(</td>
          <td class="paramtype">const typename F::Sequence &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2af6441863bd25ce8c40bc31a4e988d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af6441863bd25ce8c40bc31a4e988d6">&#9670;&nbsp;</a></span>extract_ty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI battery::tuple&lt;F,F&gt; lala::extract_ty </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a conjunctive formula <code>f</code> of the form \( c_1 \land ... \land c_n \), it returns a pair \( \langle c_i \land .. \land c_j, c_k \land ... \land c_l \rangle \) such that the first component contains all formulas with the type <code>ty</code>, and the second component, all other formulas. </p>

</div>
</div>
<a id="a61c82f922a369376733ac1ceb63f2ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c82f922a369376733ac1ceb63f2ecc">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt; F &gt; lala::negate </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7903710a42f3bdc161f79c13b2d3b33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7903710a42f3bdc161f79c13b2d3b33e">&#9670;&nbsp;</a></span>de_morgan_law()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt;F&gt; lala::de_morgan_law </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig_neg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>not(f1 \/ ... \/ fn) --&gt; not(f1) /\ ... /\ not(fn) not(f1 /\ ... /\ fn) --&gt; not(f1) \/ ... \/ not(fn) </p>

</div>
</div>
<a id="af36d1200033fd624fe0baa3632553b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36d1200033fd624fe0baa3632553b49">&#9670;&nbsp;</a></span>negate_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt;F&gt; lala::negate_eq </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad13b1cbdaf671ada055fcddffa64786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13b1cbdaf671ada055fcddffa64786e">&#9670;&nbsp;</a></span>negate_arithmetic_comparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::negate_arithmetic_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46b8c9e53b51af981665045ab0ef5789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b8c9e53b51af981665045ab0ef5789">&#9670;&nbsp;</a></span>is_arithmetic_comparison() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_arithmetic_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators &lt;=, &lt;, &gt;, &gt;=, =, != </p>

</div>
</div>
<a id="af5ec9df0db7364e9a1d4a6cf55133bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ec9df0db7364e9a1d4a6cf55133bc0">&#9670;&nbsp;</a></span>is_set_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_set_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators =, !=, subset, subseteq, supset, supseteq </p>

</div>
</div>
<a id="aa96505876a4dc4a73e9dcac1df80ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96505876a4dc4a73e9dcac1df80ba16">&#9670;&nbsp;</a></span>is_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators &lt;=, &lt;, &gt;, &gt;=, =, !=, subset, subseteq, supset, supseteq </p>

</div>
</div>
<a id="a37723381538b58c397b57008bcc7671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37723381538b58c397b57008bcc7671b">&#9670;&nbsp;</a></span>converse_comparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::converse_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the converse of a comparison operator (see <code>is_comparison</code>). </p>

</div>
</div>
<a id="a1c3a823ec9c5e512892e628d8311c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3a823ec9c5e512892e628d8311c543">&#9670;&nbsp;</a></span>map_avar_to_lvar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI void lala::map_avar_to_lvar </td>
          <td>(</td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code>, we transform all occurrences of <code><a class="el" href="classlala_1_1_a_var.html">AVar</a></code> into logical variables. </p>

</div>
</div>
<a id="ae6506d073b2c1165fa92bffeae6fd4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6506d073b2c1165fa92bffeae6fd4bf">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI F lala::eval </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a505158a64e90b36755f6e84b5db6b987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505158a64e90b36755f6e84b5db6b987">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI F lala::normalize </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We do simple transformation on the formula to obtain a sort of normal form such that:</p><ol type="1">
<li>For all c &lt;op&gt; t, where <code>c</code> is a constant and <code>t</code> a term, we transform it into t &lt;converse-op&gt; c, whenever &lt;op&gt; has a converse.</li>
<li>For all t &lt;op&gt; v, where <code>v</code> is a constant and <code>t</code> a term (not a variable or constant), we transform it into v &lt;converse-op&gt; t, whenever &lt;op&gt; has a converse.</li>
<li>Try to push NOT inside the formula (see <code>negate</code>).</li>
<li>Transform <code>not x</code> into <code>x = 0</code>.</li>
<li>Transform <code>x in {v}</code> into <code>x = v</code>.</li>
</ol>
<p>This avoids to repeat the same transformation in different abstract domains. </p>

</div>
</div>
<a id="af1aed9c4d9ba677f7255545ffa2f7df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aed9c4d9ba677f7255545ffa2f7df3">&#9670;&nbsp;</a></span>decompose_in_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA F lala::decompose_in_constraint </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename F::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>typename&#160;F::allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a constraint of the form <code>t in S</code> where S is a set of intervals {[l1,u1],..,[lN,uN]}, create a disjunction where each term represents interval. </p>

</div>
</div>
<a id="ab77aa301355868d2d9458857ea2946a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77aa301355868d2d9458857ea2946a8">&#9670;&nbsp;</a></span>decompose_arith_neq_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA F lala::decompose_arith_neq_constraint </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename F::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>typename&#160;F::allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23e4cd05f6c827108d47c98443be639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e4cd05f6c827108d47c98443be639e">&#9670;&nbsp;</a></span>string_of_sig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI const char* lala::string_of_sig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2b298de3e0cbb50bbc02bc606b7c56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b298de3e0cbb50bbc02bc606b7c56a">&#9670;&nbsp;</a></span>is_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf05545f06bb4e74db05c3c520cb31e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf05545f06bb4e74db05c3c520cb31e8">&#9670;&nbsp;</a></span>is_division()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_division </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97ff9ae908dd0eed685d87631506b3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ff9ae908dd0eed685d87631506b3eb">&#9670;&nbsp;</a></span>is_modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b055c3c2499841f43012304df8c0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b055c3c2499841f43012304df8c0686">&#9670;&nbsp;</a></span>is_associative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_associative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa36870240eda9c7f0b1d4a3c063e10cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36870240eda9c7f0b1d4a3c063e10cd">&#9670;&nbsp;</a></span>is_arithmetic_comparison() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_arithmetic_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b74d0fad8edd85cd73c0b82b0df6345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b74d0fad8edd85cd73c0b82b0df6345">&#9670;&nbsp;</a></span>is_logical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_logical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18a0c6edcd92ebf5d23f69e8b9211fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a0c6edcd92ebf5d23f69e8b9211fb9">&#9670;&nbsp;</a></span>is_predicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa035eb336900b61d13e7f0dbc517d334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035eb336900b61d13e7f0dbc517d334">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1362bc0d6ef66f109c173073a12d63c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1362bc0d6ef66f109c173073a12d63c2">&#9670;&nbsp;</a></span>var_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt;std::reference_wrapper&lt;const typename Env::variable_type&gt; &gt; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code> and an environment, return the first variable occurring in <code>f</code> or <code>{}</code> if <code>f</code> has no variable in <code>env</code>. </p>

</div>
</div>
<a id="a06f3e5ada938781bdb8c667a159242fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3e5ada938781bdb8c667a159242fe">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc1 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad33f36a358eb1db17dc852e6bb2bf314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33f36a358eb1db17dc852e6bb2bf314">&#9670;&nbsp;</a></span>ternarize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env  = VarEnv&lt;battery::standard_allocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F lala::ternarize </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code>Env()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ternarize_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code>, we transform it into a conjunction of formulas of this form:</p><ol type="1">
<li><code>x &lt;op&gt; c</code> where <code>c</code> is a constant.</li>
<li><code>x = (y &lt;op&gt; z)</code> where <code>&lt;op&gt;</code> is a binary operator, either arithmetic or a comparison (<code>=</code>, <code>&lt;=</code>). This ternary form is used by the lala-pc/PIR solver. </li>
</ol>

</div>
</div>
<a id="a4a8490aa25a4cc0da52f96a42f15ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8490aa25a4cc0da52f96a42f15ad70">&#9670;&nbsp;</a></span>project_fun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class R  = A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R lala::project_fun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf205cdf4c3b33d9ea65f971b991d889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf205cdf4c3b33d9ea65f971b991d889">&#9670;&nbsp;</a></span>project_fun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class R  = A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R lala::project_fun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a420f1397076bb29c788d18a0fb7026cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420f1397076bb29c788d18a0fb7026cf">&#9670;&nbsp;</a></span>dual_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LDual , class L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA LDual lala::dual_bound </td>
          <td>(</td>
          <td class="paramtype">const L &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is useful when we need to convert a value to its dual. The dual is the upset of the current element, therefore, if we have \( x &lt;= 10 \), the dual is given by the formula \( x &gt;= 10 \) interpreted in the dual lattice. In that case, it just changes the type of the lattice without changing the value. A difference occurs on the bottom and top element. Indeed, by our representation of bot and top, the bottom value in a lattice L equals the top value in its dual, but we need them to remain the same, so the dual of <code>L::bot()</code> is <code>LDual::bot()</code>. </p>

</div>
</div>
<a id="acef2677570c6f6ec0d7a1e2cdb2ab9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef2677570c6f6ec0d7a1e2cdb2ab9ce">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;Pre, battery::local_memory&gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06e07ba657ba73aaedcc78067610995b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e07ba657ba73aaedcc78067610995b">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;Pre, battery::local_memory&gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abde3a19b9b8c0771697b998e73b6b3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde3a19b9b8c0771697b998e73b6b3b4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5cf5cb9621c122f5d07f984c6068400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cf5cb9621c122f5d07f984c6068400">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f237b352671c72809dad61c4497fced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f237b352671c72809dad61c4497fced">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab763178be18bb44d0b87b0238b5ed640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab763178be18bb44d0b87b0238b5ed640">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefb47c1e9ba853b1aa9957c719b2bfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb47c1e9ba853b1aa9957c719b2bfa4">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;Pre, battery::local_memory&gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bc376306287a55597f33c913258b968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc376306287a55597f33c913258b968">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;Pre, battery::local_memory&gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1760bbb14c23377e4be9f1ddedffb5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1760bbb14c23377e4be9f1ddedffb5f6">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1047b3d6574fcae4465468ba6e419ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1047b3d6574fcae4465468ba6e419ba3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a751c07b747cf648832084c3fa1f89aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751c07b747cf648832084c3fa1f89aa7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a547ed695047c53bc105eea3fe6ec28e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547ed695047c53bc105eea3fe6ec28e5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac073e87bc30d52a9329b59939cce2392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac073e87bc30d52a9329b59939cce2392">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt;N, battery::local_memory, T&gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85bd6c20fd135c37a166cf466824aa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bd6c20fd135c37a166cf466824aa02">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt;N, battery::local_memory, T&gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4afb1e07ef7fded7169167039a9f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4afb1e07ef7fded7169167039a9f3e">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a9288ef392ccc3f0ebb6c3cf7dc2dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9288ef392ccc3f0ebb6c3cf7dc2dec">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04bec15dd642120a7e93033c3ebaeeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bec15dd642120a7e93033c3ebaeeaf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7828840d9064772b024638e0e9aba5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7828840d9064772b024638e0e9aba5ce">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0215c5410b2314e5aa2b4566c459f0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0215c5410b2314e5aa2b4566c459f0aa">&#9670;&nbsp;</a></span>fmeet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c34bdae41587c8c7dd9264fde5d2f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34bdae41587c8c7dd9264fde5d2f4a">&#9670;&nbsp;</a></span>fjoin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d08be75dca11487b354fa4bdea0c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d08be75dca11487b354fa4bdea0c87">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a511f6fbe14852b39dd74918800f04441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511f6fbe14852b39dd74918800f04441">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af527b0d9cb84ef22cddd191486265146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af527b0d9cb84ef22cddd191486265146">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9009ac0a37e31306fe8bd5fd738eb469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9009ac0a37e31306fe8bd5fd738eb469">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vstore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
