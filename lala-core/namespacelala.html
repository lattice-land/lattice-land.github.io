<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Land Core Library: lala Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lattice Land Core Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacelala.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lala Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala_1_1local.html">local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_deps.html">AbstractDeps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_atomic_extraction.html">AtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_b.html">B</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_dispatch_index.html">DispatchIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_gauss_seidel_iteration.html">GaussSeidelIteration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_hash_map_var_index.html">HashMapVarIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_list_var_index.html">ListVarIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_n_bitset.html">NBitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_non_atomic_extraction.html">NonAtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_dec.html">PreSDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_inc.html">PreSInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_simplifier.html">Simplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_sort.html">Sort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_t_formula.html">TFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_var_env.html">VarEnv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_variable.html">Variable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_v_store.html">VStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a91627a807540978fdae230d4457d6805" id="r_a91627a807540978fdae230d4457d6805"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a91627a807540978fdae230d4457d6805"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91627a807540978fdae230d4457d6805">abstract_ptr</a> = battery::shared_ptr&lt;A, typename A::allocator_type&gt;</td></tr>
<tr class="separator:a91627a807540978fdae230d4457d6805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2c3adc0efc7b60c27edd38dcad08ce" id="r_a8a2c3adc0efc7b60c27edd38dcad08ce"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a8a2c3adc0efc7b60c27edd38dcad08ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a2c3adc0efc7b60c27edd38dcad08ce">LVar</a> = battery::string&lt;Allocator&gt;</td></tr>
<tr class="separator:a8a2c3adc0efc7b60c27edd38dcad08ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9e4be0630d656d38a75c914de03c40" id="r_a2b9e4be0630d656d38a75c914de03c40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> = int</td></tr>
<tr class="separator:a2b9e4be0630d656d38a75c914de03c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cdb1d38b9fce25dd5791e40cc8bd14" id="r_a72cdb1d38b9fce25dd5791e40cc8bd14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72cdb1d38b9fce25dd5791e40cc8bd14">logic_bool</a> = bool</td></tr>
<tr class="separator:a72cdb1d38b9fce25dd5791e40cc8bd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5e8c539e0b34bc5a59e90593ede563" id="r_a6b5e8c539e0b34bc5a59e90593ede563"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">logic_int</a> = long long int</td></tr>
<tr class="separator:a6b5e8c539e0b34bc5a59e90593ede563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c6e8de482686b5f51bfab62709080b" id="r_a68c6e8de482686b5f51bfab62709080b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c6e8de482686b5f51bfab62709080b">logic_real</a> = battery::tuple&lt;double, double&gt;</td></tr>
<tr class="separator:a68c6e8de482686b5f51bfab62709080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cb772dc141687e1737e8fe9253f525" id="r_a09cb772dc141687e1737e8fe9253f525"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a09cb772dc141687e1737e8fe9253f525"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09cb772dc141687e1737e8fe9253f525">logic_set</a> = battery::vector&lt;battery::tuple&lt;F, F&gt;, typename F::allocator_type&gt;</td></tr>
<tr class="separator:a09cb772dc141687e1737e8fe9253f525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e489a62c936a5c92f7d1ed13088717" id="r_ac9e489a62c936a5c92f7d1ed13088717"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:ac9e489a62c936a5c92f7d1ed13088717"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9e489a62c936a5c92f7d1ed13088717">ZLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:ac9e489a62c936a5c92f7d1ed13088717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199dd4298f467da23afbe2fbe92b1ff7" id="r_a199dd4298f467da23afbe2fbe92b1ff7"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a199dd4298f467da23afbe2fbe92b1ff7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a199dd4298f467da23afbe2fbe92b1ff7">ZUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:a199dd4298f467da23afbe2fbe92b1ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693819038d669f682ca60792efe22763" id="r_a693819038d669f682ca60792efe22763"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a693819038d669f682ca60792efe22763"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a693819038d669f682ca60792efe22763">FLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:a693819038d669f682ca60792efe22763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c2876708f5cf8bca435dfff880be67" id="r_a36c2876708f5cf8bca435dfff880be67"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a36c2876708f5cf8bca435dfff880be67"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36c2876708f5cf8bca435dfff880be67">FUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:a36c2876708f5cf8bca435dfff880be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06af1aa721c62bd9380856db637bf03b" id="r_a06af1aa721c62bd9380856db637bf03b"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a06af1aa721c62bd9380856db637bf03b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06af1aa721c62bd9380856db637bf03b">ZFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:a06af1aa721c62bd9380856db637bf03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95404a0273e5868af886c6683b2d3e20" id="r_a95404a0273e5868af886c6683b2d3e20"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a95404a0273e5868af886c6683b2d3e20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95404a0273e5868af886c6683b2d3e20">FFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td></tr>
<tr class="separator:a95404a0273e5868af886c6683b2d3e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac24a8d85a4dfb9ed5e5ffcd09a4c60ed" id="r_ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> { <a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60eda9fb730caf1b2d638a1dcf747f0d4207d">ASK</a>
, <a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60edaca29caf9aab7f5eb7b91a531650cb517">TELL</a>
 }</td></tr>
<tr class="separator:ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be41540c5051a480d0611a3e216b659" id="r_a4be41540c5051a480d0611a3e216b659"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> { <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82">NEG</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e">ABS</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02">ADD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c">SUB</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982">MUL</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc">POW</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd">MIN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0">MAX</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539">SQRT</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e">EXP</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c">LN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91">NROOT</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6">LOG</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8">SIN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976">COS</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951">TAN</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869">ASIN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d">ACOS</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29">ATAN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049">SINH</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d">COSH</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a">TANH</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb">ASINH</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd">ACOSH</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e">ATANH</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0">DIV</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845">MOD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af">TDIV</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858">TMOD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503">FDIV</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f">FMOD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188">CDIV</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187">CMOD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f">EDIV</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8">EMOD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1">UNION</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac">INTERSECTION</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2">DIFFERENCE</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149">SYMMETRIC_DIFFERENCE</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480">COMPLEMENT</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed">SUBSET</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134">SUBSETEQ</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50">SUPSET</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc">SUPSETEQ</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4">IN</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2">CARD</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a">HULL</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed">CONVEX</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134">EQ</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6">NEQ</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066">LEQ</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad">GEQ</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69">LT</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651">GT</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e">AND</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9">OR</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd">IMPLY</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b">EQUIV</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e">NOT</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041">XOR</a>
, <br />
&#160;&#160;<a class="el" href="#a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5">ITE</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856">MAXIMIZE</a>
, <a class="el" href="#a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6">MINIMIZE</a>
<br />
 }</td></tr>
<tr class="separator:a4be41540c5051a480d0611a3e216b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9857d1d4caeb321edd3979c9bf2f7b6" id="r_af9857d1d4caeb321edd3979c9bf2f7b6"><td class="memTemplParams" colspan="2">template&lt;size_t i, class... As&gt; </td></tr>
<tr class="memitem:af9857d1d4caeb321edd3979c9bf2f7b6"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9857d1d4caeb321edd3979c9bf2f7b6">project</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;cp)</td></tr>
<tr class="memdesc:af9857d1d4caeb321edd3979c9bf2f7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax.  <br /></td></tr>
<tr class="separator:af9857d1d4caeb321edd3979c9bf2f7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0855e38d7627dab30836c30481a6dc" id="r_afa0855e38d7627dab30836c30481a6dc"><td class="memTemplParams" colspan="2">template&lt;size_t i, class... As&gt; </td></tr>
<tr class="memitem:afa0855e38d7627dab30836c30481a6dc"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa0855e38d7627dab30836c30481a6dc">project</a> (<a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;cp)</td></tr>
<tr class="separator:afa0855e38d7627dab30836c30481a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc9e58992ea85758270743d0bd62c90" id="r_a3fc9e58992ea85758270743d0bd62c90"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a3fc9e58992ea85758270743d0bd62c90"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3fc9e58992ea85758270743d0bd62c90">fjoin</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a3fc9e58992ea85758270743d0bd62c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42297b1d8d6ad4374d6550421761df5" id="r_ab42297b1d8d6ad4374d6550421761df5"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:ab42297b1d8d6ad4374d6550421761df5"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab42297b1d8d6ad4374d6550421761df5">fmeet</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:ab42297b1d8d6ad4374d6550421761df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909139c7fbbea78476539a48bb989e9" id="r_aa909139c7fbbea78476539a48bb989e9"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:aa909139c7fbbea78476539a48bb989e9"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa909139c7fbbea78476539a48bb989e9">operator&lt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:aa909139c7fbbea78476539a48bb989e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4632875e493f8e8dce9f43d1d2d0387" id="r_ab4632875e493f8e8dce9f43d1d2d0387"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:ab4632875e493f8e8dce9f43d1d2d0387"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4632875e493f8e8dce9f43d1d2d0387">operator&gt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:ab4632875e493f8e8dce9f43d1d2d0387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44314d29734db79278128b688836bcb5" id="r_a44314d29734db79278128b688836bcb5"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a44314d29734db79278128b688836bcb5"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44314d29734db79278128b688836bcb5">operator==</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a44314d29734db79278128b688836bcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d25524e24ca7311659d66cb013d1c3" id="r_a04d25524e24ca7311659d66cb013d1c3"><td class="memTemplParams" colspan="2">template&lt;class A , class... As&gt; </td></tr>
<tr class="memitem:a04d25524e24ca7311659d66cb013d1c3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04d25524e24ca7311659d66cb013d1c3">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;cp)</td></tr>
<tr class="separator:a04d25524e24ca7311659d66cb013d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860555919eb11a23caf88c6326961127" id="r_a860555919eb11a23caf88c6326961127"><td class="memTemplParams" colspan="2">template&lt;class L , <a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F &gt; </td></tr>
<tr class="memitem:a860555919eb11a23caf88c6326961127"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a860555919eb11a23caf88c6326961127">ginterpret_true</a> (const F &amp;f, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a860555919eb11a23caf88c6326961127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c2ef9e5728a6e1c89b7ce5ffefdce" id="r_ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class A , class F , class Env , class I &gt; </td></tr>
<tr class="memitem:ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad43c2ef9e5728a6e1c89b7ce5ffefdce">ginterpret_in</a> (const A &amp;a, const F &amp;f, Env &amp;env, I &amp;intermediate, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:ad43c2ef9e5728a6e1c89b7ce5ffefdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c4c21442cb5e55dec7f733b5409254" id="r_a65c4c21442cb5e55dec7f733b5409254"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F , class Env , class U &gt; </td></tr>
<tr class="memitem:a65c4c21442cb5e55dec7f733b5409254"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65c4c21442cb5e55dec7f733b5409254">ginterpret_in</a> (const F &amp;f, const Env &amp;env, U &amp;value, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a65c4c21442cb5e55dec7f733b5409254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5410dc3f527e6cd2a110c6966b3de8b4" id="r_a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class A , class F , class Env , class I &gt; </td></tr>
<tr class="memitem:a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5410dc3f527e6cd2a110c6966b3de8b4">top_level_ginterpret_in</a> (const A &amp;a, const F &amp;f, Env &amp;env, I &amp;intermediate, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics)</td></tr>
<tr class="separator:a5410dc3f527e6cd2a110c6966b3de8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f4e6f8e78e5e31c42de55d4d3f65e" id="r_a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memTemplParams" colspan="2">template&lt;class A , class Alloc  = battery::standard_allocator, class Env &gt; </td></tr>
<tr class="memitem:a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memTemplItemLeft" align="right" valign="top">CUDA A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a431f4e6f8e78e5e31c42de55d4d3f65e">make_top</a> (Env &amp;env, Alloc alloc=Alloc{})</td></tr>
<tr class="separator:a431f4e6f8e78e5e31c42de55d4d3f65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b931b522b200e25aaf0b5574700db9" id="r_ab2b931b522b200e25aaf0b5574700db9"><td class="memTemplParams" colspan="2">template&lt;bool diagnose = false, class TellAlloc  = battery::standard_allocator, class F , class Env , class L &gt; </td></tr>
<tr class="memitem:ab2b931b522b200e25aaf0b5574700db9"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2b931b522b200e25aaf0b5574700db9">interpret_and_tell</a> (const F &amp;f, Env &amp;env, L &amp;value, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics, TellAlloc tell_alloc=TellAlloc{})</td></tr>
<tr class="separator:ab2b931b522b200e25aaf0b5574700db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6334729ccf128a1381a39f7f1c8a17f" id="r_aa6334729ccf128a1381a39f7f1c8a17f"><td class="memTemplParams" colspan="2">template&lt;class A , bool diagnose = false, class F , class Env , class TellAlloc  = typename A::allocator_type&gt; </td></tr>
<tr class="memitem:aa6334729ccf128a1381a39f7f1c8a17f"><td class="memTemplItemLeft" align="right" valign="top">CUDA std::optional&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6334729ccf128a1381a39f7f1c8a17f">create_and_interpret_and_tell</a> (const F &amp;f, Env &amp;env, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics, typename A::allocator_type alloc=typename A::allocator_type{}, TellAlloc tell_alloc=TellAlloc{})</td></tr>
<tr class="separator:aa6334729ccf128a1381a39f7f1c8a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d15ad8d7e0974c7b2bb1a88c3f3277" id="r_ac2d15ad8d7e0974c7b2bb1a88c3f3277"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ac2d15ad8d7e0974c7b2bb1a88c3f3277"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2d15ad8d7e0974c7b2bb1a88c3f3277">meet</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;)</td></tr>
<tr class="separator:ac2d15ad8d7e0974c7b2bb1a88c3f3277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac485671cf0aa58bb6ade85356ff8ddcb" id="r_ac485671cf0aa58bb6ade85356ff8ddcb"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ac485671cf0aa58bb6ade85356ff8ddcb"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac485671cf0aa58bb6ade85356ff8ddcb">fjoin</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:ac485671cf0aa58bb6ade85356ff8ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d16f226d295bee37e4c44482fa8c732" id="r_a4d16f226d295bee37e4c44482fa8c732"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a4d16f226d295bee37e4c44482fa8c732"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d16f226d295bee37e4c44482fa8c732">fmeet</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a4d16f226d295bee37e4c44482fa8c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d436ce98ff7d08515c9b113594c006b" id="r_a3d436ce98ff7d08515c9b113594c006b"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a3d436ce98ff7d08515c9b113594c006b"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d436ce98ff7d08515c9b113594c006b">operator&lt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a3d436ce98ff7d08515c9b113594c006b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9882b578e2f8b02730f31620b51cd026" id="r_a9882b578e2f8b02730f31620b51cd026"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a9882b578e2f8b02730f31620b51cd026"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9882b578e2f8b02730f31620b51cd026">operator&gt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a9882b578e2f8b02730f31620b51cd026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c95a394c05fd2c3e46d72ec1fcc934b" id="r_a6c95a394c05fd2c3e46d72ec1fcc934b"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a6c95a394c05fd2c3e46d72ec1fcc934b"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c95a394c05fd2c3e46d72ec1fcc934b">operator==</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a6c95a394c05fd2c3e46d72ec1fcc934b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0b0c30b7a7b1cf51a7239b8bb2674d" id="r_a8e0b0c30b7a7b1cf51a7239b8bb2674d"><td class="memTemplParams" colspan="2">template&lt;class L &gt; </td></tr>
<tr class="memitem:a8e0b0c30b7a7b1cf51a7239b8bb2674d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e0b0c30b7a7b1cf51a7239b8bb2674d">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;itv)</td></tr>
<tr class="separator:a8e0b0c30b7a7b1cf51a7239b8bb2674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9" id="r_a095313c4ac1c353450411ecd930b24c9"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a095313c4ac1c353450411ecd930b24c9">is_v_op_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a095313c4ac1c353450411ecd930b24c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c" id="r_a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8264bf97bc739bc4ef3de14b159d4d6c">is_v_op_z</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b489e2f66fc4666a9d9d5dd07f0a5" id="r_a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a704b489e2f66fc4666a9d9d5dd07f0a5">is_var_equality</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f)</td></tr>
<tr class="separator:a704b489e2f66fc4666a9d9d5dd07f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e72bb3380853c8c65ff15a601e3d18" id="r_a73e72bb3380853c8c65ff15a601e3d18"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a73e72bb3380853c8c65ff15a601e3d18"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73e72bb3380853c8c65ff15a601e3d18">make_v_op_z</a> (<a class="el" href="#a8a2c3adc0efc7b60c27edd38dcad08ce">LVar</a>&lt; Allocator &gt; v, <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">logic_int</a> z, <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:a73e72bb3380853c8c65ff15a601e3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98e8affc35bd856ed8c317c57beb93" id="r_a1c98e8affc35bd856ed8c317c57beb93"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a1c98e8affc35bd856ed8c317c57beb93"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c98e8affc35bd856ed8c317c57beb93">make_v_op_z</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> v, <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">logic_int</a> z, <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:a1c98e8affc35bd856ed8c317c57beb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44fa0949aa0050534b4e5888182cf27" id="r_ac44fa0949aa0050534b4e5888182cf27"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:ac44fa0949aa0050534b4e5888182cf27"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac44fa0949aa0050534b4e5888182cf27">geq_of_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;f)</td></tr>
<tr class="separator:ac44fa0949aa0050534b4e5888182cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99742669495aa20254d238796f3225f9" id="r_a99742669495aa20254d238796f3225f9"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:a99742669495aa20254d238796f3225f9"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99742669495aa20254d238796f3225f9">leq_of_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;f)</td></tr>
<tr class="separator:a99742669495aa20254d238796f3225f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61da309e0f805e38d1b86a1d9bf4b70" id="r_ad61da309e0f805e38d1b86a1d9bf4b70"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:ad61da309e0f805e38d1b86a1d9bf4b70"><td class="memTemplItemLeft" align="right" valign="top">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad61da309e0f805e38d1b86a1d9bf4b70">var_in</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f)</td></tr>
<tr class="separator:ad61da309e0f805e38d1b86a1d9bf4b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89" id="r_ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac68fae34e298f9dc08e81209a98dea89">num_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:ac68fae34e298f9dc08e81209a98dea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea742778e40b41e47d53e2f205b7f33" id="r_a7ea742778e40b41e47d53e2f205b7f33"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a7ea742778e40b41e47d53e2f205b7f33"><td class="memTemplItemLeft" align="right" valign="top">CUDA int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ea742778e40b41e47d53e2f205b7f33">num_quantified_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:a7ea742778e40b41e47d53e2f205b7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595c82a412e489c8ca65997a3ce2a199" id="r_a595c82a412e489c8ca65997a3ce2a199"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a595c82a412e489c8ca65997a3ce2a199"><td class="memTemplItemLeft" align="right" valign="top">CUDA int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a595c82a412e489c8ca65997a3ce2a199">num_quantified_vars</a> (const F &amp;f, <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> aty)</td></tr>
<tr class="separator:a595c82a412e489c8ca65997a3ce2a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818" id="r_a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93ff80f41d2a60ce49d9d969792f3818">type_of_conjunction</a> (const typename F::Sequence &amp;seq)</td></tr>
<tr class="separator:a93ff80f41d2a60ce49d9d969792f3818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814b7acfb675818f3775fe2ca64c5059" id="r_a814b7acfb675818f3775fe2ca64c5059"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a814b7acfb675818f3775fe2ca64c5059"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI battery::tuple&lt; F, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a814b7acfb675818f3775fe2ca64c5059">extract_ty</a> (const F &amp;f, <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> ty)</td></tr>
<tr class="separator:a814b7acfb675818f3775fe2ca64c5059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c82f922a369376733ac1ceb63f2ecc" id="r_a61c82f922a369376733ac1ceb63f2ecc"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a61c82f922a369376733ac1ceb63f2ecc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61c82f922a369376733ac1ceb63f2ecc">negate</a> (const F &amp;f)</td></tr>
<tr class="separator:a61c82f922a369376733ac1ceb63f2ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caa21841419c6fd7f24ec5e8e615b26" id="r_a2caa21841419c6fd7f24ec5e8e615b26"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a2caa21841419c6fd7f24ec5e8e615b26"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2caa21841419c6fd7f24ec5e8e615b26">de_morgan_law</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig_neg, const F &amp;f)</td></tr>
<tr class="separator:a2caa21841419c6fd7f24ec5e8e615b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f21dcd4bdfdb672fdf29d9be8bdc2" id="r_a058f21dcd4bdfdb672fdf29d9be8bdc2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a058f21dcd4bdfdb672fdf29d9be8bdc2"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a058f21dcd4bdfdb672fdf29d9be8bdc2">negate_eq</a> (const F &amp;f)</td></tr>
<tr class="separator:a058f21dcd4bdfdb672fdf29d9be8bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b1cbdaf671ada055fcddffa64786e" id="r_ad13b1cbdaf671ada055fcddffa64786e"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13b1cbdaf671ada055fcddffa64786e">negate_arithmetic_comparison</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:ad13b1cbdaf671ada055fcddffa64786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b8c9e53b51af981665045ab0ef5789" id="r_a46b8c9e53b51af981665045ab0ef5789"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a46b8c9e53b51af981665045ab0ef5789"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46b8c9e53b51af981665045ab0ef5789">is_arithmetic_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:a46b8c9e53b51af981665045ab0ef5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec9df0db7364e9a1d4a6cf55133bc0" id="r_af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5ec9df0db7364e9a1d4a6cf55133bc0">is_set_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:af5ec9df0db7364e9a1d4a6cf55133bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16" id="r_aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa96505876a4dc4a73e9dcac1df80ba16">is_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37723381538b58c397b57008bcc7671b" id="r_a37723381538b58c397b57008bcc7671b"><td class="memItemLeft" align="right" valign="top">CUDA NI <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37723381538b58c397b57008bcc7671b">converse_comparison</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a37723381538b58c397b57008bcc7671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3a823ec9c5e512892e628d8311c543" id="r_a1c3a823ec9c5e512892e628d8311c543"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a1c3a823ec9c5e512892e628d8311c543"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c3a823ec9c5e512892e628d8311c543">map_avar_to_lvar</a> (F &amp;f, const Env &amp;env, bool erase_type=false)</td></tr>
<tr class="separator:a1c3a823ec9c5e512892e628d8311c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6506d073b2c1165fa92bffeae6fd4bf" id="r_ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6506d073b2c1165fa92bffeae6fd4bf">eval</a> (const F &amp;f)</td></tr>
<tr class="separator:ae6506d073b2c1165fa92bffeae6fd4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8550569c2adf06a8d8ce470bd2e3e9" id="r_aad8550569c2adf06a8d8ce470bd2e3e9"><td class="memItemLeft" align="right" valign="top">CUDA NI const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad8550569c2adf06a8d8ce470bd2e3e9">string_of_sig</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:aad8550569c2adf06a8d8ce470bd2e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9decc16cdfba74c367b1edf7110e595f" id="r_a9decc16cdfba74c367b1edf7110e595f"><td class="memItemLeft" align="right" valign="top">CUDA NI constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9decc16cdfba74c367b1edf7110e595f">is_prefix</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a9decc16cdfba74c367b1edf7110e595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39552615f718c4f45eece484b13baa8" id="r_ab39552615f718c4f45eece484b13baa8"><td class="memItemLeft" align="right" valign="top">CUDA NI constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab39552615f718c4f45eece484b13baa8">is_division</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:ab39552615f718c4f45eece484b13baa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf455317064ad356964a272138df9b5" id="r_adcf455317064ad356964a272138df9b5"><td class="memItemLeft" align="right" valign="top">CUDA NI constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf455317064ad356964a272138df9b5">is_modulo</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:adcf455317064ad356964a272138df9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad1145d2bc437a38928e69fc17af113" id="r_a4ad1145d2bc437a38928e69fc17af113"><td class="memItemLeft" align="right" valign="top">CUDA NI constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ad1145d2bc437a38928e69fc17af113">is_associative</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a4ad1145d2bc437a38928e69fc17af113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334" id="r_aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa035eb336900b61d13e7f0dbc517d334">operator==</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;lhs, const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;rhs)</td></tr>
<tr class="separator:aa035eb336900b61d13e7f0dbc517d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33084787dfef943a2b5174bb4ccf177f" id="r_a33084787dfef943a2b5174bb4ccf177f"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a33084787dfef943a2b5174bb4ccf177f"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI std::optional&lt; std::reference_wrapper&lt; const typename Env::variable_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33084787dfef943a2b5174bb4ccf177f">var_in</a> (const F &amp;f, const Env &amp;env)</td></tr>
<tr class="separator:a33084787dfef943a2b5174bb4ccf177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe" id="r_a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplParams" colspan="2">template&lt;class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06f3e5ada938781bdb8c667a159242fe">operator==</a> (const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;lhs, const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a06f3e5ada938781bdb8c667a159242fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8490aa25a4cc0da52f96a42f15ad70" id="r_a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memTemplParams" colspan="2">template&lt;class A , class R  = A&gt; </td></tr>
<tr class="memitem:a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a8490aa25a4cc0da52f96a42f15ad70">project_fun</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> fun, const A &amp;a, const A &amp;b)</td></tr>
<tr class="separator:a4a8490aa25a4cc0da52f96a42f15ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf205cdf4c3b33d9ea65f971b991d889" id="r_aaf205cdf4c3b33d9ea65f971b991d889"><td class="memTemplParams" colspan="2">template&lt;class A , class R  = A&gt; </td></tr>
<tr class="memitem:aaf205cdf4c3b33d9ea65f971b991d889"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf205cdf4c3b33d9ea65f971b991d889">project_fun</a> (<a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> fun, const A &amp;a)</td></tr>
<tr class="separator:aaf205cdf4c3b33d9ea65f971b991d889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253331b314cef4226fc0b5f0436a9787" id="r_a253331b314cef4226fc0b5f0436a9787"><td class="memTemplParams" colspan="2">template&lt;class LDual , class L &gt; </td></tr>
<tr class="memitem:a253331b314cef4226fc0b5f0436a9787"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr LDual&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a253331b314cef4226fc0b5f0436a9787">dual</a> (const L &amp;x)</td></tr>
<tr class="separator:a253331b314cef4226fc0b5f0436a9787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d9e032cb1c165afd1a2bd792418185" id="r_ab5d9e032cb1c165afd1a2bd792418185"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:ab5d9e032cb1c165afd1a2bd792418185"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5d9e032cb1c165afd1a2bd792418185">fjoin</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:ab5d9e032cb1c165afd1a2bd792418185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2199dc533c06a5054adee13df82c87b4" id="r_a2199dc533c06a5054adee13df82c87b4"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a2199dc533c06a5054adee13df82c87b4"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2199dc533c06a5054adee13df82c87b4">fmeet</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a2199dc533c06a5054adee13df82c87b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10012e10c6cd87d477ac7b58d8692d9c" id="r_a10012e10c6cd87d477ac7b58d8692d9c"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a10012e10c6cd87d477ac7b58d8692d9c"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10012e10c6cd87d477ac7b58d8692d9c">operator&lt;</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a10012e10c6cd87d477ac7b58d8692d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f658a251c3c92953952792d8e2a2bd" id="r_af4f658a251c3c92953952792d8e2a2bd"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:af4f658a251c3c92953952792d8e2a2bd"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4f658a251c3c92953952792d8e2a2bd">operator&gt;</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:af4f658a251c3c92953952792d8e2a2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c526553b97b12fe3c7b5c3226312a55" id="r_a9c526553b97b12fe3c7b5c3226312a55"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a9c526553b97b12fe3c7b5c3226312a55"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c526553b97b12fe3c7b5c3226312a55">operator==</a> (const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a9c526553b97b12fe3c7b5c3226312a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab003dd4355deb5c5e211ec63ff452a85" id="r_ab003dd4355deb5c5e211ec63ff452a85"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:ab003dd4355deb5c5e211ec63ff452a85"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab003dd4355deb5c5e211ec63ff452a85">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M &gt; &amp;a)</td></tr>
<tr class="separator:ab003dd4355deb5c5e211ec63ff452a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2899339e9e500ce3f6b623dce27b948" id="r_ab2899339e9e500ce3f6b623dce27b948"><td class="memTemplParams" colspan="2">template&lt;class Pre &gt; </td></tr>
<tr class="memitem:ab2899339e9e500ce3f6b623dce27b948"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2899339e9e500ce3f6b623dce27b948">fjoin</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;b)</td></tr>
<tr class="separator:ab2899339e9e500ce3f6b623dce27b948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb16a970f3b7d3d498c54badfba504a9" id="r_aeb16a970f3b7d3d498c54badfba504a9"><td class="memTemplParams" colspan="2">template&lt;class Pre &gt; </td></tr>
<tr class="memitem:aeb16a970f3b7d3d498c54badfba504a9"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb16a970f3b7d3d498c54badfba504a9">fmeet</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;b)</td></tr>
<tr class="separator:aeb16a970f3b7d3d498c54badfba504a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6222341c0bc329fcd15df74413c07fb2" id="r_a6222341c0bc329fcd15df74413c07fb2"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a6222341c0bc329fcd15df74413c07fb2"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6222341c0bc329fcd15df74413c07fb2">operator&lt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a6222341c0bc329fcd15df74413c07fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad555218b1f82ab12881100b30a3ec036" id="r_ad555218b1f82ab12881100b30a3ec036"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:ad555218b1f82ab12881100b30a3ec036"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad555218b1f82ab12881100b30a3ec036">operator&gt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:ad555218b1f82ab12881100b30a3ec036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37e7655b17f0850fda3656c62f962a4" id="r_ab37e7655b17f0850fda3656c62f962a4"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:ab37e7655b17f0850fda3656c62f962a4"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab37e7655b17f0850fda3656c62f962a4">operator==</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:ab37e7655b17f0850fda3656c62f962a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c05037a0a816a678a831710d97a7c5" id="r_a80c05037a0a816a678a831710d97a7c5"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:a80c05037a0a816a678a831710d97a7c5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80c05037a0a816a678a831710d97a7c5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;a)</td></tr>
<tr class="separator:a80c05037a0a816a678a831710d97a7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08574b94fd313aa150af3def34853156" id="r_a08574b94fd313aa150af3def34853156"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a08574b94fd313aa150af3def34853156"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08574b94fd313aa150af3def34853156">fjoin</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a08574b94fd313aa150af3def34853156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b20f603ae44ad4108e4adf9229125a" id="r_a72b20f603ae44ad4108e4adf9229125a"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a72b20f603ae44ad4108e4adf9229125a"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72b20f603ae44ad4108e4adf9229125a">fmeet</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a72b20f603ae44ad4108e4adf9229125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1711a87beb817da46277646f641fe45f" id="r_a1711a87beb817da46277646f641fe45f"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a1711a87beb817da46277646f641fe45f"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1711a87beb817da46277646f641fe45f">operator&lt;</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a1711a87beb817da46277646f641fe45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f9c5c46728f0aa2d051bb944b54d12" id="r_a10f9c5c46728f0aa2d051bb944b54d12"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a10f9c5c46728f0aa2d051bb944b54d12"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10f9c5c46728f0aa2d051bb944b54d12">operator&gt;</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a10f9c5c46728f0aa2d051bb944b54d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53df1bee8511ee593c619415ad7918" id="r_a1e53df1bee8511ee593c619415ad7918"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M1 , class M2 , class T &gt; </td></tr>
<tr class="memitem:a1e53df1bee8511ee593c619415ad7918"><td class="memTemplItemLeft" align="right" valign="top">CUDA constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e53df1bee8511ee593c619415ad7918">operator==</a> (const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;a, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;b)</td></tr>
<tr class="separator:a1e53df1bee8511ee593c619415ad7918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8e2806de947f10ee1aaa3e8b1fb4b" id="r_a92a8e2806de947f10ee1aaa3e8b1fb4b"><td class="memTemplParams" colspan="2">template&lt;size_t N, class M , class T &gt; </td></tr>
<tr class="memitem:a92a8e2806de947f10ee1aaa3e8b1fb4b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92a8e2806de947f10ee1aaa3e8b1fb4b">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M, T &gt; &amp;a)</td></tr>
<tr class="separator:a92a8e2806de947f10ee1aaa3e8b1fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215c5410b2314e5aa2b4566c459f0aa" id="r_a0215c5410b2314e5aa2b4566c459f0aa"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a0215c5410b2314e5aa2b4566c459f0aa"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0215c5410b2314e5aa2b4566c459f0aa">fmeet</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a0215c5410b2314e5aa2b4566c459f0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34bdae41587c8c7dd9264fde5d2f4a" id="r_a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c34bdae41587c8c7dd9264fde5d2f4a">fjoin</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a8c34bdae41587c8c7dd9264fde5d2f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87" id="r_a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09d08be75dca11487b354fa4bdea0c87">operator&lt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a09d08be75dca11487b354fa4bdea0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441" id="r_a511f6fbe14852b39dd74918800f04441"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a511f6fbe14852b39dd74918800f04441">operator&gt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a511f6fbe14852b39dd74918800f04441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146" id="r_af527b0d9cb84ef22cddd191486265146"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af527b0d9cb84ef22cddd191486265146">operator==</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:af527b0d9cb84ef22cddd191486265146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8876a463a08e4218bb4767c097ca0e" id="r_aed8876a463a08e4218bb4767c097ca0e"><td class="memTemplParams" colspan="2">template&lt;class L , class Alloc &gt; </td></tr>
<tr class="memitem:aed8876a463a08e4218bb4767c097ca0e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed8876a463a08e4218bb4767c097ca0e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;vstore)</td></tr>
<tr class="separator:aed8876a463a08e4218bb4767c097ca0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides an extended interface to interpret formulas in abstract domains and abstract universes. It also provides a unified interface for tell and ask interpretation using a template parameter <code>IKind</code>.</p>
<p>A pre-abstract universe is a lattice (with usual operations join, order, ...) equipped with a simple logical interpretation function and a next/prev functions. We consider totally ordered pre-abstract universes with a downset semantics. For any lattice \( L \), we consider an element \( a \in L \) to represent all the concrete elements equal to or below it. This set is called the downset of \( a \) and is denoted \( \mathord{\downarrow}{a} \). The concretization function \( \gamma \) formalizes this idea: \( \gamma(a) = \{x \mapsto b \;|\; b \in \mathord{\downarrow}{a} \cap U \} \) where \( U \) is the universe of discourse. The intersection with \( U \) is necessary to remove potential elements in the abstract universe that are not in the concrete universe of discourse (e.g., \( -\infty, \infty \) below).</p>
<p>The downset semantics associates each element of a lattice to its concrete downset. It is possible to decide that each element is associated to the concrete upset instead. Doing so will reverse our usage of the lattice-theoretic operations (join instead of meet, &lt;= instead of &gt;=, etc.). Instead of considering the upset semantics, it is more convenient to consider the downset semantics of the dual lattice.</p>
<p>Example: The lattice of increasing integer \( \mathit{ZUB} = \langle \{-\infty, \ldots, -2, -1, 0, 1, 2, \ldots, \infty\}, \leq \rangle \) is ordered by the natural arithmetic comparison operator, it represents an upper bound on the set of integers represented. Using the downset semantics, we can represent simple constraints such as \( x \leq 3 \), in which case the downset \( \mathord{\downarrow}{3} = \{\ldots, 1, 2, 3\} \) represents all the values of \( x \) satisfying the constraints \( x \leq 3 \), that is, the solutions of the constraints. By taking the upset semantics of \( \mathit{ZUB} \), we can represent constraints such as \( x \geq 3 \). Alternatively, we can take the dual lattice of decreasing integers \( \mathit{ZLB} = \langle \{\infty, \ldots, 2, 1, 0, -1, -2, \ldots, -\infty\}, \geq \rangle \). The downset semantics of \( \mathit{ZLB} \) corresponds to the upset semantics of \( \mathit{ZUB} \).</p>
<p>From a pre-abstract universe, we obtain an abstract universe using the <code>Universe</code> class below. We also define various aliases to abstract universes such as <code>ZLB</code>, <code>ZUB</code>, etc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a91627a807540978fdae230d4457d6805" name="a91627a807540978fdae230d4457d6805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91627a807540978fdae230d4457d6805">&#9670;&#160;</a></span>abstract_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a91627a807540978fdae230d4457d6805">lala::abstract_ptr</a> = battery::shared_ptr&lt;A, typename A::allocator_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a2c3adc0efc7b60c27edd38dcad08ce" name="a8a2c3adc0efc7b60c27edd38dcad08ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2c3adc0efc7b60c27edd38dcad08ce">&#9670;&#160;</a></span>LVar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8a2c3adc0efc7b60c27edd38dcad08ce">lala::LVar</a> = battery::string&lt;Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "logical variable" is just the name of the variable. </p>

</div>
</div>
<a id="a2b9e4be0630d656d38a75c914de03c40" name="a2b9e4be0630d656d38a75c914de03c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9e4be0630d656d38a75c914de03c40">&#9670;&#160;</a></span>AType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">lala::AType</a> = int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each abstract domain is uniquely identified by an UID. We call it an <em>abstract type</em>. Each formula (and recursively, its subformulas) is assigned to an abstract type indicating in what abstract domain this formula should be interpreted. </p>

</div>
</div>
<a id="a72cdb1d38b9fce25dd5791e40cc8bd14" name="a72cdb1d38b9fce25dd5791e40cc8bd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cdb1d38b9fce25dd5791e40cc8bd14">&#9670;&#160;</a></span>logic_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a72cdb1d38b9fce25dd5791e40cc8bd14">lala::logic_bool</a> = bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of Boolean used in logic formulas. </p>

</div>
</div>
<a id="a6b5e8c539e0b34bc5a59e90593ede563" name="a6b5e8c539e0b34bc5a59e90593ede563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5e8c539e0b34bc5a59e90593ede563">&#9670;&#160;</a></span>logic_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">lala::logic_int</a> = long long int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of integers used in logic formulas. Integers are represented by the set \( \{-\infty, \infty\} \cup Z (\text{ with} Z \subset \mathbb{Z}) \). The minimal and maximal values of <code>logic_int</code> represents \( -\infty \) and \( \infty \) respectively. </p>

</div>
</div>
<a id="a68c6e8de482686b5f51bfab62709080b" name="a68c6e8de482686b5f51bfab62709080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c6e8de482686b5f51bfab62709080b">&#9670;&#160;</a></span>logic_real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a68c6e8de482686b5f51bfab62709080b">lala::logic_real</a> = battery::tuple&lt;double, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of real numbers used in logic formulas. Real numbers are approximated by the set \( \mathbb{F} \times \mathbb{F} \). When a real number \( r \in \mathbb{R} \) is also a floating-point number, then it is represented by \( (r, r) \), otherwise it is represented by \( (\lfloor r \rfloor, \lceil r \rceil) \) such that \( \lfloor r \rfloor &lt; r &lt; \lceil r \rceil \) and there is no floating-point number \( f \) such that \( \lfloor r \rfloor &lt; f &lt; \lceil r \rceil \). </p>

</div>
</div>
<a id="a09cb772dc141687e1737e8fe9253f525" name="a09cb772dc141687e1737e8fe9253f525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cb772dc141687e1737e8fe9253f525">&#9670;&#160;</a></span>logic_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a09cb772dc141687e1737e8fe9253f525">lala::logic_set</a> = battery::vector&lt;battery::tuple&lt;F, F&gt;, typename F::allocator_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set is parametric in a universe of discourse. For instance, <code>logic_set&lt;F&gt;</code>, with F representing an integer constant, is a set of integers. Sets are defined in extension: we explicitly list the values belonging to the set. To avoid using too much memory with large sets, we use an interval representation, e.g., \( \{1..3, 5..5, 10..12\} = \{1, 2, 3, 5, 10, 11, 12\} \). When sets occur in intervals, they are ordered by set inclusion, e.g., \( \{\{1..2\}..\{1..4\}\} = \{\{1,2\}, \{1,2,3\}, \{1,2,4\}, \{1,2,3,4\}\} \). </p>

</div>
</div>
<a id="ac9e489a62c936a5c92f7d1ed13088717" name="ac9e489a62c936a5c92f7d1ed13088717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e489a62c936a5c92f7d1ed13088717">&#9670;&#160;</a></span>ZLB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac9e489a62c936a5c92f7d1ed13088717">lala::ZLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_l_b.html">PreZLB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of integer lower bounds. </p>

</div>
</div>
<a id="a199dd4298f467da23afbe2fbe92b1ff7" name="a199dd4298f467da23afbe2fbe92b1ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199dd4298f467da23afbe2fbe92b1ff7">&#9670;&#160;</a></span>ZUB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a199dd4298f467da23afbe2fbe92b1ff7">lala::ZUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of integer upper bounds. </p>

</div>
</div>
<a id="a693819038d669f682ca60792efe22763" name="a693819038d669f682ca60792efe22763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693819038d669f682ca60792efe22763">&#9670;&#160;</a></span>FLB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a693819038d669f682ca60792efe22763">lala::FLB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_l_b.html">PreFLB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of floating-point lower bounds. </p>

</div>
</div>
<a id="a36c2876708f5cf8bca435dfff880be67" name="a36c2876708f5cf8bca435dfff880be67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c2876708f5cf8bca435dfff880be67">&#9670;&#160;</a></span>FUB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a36c2876708f5cf8bca435dfff880be67">lala::FUB</a> = <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of floating-point upper bounds. </p>

</div>
</div>
<a id="a06af1aa721c62bd9380856db637bf03b" name="a06af1aa721c62bd9380856db637bf03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06af1aa721c62bd9380856db637bf03b">&#9670;&#160;</a></span>ZFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a06af1aa721c62bd9380856db637bf03b">lala::ZFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_z_u_b.html">PreZUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat integers. </p>

</div>
</div>
<a id="a95404a0273e5868af886c6683b2d3e20" name="a95404a0273e5868af886c6683b2d3e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95404a0273e5868af886c6683b2d3e20">&#9670;&#160;</a></span>FFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a95404a0273e5868af886c6683b2d3e20">lala::FFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_f_u_b.html">PreFUB</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat floating-point numbers. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60ed" name="ac24a8d85a4dfb9ed5e5ffcd09a4c60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">&#9670;&#160;</a></span>IKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">lala::IKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The kind of interpretation operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60eda9fb730caf1b2d638a1dcf747f0d4207d" name="ac24a8d85a4dfb9ed5e5ffcd09a4c60eda9fb730caf1b2d638a1dcf747f0d4207d"></a>ASK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac24a8d85a4dfb9ed5e5ffcd09a4c60edaca29caf9aab7f5eb7b91a531650cb517" name="ac24a8d85a4dfb9ed5e5ffcd09a4c60edaca29caf9aab7f5eb7b91a531650cb517"></a>TELL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4be41540c5051a480d0611a3e216b659" name="a4be41540c5051a480d0611a3e216b659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be41540c5051a480d0611a3e216b659">&#9670;&#160;</a></span>Sig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a4be41540c5051a480d0611a3e216b659">lala::Sig</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A first-order signature is a triple \( (X, F, P) \) where \( X \) is the set of variables, \( F \) the set of function symbols and \( P \) the set of predicates. We represent \( X \) by strings (see <code>LVar</code>), while \( F \) and \( P \) are described in the following enumeration <code>Sig</code>. For programming conveniency, we suppose that logical connectors are included in the set of predicates and thus are in the signature as well. Finally, function symbols and predicates are at the "same level". Hence a predicate can occur as the argument of a function, which is convenient when modelling, consider for example a cardinality constraint: \( ((x &gt; 4) + (y &lt; 4) + (z = 3)) \neq 2 \).</p>
<p>Symbols are sometimes overloaded across different universe of discourse. For instance, <code>ADD</code> can be used over integers, reals and even set of integers (pairwise addition).</p>
<p>Division and modulus are defined as usual over continuous domains such as rational and real numbers. However, it gets more tricky when defined over discrete domains such as integers and floating-point numbers, since there is not a single definition of division and modulus. The various kinds of discrete divisions are explained in (Leijend D. (2003). Division and Modulus for Computer Scientists), and we add four of those definitions to the logical signature. There are several use-cases of modulus and division: If you write a constraint model, you probably want to use euclidean division and modulus (EDIV, EMOD) as this is the most "mathematical" definition. If you intend to model the semantics of a programming language, you should use the same kind of division as the one present in your programming language (most likely truncated division). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82" name="a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82"></a>NEG&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e" name="a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e"></a>ABS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02" name="a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02"></a>ADD&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c" name="a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c"></a>SUB&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982" name="a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982"></a>MUL&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc" name="a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc"></a>POW&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd" name="a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd"></a>MIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0" name="a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0"></a>MAX&#160;</td><td class="fielddoc"><p>Binary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539" name="a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539"></a>SQRT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e" name="a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e"></a>EXP&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c" name="a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c"></a>LN&#160;</td><td class="fielddoc"><p>Square root, natural exponential and natural logarithm function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91" name="a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91"></a>NROOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6" name="a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6"></a>LOG&#160;</td><td class="fielddoc"><p>nth root and logarithm to base (both binary function symbols). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8" name="a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8"></a>SIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976" name="a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976"></a>COS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951" name="a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951"></a>TAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869" name="a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869"></a>ASIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d" name="a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d"></a>ACOS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29" name="a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29"></a>ATAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049" name="a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049"></a>SINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d" name="a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d"></a>COSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a" name="a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a"></a>TANH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb" name="a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb"></a>ASINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd" name="a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd"></a>ACOSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e" name="a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e"></a>ATANH&#160;</td><td class="fielddoc"><p>Trigonometric unary function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0" name="a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0"></a>DIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845" name="a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845"></a>MOD&#160;</td><td class="fielddoc"><p>Division and modulus over continuous domains (e.g., floating-point numbers and rational). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af" name="a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af"></a>TDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858" name="a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858"></a>TMOD&#160;</td><td class="fielddoc"><p>Truncated division, present in most programming languages, is defined as \( a\,\mathbf{tdiv}\,b = \mathit{trunc}(a/b) \), i.e., it rounds towards zero. Modulus is defined as \( a\,\mathbf{tmod}\,b = a - b * (a\,\mathbf{tdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503" name="a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503"></a>FDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f" name="a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f"></a>FMOD&#160;</td><td class="fielddoc"><p>Floor division (Knuth D. (1972). The Art of Computer Programming, Vol 1, Fundamental Algorithms), is defined as \( a\,\mathbf{fdiv}\,b = \lfloor a/b \rfloor \), i.e., it rounds towards negative infinity. Modulus is defined as \( a\,\mathbf{fmod}\,b = a - b * (a\,\mathbf{fdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188" name="a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188"></a>CDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187" name="a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187"></a>CMOD&#160;</td><td class="fielddoc"><p>Ceil division is defined as \( a\,\mathbf{cdiv}\,b = \lceil a/b \rceil \). Modulus is defined as \( a\,\mathbf{cmod}\,b = a - b * (a\,\mathbf{cdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f" name="a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f"></a>EDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8" name="a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8"></a>EMOD&#160;</td><td class="fielddoc"><p>Euclidean division (Boute T. R. (1992). The Euclidean definition of the functions div and mod). The properties satisfy by this division are: (1) \( a\,\mathbf{ediv}\,b \in \mathbb{Z} \), (2) \( a = b * (a\,\mathbf{ediv}\,b) + (a\,\mathbf{emod}\,b) \) and (3) \( 0 \leq a\,\mathbf{emod}\,b &lt; |b|\). Further, note that Euclidean division satisfies \( a\,\mathbf{ediv}\,(-b) = -(a\,\mathbf{ediv}\,b) \) and \( a\,\mathbf{emod}\,(-b) = a\,\mathbf{emod}\,b \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1" name="a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1"></a>UNION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac" name="a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac"></a>INTERSECTION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2" name="a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2"></a>DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149" name="a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149"></a>SYMMETRIC_DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480" name="a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480"></a>COMPLEMENT&#160;</td><td class="fielddoc"><p>Set functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed" name="a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed"></a>SUBSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134" name="a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134"></a>SUBSETEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50" name="a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50"></a>SUPSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc" name="a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc"></a>SUPSETEQ&#160;</td><td class="fielddoc"><p>Set inclusion predicates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4" name="a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4"></a>IN&#160;</td><td class="fielddoc"><p>Set membership predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2" name="a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2"></a>CARD&#160;</td><td class="fielddoc"><p>Cardinality function from set to integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a" name="a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a"></a>HULL&#160;</td><td class="fielddoc"><p>Unary function performing the convex hull of a set, e.g., \( \mathit{hull}(s) = \{x \;|\; \mathit{min}(s) \leq x \leq \mathit{max}(s) \} \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed" name="a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed"></a>CONVEX&#160;</td><td class="fielddoc"><p>Unary predicate, requiring \( s = \mathit{hull}(s) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134" name="a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134"></a>EQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6" name="a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6"></a>NEQ&#160;</td><td class="fielddoc"><p>Equality relations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066" name="a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066"></a>LEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad" name="a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad"></a>GEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69" name="a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69"></a>LT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651" name="a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651"></a>GT&#160;</td><td class="fielddoc"><p>Arithmetic comparison predicates. When applied to set, it corresponds to the lexicographic ordering of the sorted set according the underlying natural ordering of the elements in the set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e" name="a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e"></a>AND&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9" name="a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9"></a>OR&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd" name="a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd"></a>IMPLY&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b" name="a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b"></a>EQUIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e" name="a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e"></a>NOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041" name="a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041"></a>XOR&#160;</td><td class="fielddoc"><p>Logical connector. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5" name="a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5"></a>ITE&#160;</td><td class="fielddoc"><p>If-then-else. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856" name="a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856"></a>MAXIMIZE&#160;</td><td class="fielddoc"><p>Unary "meta-predicate" indicating that its argument must be maximized, according to the increasing ordering of the underlying universe of discourse. This is not a predicate because it is defined on the solutions space of the whole formulas. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6" name="a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6"></a>MINIMIZE&#160;</td><td class="fielddoc"><p>Same as MAXIMIZE, but for minimization. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af9857d1d4caeb321edd3979c9bf2f7b6" name="af9857d1d4caeb321edd3979c9bf2f7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9857d1d4caeb321edd3979c9bf2f7b6">&#9670;&#160;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t i, class... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp; lala::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax. </p>

</div>
</div>
<a id="afa0855e38d7627dab30836c30481a6dc" name="afa0855e38d7627dab30836c30481a6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0855e38d7627dab30836c30481a6dc">&#9670;&#160;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t i, class... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp; lala::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc9e58992ea85758270743d0bd62c90" name="a3fc9e58992ea85758270743d0bd62c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc9e58992ea85758270743d0bd62c90">&#9670;&#160;</a></span>fjoin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr auto lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcup (b_1, \ldots, b_n) = (a_1 \sqcup_1 b_1, \ldots, a_n \sqcup_n b_n) \) </p>

</div>
</div>
<a id="ab42297b1d8d6ad4374d6550421761df5" name="ab42297b1d8d6ad4374d6550421761df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42297b1d8d6ad4374d6550421761df5">&#9670;&#160;</a></span>fmeet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr auto lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcap (b_1, \ldots, b_n) = (a_1 \sqcap_1 b_1, \ldots, a_n \sqcap_n b_n) \) </p>

</div>
</div>
<a id="aa909139c7fbbea78476539a48bb989e9" name="aa909139c7fbbea78476539a48bb989e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909139c7fbbea78476539a48bb989e9">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4632875e493f8e8dce9f43d1d2d0387" name="ab4632875e493f8e8dce9f43d1d2d0387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4632875e493f8e8dce9f43d1d2d0387">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44314d29734db79278128b688836bcb5" name="a44314d29734db79278128b688836bcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44314d29734db79278128b688836bcb5">&#9670;&#160;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04d25524e24ca7311659d66cb013d1c3" name="a04d25524e24ca7311659d66cb013d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d25524e24ca7311659d66cb013d1c3">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class... As&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a860555919eb11a23caf88c6326961127" name="a860555919eb11a23caf88c6326961127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860555919eb11a23caf88c6326961127">&#9670;&#160;</a></span>ginterpret_true()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , <a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_true </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpret <code>true</code> in the lattice <code>L</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>L</code> preserves the top element w.r.t. the concrete domain or if <code>true</code> is interpreted by under-approximation (kind == ASK). </dd></dl>

</div>
</div>
<a id="ad43c2ef9e5728a6e1c89b7ce5ffefdce" name="ad43c2ef9e5728a6e1c89b7ce5ffefdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c2ef9e5728a6e1c89b7ce5ffefdce">&#9670;&#160;</a></span>ginterpret_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class A , class F , class Env , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;</td>          <td class="paramname"><span class="paramname"><em>intermediate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides an extended and unified interface to ask and tell interpretation of formula in abstract domains. It provides default interpretation for common formulas such as <code>true</code>, <code>false</code> and conjunction of formulas whenever <code>A</code> satisfies some lattice-theoretic conditions. </p>

</div>
</div>
<a id="a65c4c21442cb5e55dec7f733b5409254" name="a65c4c21442cb5e55dec7f733b5409254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c4c21442cb5e55dec7f733b5409254">&#9670;&#160;</a></span>ginterpret_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F , class Env , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides an extended and unified interface to ask and tell interpretation of formula in abstract universes. It provides default interpretation for common formulas such as <code>true</code>, <code>false</code>, conjunction and disjunction of formulas whenever <code>U</code> satisfies some lattice-theoretic conditions. </p>

</div>
</div>
<a id="a5410dc3f527e6cd2a110c6966b3de8b4" name="a5410dc3f527e6cd2a110c6966b3de8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5410dc3f527e6cd2a110c6966b3de8b4">&#9670;&#160;</a></span>top_level_ginterpret_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class A , class F , class Env , class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::top_level_ginterpret_in </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;</td>          <td class="paramname"><span class="paramname"><em>intermediate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Top-level version of <code>ginterpret_in</code>, we restore <code>env</code> and <code>intermediate</code> in case of failure. </p>

</div>
</div>
<a id="a431f4e6f8e78e5e31c42de55d4d3f65e" name="a431f4e6f8e78e5e31c42de55d4d3f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431f4e6f8e78e5e31c42de55d4d3f65e">&#9670;&#160;</a></span>make_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Alloc  = battery::standard_allocator, class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA A lala::make_top </td>
          <td>(</td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2b931b522b200e25aaf0b5574700db9" name="ab2b931b522b200e25aaf0b5574700db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b931b522b200e25aaf0b5574700db9">&#9670;&#160;</a></span>interpret_and_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool diagnose = false, class TellAlloc  = battery::standard_allocator, class F , class Env , class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::interpret_and_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TellAlloc</td>          <td class="paramname"><span class="paramname"><em>tell_alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TellAlloc{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6334729ccf128a1381a39f7f1c8a17f" name="aa6334729ccf128a1381a39f7f1c8a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6334729ccf128a1381a39f7f1c8a17f">&#9670;&#160;</a></span>create_and_interpret_and_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , bool diagnose = false, class F , class Env , class TellAlloc  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA std::optional&lt; A &gt; lala::create_and_interpret_and_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename A::allocator_type</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">typename&#160;A::allocator_type{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TellAlloc</td>          <td class="paramname"><span class="paramname"><em>tell_alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TellAlloc{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2d15ad8d7e0974c7b2bb1a88c3f3277" name="ac2d15ad8d7e0974c7b2bb1a88c3f3277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d15ad8d7e0974c7b2bb1a88c3f3277">&#9670;&#160;</a></span>meet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr auto lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac485671cf0aa58bb6ade85356ff8ddcb" name="ac485671cf0aa58bb6ade85356ff8ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac485671cf0aa58bb6ade85356ff8ddcb">&#9670;&#160;</a></span>fjoin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr auto lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d16f226d295bee37e4c44482fa8c732" name="a4d16f226d295bee37e4c44482fa8c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d16f226d295bee37e4c44482fa8c732">&#9670;&#160;</a></span>fmeet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr auto lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d436ce98ff7d08515c9b113594c006b" name="a3d436ce98ff7d08515c9b113594c006b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d436ce98ff7d08515c9b113594c006b">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9882b578e2f8b02730f31620b51cd026" name="a9882b578e2f8b02730f31620b51cd026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9882b578e2f8b02730f31620b51cd026">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c95a394c05fd2c3e46d72ec1fcc934b" name="a6c95a394c05fd2c3e46d72ec1fcc934b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c95a394c05fd2c3e46d72ec1fcc934b">&#9670;&#160;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e0b0c30b7a7b1cf51a7239b8bb2674d" name="a8e0b0c30b7a7b1cf51a7239b8bb2674d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0b0c30b7a7b1cf51a7239b8bb2674d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>itv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a095313c4ac1c353450411ecd930b24c9" name="a095313c4ac1c353450411ecd930b24c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095313c4ac1c353450411ecd930b24c9">&#9670;&#160;</a></span>is_v_op_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable &lt;sig&gt; constant</code>. </dd></dl>

</div>
</div>
<a id="a8264bf97bc739bc4ef3de14b159d4d6c" name="a8264bf97bc739bc4ef3de14b159d4d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8264bf97bc739bc4ef3de14b159d4d6c">&#9670;&#160;</a></span>is_v_op_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_z </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable op integer constant</code>, e.g., <code>x &lt; 4</code>. </dd></dl>

</div>
</div>
<a id="a704b489e2f66fc4666a9d9d5dd07f0a5" name="a704b489e2f66fc4666a9d9d5dd07f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704b489e2f66fc4666a9d9d5dd07f0a5">&#9670;&#160;</a></span>is_var_equality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_var_equality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable = variable</code> or <code>variable &lt;=&gt; variable</code>. </dd></dl>

</div>
</div>
<a id="a73e72bb3380853c8c65ff15a601e3d18" name="a73e72bb3380853c8c65ff15a601e3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e72bb3380853c8c65ff15a601e3d18">&#9670;&#160;</a></span>make_v_op_z() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8a2c3adc0efc7b60c27edd38dcad08ce">LVar</a>&lt; Allocator &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">logic_int</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>aty</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c98e8affc35bd856ed8c317c57beb93" name="a1c98e8affc35bd856ed8c317c57beb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c98e8affc35bd856ed8c317c57beb93">&#9670;&#160;</a></span>make_v_op_z() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6b5e8c539e0b34bc5a59e90593ede563">logic_int</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>aty</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44fa0949aa0050534b4e5888182cf27" name="ac44fa0949aa0050534b4e5888182cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44fa0949aa0050534b4e5888182cf27">&#9670;&#160;</a></span>geq_of_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::geq_of_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99742669495aa20254d238796f3225f9" name="a99742669495aa20254d238796f3225f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99742669495aa20254d238796f3225f9">&#9670;&#160;</a></span>leq_of_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::leq_of_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad61da309e0f805e38d1b86a1d9bf4b70" name="ad61da309e0f805e38d1b86a1d9bf4b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61da309e0f805e38d1b86a1d9bf4b70">&#9670;&#160;</a></span>var_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first variable occurring in the formula, or any other subformula if the formula does not contain a variable. It returns either a logical variable, an abstract variable or a quantifier. </dd></dl>

</div>
</div>
<a id="ac68fae34e298f9dc08e81209a98dea89" name="ac68fae34e298f9dc08e81209a98dea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68fae34e298f9dc08e81209a98dea89">&#9670;&#160;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI int lala::num_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in the formula <code>F</code> including existential quantifier, logical variables and abstract variables. Each occurrence of a variable is added up (duplicates are counted). </dd></dl>

</div>
</div>
<a id="a7ea742778e40b41e47d53e2f205b7f33" name="a7ea742778e40b41e47d53e2f205b7f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea742778e40b41e47d53e2f205b7f33">&#9670;&#160;</a></span>num_quantified_vars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA int lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of existential quantifiers. </dd></dl>

</div>
</div>
<a id="a595c82a412e489c8ca65997a3ce2a199" name="a595c82a412e489c8ca65997a3ce2a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c82a412e489c8ca65997a3ce2a199">&#9670;&#160;</a></span>num_quantified_vars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA int lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>aty</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in an existential quantifier that have type <code>aty</code>. </dd></dl>

</div>
</div>
<a id="a93ff80f41d2a60ce49d9d969792f3818" name="a93ff80f41d2a60ce49d9d969792f3818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff80f41d2a60ce49d9d969792f3818">&#9670;&#160;</a></span>type_of_conjunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a> lala::type_of_conjunction </td>
          <td>(</td>
          <td class="paramtype">const typename F::Sequence &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a814b7acfb675818f3775fe2ca64c5059" name="a814b7acfb675818f3775fe2ca64c5059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814b7acfb675818f3775fe2ca64c5059">&#9670;&#160;</a></span>extract_ty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI battery::tuple&lt; F, F &gt; lala::extract_ty </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>ty</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a conjunctive formula <code>f</code> of the form \( c_1 \land ... \land c_n \), it returns a pair \( \langle c_i \land .. \land c_j, c_k \land ... \land c_l \rangle \) such that the first component contains all formulas with the type <code>ty</code>, and the second component, all other formulas. </p>

</div>
</div>
<a id="a61c82f922a369376733ac1ceb63f2ecc" name="a61c82f922a369376733ac1ceb63f2ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c82f922a369376733ac1ceb63f2ecc">&#9670;&#160;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt; F &gt; lala::negate </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2caa21841419c6fd7f24ec5e8e615b26" name="a2caa21841419c6fd7f24ec5e8e615b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caa21841419c6fd7f24ec5e8e615b26">&#9670;&#160;</a></span>de_morgan_law()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt; F &gt; lala::de_morgan_law </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig_neg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>not(f1 \/ ... \/ fn) --&gt; not(f1) /\ ... /\ not(fn) not(f1 /\ ... /\ fn) --&gt; not(f1) \/ ... \/ not(fn) </p>

</div>
</div>
<a id="a058f21dcd4bdfdb672fdf29d9be8bdc2" name="a058f21dcd4bdfdb672fdf29d9be8bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f21dcd4bdfdb672fdf29d9be8bdc2">&#9670;&#160;</a></span>negate_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt; F &gt; lala::negate_eq </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad13b1cbdaf671ada055fcddffa64786e" name="ad13b1cbdaf671ada055fcddffa64786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13b1cbdaf671ada055fcddffa64786e">&#9670;&#160;</a></span>negate_arithmetic_comparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::negate_arithmetic_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46b8c9e53b51af981665045ab0ef5789" name="a46b8c9e53b51af981665045ab0ef5789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b8c9e53b51af981665045ab0ef5789">&#9670;&#160;</a></span>is_arithmetic_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_arithmetic_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators &lt;=, &lt;, &gt;, &gt;=, =, != </p>

</div>
</div>
<a id="af5ec9df0db7364e9a1d4a6cf55133bc0" name="af5ec9df0db7364e9a1d4a6cf55133bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ec9df0db7364e9a1d4a6cf55133bc0">&#9670;&#160;</a></span>is_set_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_set_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators =, !=, subset, subseteq, supset, supseteq </p>

</div>
</div>
<a id="aa96505876a4dc4a73e9dcac1df80ba16" name="aa96505876a4dc4a73e9dcac1df80ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96505876a4dc4a73e9dcac1df80ba16">&#9670;&#160;</a></span>is_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators &lt;=, &lt;, &gt;, &gt;=, =, !=, subset, subseteq, supset, supseteq </p>

</div>
</div>
<a id="a37723381538b58c397b57008bcc7671b" name="a37723381538b58c397b57008bcc7671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37723381538b58c397b57008bcc7671b">&#9670;&#160;</a></span>converse_comparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::converse_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the converse of a comparison operator (see <code>is_comparison</code>). </p>

</div>
</div>
<a id="a1c3a823ec9c5e512892e628d8311c543" name="a1c3a823ec9c5e512892e628d8311c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3a823ec9c5e512892e628d8311c543">&#9670;&#160;</a></span>map_avar_to_lvar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI void lala::map_avar_to_lvar </td>
          <td>(</td>
          <td class="paramtype">F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>erase_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code>, we transform all occurrences of <code><a class="el" href="classlala_1_1_a_var.html">AVar</a></code> into logical variables. </p>

</div>
</div>
<a id="ae6506d073b2c1165fa92bffeae6fd4bf" name="ae6506d073b2c1165fa92bffeae6fd4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6506d073b2c1165fa92bffeae6fd4bf">&#9670;&#160;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI F lala::eval </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad8550569c2adf06a8d8ce470bd2e3e9" name="aad8550569c2adf06a8d8ce470bd2e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8550569c2adf06a8d8ce470bd2e3e9">&#9670;&#160;</a></span>string_of_sig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI const char * lala::string_of_sig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9decc16cdfba74c367b1edf7110e595f" name="a9decc16cdfba74c367b1edf7110e595f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9decc16cdfba74c367b1edf7110e595f">&#9670;&#160;</a></span>is_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI constexpr bool lala::is_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39552615f718c4f45eece484b13baa8" name="ab39552615f718c4f45eece484b13baa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39552615f718c4f45eece484b13baa8">&#9670;&#160;</a></span>is_division()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI constexpr bool lala::is_division </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf455317064ad356964a272138df9b5" name="adcf455317064ad356964a272138df9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf455317064ad356964a272138df9b5">&#9670;&#160;</a></span>is_modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI constexpr bool lala::is_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad1145d2bc437a38928e69fc17af113" name="a4ad1145d2bc437a38928e69fc17af113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad1145d2bc437a38928e69fc17af113">&#9670;&#160;</a></span>is_associative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI constexpr bool lala::is_associative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa035eb336900b61d13e7f0dbc517d334" name="aa035eb336900b61d13e7f0dbc517d334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035eb336900b61d13e7f0dbc517d334">&#9670;&#160;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33084787dfef943a2b5174bb4ccf177f" name="a33084787dfef943a2b5174bb4ccf177f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33084787dfef943a2b5174bb4ccf177f">&#9670;&#160;</a></span>var_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI std::optional&lt; std::reference_wrapper&lt; const typename Env::variable_type &gt; &gt; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code> and an environment, return the first variable occurring in <code>f</code> or <code>{}</code> if <code>f</code> has no variable in <code>env</code>. </p>

</div>
</div>
<a id="a06f3e5ada938781bdb8c667a159242fe" name="a06f3e5ada938781bdb8c667a159242fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3e5ada938781bdb8c667a159242fe">&#9670;&#160;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc1 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a8490aa25a4cc0da52f96a42f15ad70" name="a4a8490aa25a4cc0da52f96a42f15ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8490aa25a4cc0da52f96a42f15ad70">&#9670;&#160;</a></span>project_fun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class R  = A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R lala::project_fun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf205cdf4c3b33d9ea65f971b991d889" name="aaf205cdf4c3b33d9ea65f971b991d889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf205cdf4c3b33d9ea65f971b991d889">&#9670;&#160;</a></span>project_fun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class R  = A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R lala::project_fun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4be41540c5051a480d0611a3e216b659">Sig</a></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a253331b314cef4226fc0b5f0436a9787" name="a253331b314cef4226fc0b5f0436a9787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253331b314cef4226fc0b5f0436a9787">&#9670;&#160;</a></span>dual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LDual , class L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr LDual lala::dual </td>
          <td>(</td>
          <td class="paramtype">const L &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is useful when we need to convert a value to its dual. The dual is the upset of the current element, therefore, if we have \( x &lt;= 10 \), the dual is given by the formula \( x &gt;= 10 \) interpreted in the dual lattice. In that case, it just changes the type of the lattice without changing the value. A difference occurs on the bottom and top element. Indeed, by our representation of bot and top, the bottom value in a lattice L equals the top value in its dual, but we need them to remain the same, so the dual of <code>L::bot()</code> is <code>LDual::bot()</code>. </p>

</div>
</div>
<a id="ab5d9e032cb1c165afd1a2bd792418185" name="ab5d9e032cb1c165afd1a2bd792418185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d9e032cb1c165afd1a2bd792418185">&#9670;&#160;</a></span>fjoin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2199dc533c06a5054adee13df82c87b4" name="a2199dc533c06a5054adee13df82c87b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2199dc533c06a5054adee13df82c87b4">&#9670;&#160;</a></span>fmeet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, battery::local_memory &gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10012e10c6cd87d477ac7b58d8692d9c" name="a10012e10c6cd87d477ac7b58d8692d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10012e10c6cd87d477ac7b58d8692d9c">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4f658a251c3c92953952792d8e2a2bd" name="af4f658a251c3c92953952792d8e2a2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f658a251c3c92953952792d8e2a2bd">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c526553b97b12fe3c7b5c3226312a55" name="a9c526553b97b12fe3c7b5c3226312a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c526553b97b12fe3c7b5c3226312a55">&#9670;&#160;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab003dd4355deb5c5e211ec63ff452a85" name="ab003dd4355deb5c5e211ec63ff452a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab003dd4355deb5c5e211ec63ff452a85">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_arith_bound.html">ArithBound</a>&lt; Pre, M &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2899339e9e500ce3f6b623dce27b948" name="ab2899339e9e500ce3f6b623dce27b948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2899339e9e500ce3f6b623dce27b948">&#9670;&#160;</a></span>fjoin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb16a970f3b7d3d498c54badfba504a9" name="aeb16a970f3b7d3d498c54badfba504a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb16a970f3b7d3d498c54badfba504a9">&#9670;&#160;</a></span>fmeet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6222341c0bc329fcd15df74413c07fb2" name="a6222341c0bc329fcd15df74413c07fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6222341c0bc329fcd15df74413c07fb2">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad555218b1f82ab12881100b30a3ec036" name="ad555218b1f82ab12881100b30a3ec036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad555218b1f82ab12881100b30a3ec036">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab37e7655b17f0850fda3656c62f962a4" name="ab37e7655b17f0850fda3656c62f962a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37e7655b17f0850fda3656c62f962a4">&#9670;&#160;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80c05037a0a816a678a831710d97a7c5" name="a80c05037a0a816a678a831710d97a7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c05037a0a816a678a831710d97a7c5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08574b94fd313aa150af3def34853156" name="a08574b94fd313aa150af3def34853156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08574b94fd313aa150af3def34853156">&#9670;&#160;</a></span>fjoin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt; lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72b20f603ae44ad4108e4adf9229125a" name="a72b20f603ae44ad4108e4adf9229125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b20f603ae44ad4108e4adf9229125a">&#9670;&#160;</a></span>fmeet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, battery::local_memory, T &gt; lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1711a87beb817da46277646f641fe45f" name="a1711a87beb817da46277646f641fe45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1711a87beb817da46277646f641fe45f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10f9c5c46728f0aa2d051bb944b54d12" name="a10f9c5c46728f0aa2d051bb944b54d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f9c5c46728f0aa2d051bb944b54d12">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e53df1bee8511ee593c619415ad7918" name="a1e53df1bee8511ee593c619415ad7918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e53df1bee8511ee593c619415ad7918">&#9670;&#160;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M1 , class M2 , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M1, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M2, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a8e2806de947f10ee1aaa3e8b1fb4b" name="a92a8e2806de947f10ee1aaa3e8b1fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a8e2806de947f10ee1aaa3e8b1fb4b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, class M , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_n_bitset.html">NBitset</a>&lt; N, M, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0215c5410b2314e5aa2b4566c459f0aa" name="a0215c5410b2314e5aa2b4566c459f0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0215c5410b2314e5aa2b4566c459f0aa">&#9670;&#160;</a></span>fmeet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::fmeet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c34bdae41587c8c7dd9264fde5d2f4a" name="a8c34bdae41587c8c7dd9264fde5d2f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34bdae41587c8c7dd9264fde5d2f4a">&#9670;&#160;</a></span>fjoin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::fjoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d08be75dca11487b354fa4bdea0c87" name="a09d08be75dca11487b354fa4bdea0c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d08be75dca11487b354fa4bdea0c87">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a511f6fbe14852b39dd74918800f04441" name="a511f6fbe14852b39dd74918800f04441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511f6fbe14852b39dd74918800f04441">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af527b0d9cb84ef22cddd191486265146" name="af527b0d9cb84ef22cddd191486265146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af527b0d9cb84ef22cddd191486265146">&#9670;&#160;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed8876a463a08e4218bb4767c097ca0e" name="aed8876a463a08e4218bb4767c097ca0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8876a463a08e4218bb4767c097ca0e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vstore</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
