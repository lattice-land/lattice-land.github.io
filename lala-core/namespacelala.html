<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Land Core Library: lala Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Land Core Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacelala.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lala Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelala_1_1local"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala_1_1local.html">local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_deps.html">AbstractDeps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_gauss_seidel_iteration.html">GaussSeidelIteration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_t_formula.html">TFormula</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_variable.html">Variable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_var_env.html">VarEnv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_i_error.html">IError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_i_result.html">IResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_sort.html">Sort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_dec.html">PreSDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_s_inc.html">PreSInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_b_dec.html">PreBDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_b_inc.html">PreBInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_inc.html">PreFInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_f_dec.html">PreFDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_inc.html">PreZInc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_pre_z_dec.html">PreZDec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_non_atomic_extraction.html">NonAtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_atomic_extraction.html">AtomicExtraction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_v_store.html">VStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a609554da1e3f1cb56804fcca736e7d70"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a609554da1e3f1cb56804fcca736e7d70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a609554da1e3f1cb56804fcca736e7d70">abstract_ptr</a> = battery::shared_ptr&lt; A, typename A::allocator_type &gt;</td></tr>
<tr class="separator:a609554da1e3f1cb56804fcca736e7d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f389c51804929bfb3e6d682d77ff0"><td class="memTemplParams" colspan="2">template&lt;class Allocator &gt; </td></tr>
<tr class="memitem:acb9f389c51804929bfb3e6d682d77ff0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a> = battery::string&lt; Allocator &gt;</td></tr>
<tr class="separator:acb9f389c51804929bfb3e6d682d77ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c626918dd7c19ff046f5cebaabec18f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> = int</td></tr>
<tr class="separator:a6c626918dd7c19ff046f5cebaabec18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2397fa063de70fb2241dc9ea08c47800"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2397fa063de70fb2241dc9ea08c47800">logic_bool</a> = bool</td></tr>
<tr class="separator:a2397fa063de70fb2241dc9ea08c47800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d30ab753875ab1fc49e3b4f195719"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> = long long int</td></tr>
<tr class="separator:a303d30ab753875ab1fc49e3b4f195719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08adbd4b2483ca2b14db01ba8769ef93"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a08adbd4b2483ca2b14db01ba8769ef93">logic_real</a> = battery::tuple&lt; double, double &gt;</td></tr>
<tr class="separator:a08adbd4b2483ca2b14db01ba8769ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a2de27857c134650693ca016c9c057"><td class="memTemplParams" colspan="2">template&lt;class F , class Allocator &gt; </td></tr>
<tr class="memitem:aa6a2de27857c134650693ca016c9c057"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa6a2de27857c134650693ca016c9c057">logic_set</a> = battery::vector&lt; battery::tuple&lt; F, F &gt;, Allocator &gt;</td></tr>
<tr class="separator:aa6a2de27857c134650693ca016c9c057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d79402fae1ea02a3b1f4710aff94403"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a1d79402fae1ea02a3b1f4710aff94403"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1d79402fae1ea02a3b1f4710aff94403">ZFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; <a class="el" href="structlala_1_1_pre_z_inc.html">PreZInc</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a1d79402fae1ea02a3b1f4710aff94403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8858cfe58e899ed9f17a5409ef9555fd"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a8858cfe58e899ed9f17a5409ef9555fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8858cfe58e899ed9f17a5409ef9555fd">FFlat</a> = <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; <a class="el" href="structlala_1_1_pre_f_inc.html">PreFInc</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a8858cfe58e899ed9f17a5409ef9555fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965e34fcb49caa34f1a093530d734e65"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a965e34fcb49caa34f1a093530d734e65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a965e34fcb49caa34f1a093530d734e65">ZInc</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_z_inc.html">PreZInc</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a965e34fcb49caa34f1a093530d734e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f4adb447746f2f8b8382a6c7ab93ee"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:aa9f4adb447746f2f8b8382a6c7ab93ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa9f4adb447746f2f8b8382a6c7ab93ee">ZDec</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_z_dec.html">PreZDec</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:aa9f4adb447746f2f8b8382a6c7ab93ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8260afc56449d61aa371800ee28a307"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:ac8260afc56449d61aa371800ee28a307"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac8260afc56449d61aa371800ee28a307">FInc</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_f_inc.html">PreFInc</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:ac8260afc56449d61aa371800ee28a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42806611b8397606c408f85a77a1eb08"><td class="memTemplParams" colspan="2">template&lt;class VT , class Mem &gt; </td></tr>
<tr class="memitem:a42806611b8397606c408f85a77a1eb08"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a42806611b8397606c408f85a77a1eb08">FDec</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_f_dec.html">PreFDec</a>&lt; VT &gt;, Mem &gt;</td></tr>
<tr class="separator:a42806611b8397606c408f85a77a1eb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c6c9e83275d6897edbb527e58f8cdf"><td class="memTemplParams" colspan="2">template&lt;class Mem &gt; </td></tr>
<tr class="memitem:ab9c6c9e83275d6897edbb527e58f8cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ab9c6c9e83275d6897edbb527e58f8cdf">BInc</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_b_inc.html">PreBInc</a>, Mem &gt;</td></tr>
<tr class="separator:ab9c6c9e83275d6897edbb527e58f8cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4169f8a3afcf847048a0e7e7c264e63e"><td class="memTemplParams" colspan="2">template&lt;class Mem &gt; </td></tr>
<tr class="memitem:a4169f8a3afcf847048a0e7e7c264e63e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a4169f8a3afcf847048a0e7e7c264e63e">BDec</a> = <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; <a class="el" href="structlala_1_1_pre_b_dec.html">PreBDec</a>, Mem &gt;</td></tr>
<tr class="separator:a4169f8a3afcf847048a0e7e7c264e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4be41540c5051a480d0611a3e216b659"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> { <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82">NEG</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e">ABS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02">ADD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c">SUB</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982">MUL</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc">POW</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd">MIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0">MAX</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539">SQRT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e">EXP</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c">LN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91">NROOT</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6">LOG</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8">SIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976">COS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951">TAN</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869">ASIN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d">ACOS</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29">ATAN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049">SINH</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d">COSH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a">TANH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb">ASINH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd">ACOSH</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e">ATANH</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0">DIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845">MOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af">TDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858">TMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503">FDIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f">FMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188">CDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187">CMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f">EDIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8">EMOD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1">UNION</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac">INTERSECTION</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2">DIFFERENCE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149">SYMMETRIC_DIFFERENCE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480">COMPLEMENT</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed">SUBSET</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134">SUBSETEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50">SUPSET</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc">SUPSETEQ</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4">IN</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2">CARD</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a">HULL</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed">CONVEX</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134">EQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6">NEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066">LEQ</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad">GEQ</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69">LT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651">GT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e">AND</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9">OR</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd">IMPLY</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b">EQUIV</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e">NOT</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041">XOR</a>
, <br />
&#160;&#160;<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5">ITE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856">MAXIMIZE</a>
, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6">MINIMIZE</a>
<br />
 }</td></tr>
<tr class="separator:a4be41540c5051a480d0611a3e216b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27d5b0b23c11433345924cf591019cf8"><td class="memTemplParams" colspan="2">template&lt;size_t i, class... As&gt; </td></tr>
<tr class="memitem:a27d5b0b23c11433345924cf591019cf8"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt;::template type_of&lt; i &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a27d5b0b23c11433345924cf591019cf8">project</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;cp)</td></tr>
<tr class="memdesc:a27d5b0b23c11433345924cf591019cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax.  <a href="namespacelala.html#a27d5b0b23c11433345924cf591019cf8">More...</a><br /></td></tr>
<tr class="separator:a27d5b0b23c11433345924cf591019cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c3a3e1c850baa795fb4d8b9572b26"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a0d3c3a3e1c850baa795fb4d8b9572b26"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a0d3c3a3e1c850baa795fb4d8b9572b26">join</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a0d3c3a3e1c850baa795fb4d8b9572b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b06e6b8c7980ad89104ac051f4be2e"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a91b06e6b8c7980ad89104ac051f4be2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a91b06e6b8c7980ad89104ac051f4be2e">meet</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a91b06e6b8c7980ad89104ac051f4be2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8916c6ad403391101e59fa3292d0898"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:ae8916c6ad403391101e59fa3292d0898"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae8916c6ad403391101e59fa3292d0898">operator&lt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:ae8916c6ad403391101e59fa3292d0898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#afd6379ad7a7bb2e8e51d1c137c9260d9">operator&gt;</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:afd6379ad7a7bb2e8e51d1c137c9260d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memTemplParams" colspan="2">template&lt;class... As, class... Bs&gt; </td></tr>
<tr class="memitem:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2f9ed7b6bbb550e292c2131e7fded337">operator==</a> (const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;a, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;b)</td></tr>
<tr class="separator:a2f9ed7b6bbb550e292c2131e7fded337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memTemplParams" colspan="2">template&lt;class A , class... As&gt; </td></tr>
<tr class="memitem:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa495590c545ec6cdb20f4ae45b1649d5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;cp)</td></tr>
<tr class="separator:aa495590c545ec6cdb20f4ae45b1649d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b3311d4f0ae191fda5354efd5c221a"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a12b3311d4f0ae191fda5354efd5c221a"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a12b3311d4f0ae191fda5354efd5c221a">join</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a12b3311d4f0ae191fda5354efd5c221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ae2f765f696bd7fe6795c3cc88421"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a919ae2f765f696bd7fe6795c3cc88421"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a919ae2f765f696bd7fe6795c3cc88421">meet</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a919ae2f765f696bd7fe6795c3cc88421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae508a71503241549919b188c5d372194"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ae508a71503241549919b188c5d372194"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae508a71503241549919b188c5d372194">operator&lt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:ae508a71503241549919b188c5d372194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67cd603d201f2f6df30d4fe521fd427"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:ac67cd603d201f2f6df30d4fe521fd427"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac67cd603d201f2f6df30d4fe521fd427">operator&gt;</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:ac67cd603d201f2f6df30d4fe521fd427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f62a10e87e036d30d453ad4b3f59e"><td class="memTemplParams" colspan="2">template&lt;class L , class K &gt; </td></tr>
<tr class="memitem:a972f62a10e87e036d30d453ad4b3f59e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a972f62a10e87e036d30d453ad4b3f59e">operator==</a> (const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;a, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;b)</td></tr>
<tr class="separator:a972f62a10e87e036d30d453ad4b3f59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memTemplParams" colspan="2">template&lt;class L &gt; </td></tr>
<tr class="memitem:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7ff81ccef2fad201c1b2061fbaf3ad9f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;itv)</td></tr>
<tr class="separator:a7ff81ccef2fad201c1b2061fbaf3ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a095313c4ac1c353450411ecd930b24c9"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a095313c4ac1c353450411ecd930b24c9">is_v_op_constant</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a095313c4ac1c353450411ecd930b24c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplParams" colspan="2">template&lt;class Allocator , class ExtendedSig &gt; </td></tr>
<tr class="memitem:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a8264bf97bc739bc4ef3de14b159d4d6c">is_v_op_z</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a8264bf97bc739bc4ef3de14b159d4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a92bcc6c6ade58edab3b25b01c07ceaf3">make_v_op_z</a> (<a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a>&lt; Allocator &gt; v, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> z, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:a92bcc6c6ade58edab3b25b01c07ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#affdfb7f9d029a06bfb08f0fb9d561abc">make_v_op_z</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> v, <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig, <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a> z, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const Allocator &amp;allocator=Allocator())</td></tr>
<tr class="separator:affdfb7f9d029a06bfb08f0fb9d561abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049d2d782b268501633b424c0c61b68"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:a1049d2d782b268501633b424c0c61b68"><td class="memTemplItemLeft" align="right" valign="top">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1049d2d782b268501633b424c0c61b68">var_in</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;f)</td></tr>
<tr class="separator:a1049d2d782b268501633b424c0c61b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ac68fae34e298f9dc08e81209a98dea89"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ac68fae34e298f9dc08e81209a98dea89">num_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:ac68fae34e298f9dc08e81209a98dea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea742778e40b41e47d53e2f205b7f33"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a7ea742778e40b41e47d53e2f205b7f33"><td class="memTemplItemLeft" align="right" valign="top">CUDA int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7ea742778e40b41e47d53e2f205b7f33">num_quantified_vars</a> (const F &amp;f)</td></tr>
<tr class="separator:a7ea742778e40b41e47d53e2f205b7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595c82a412e489c8ca65997a3ce2a199"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a595c82a412e489c8ca65997a3ce2a199"><td class="memTemplItemLeft" align="right" valign="top">CUDA int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a595c82a412e489c8ca65997a3ce2a199">num_quantified_vars</a> (const F &amp;f, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> aty)</td></tr>
<tr class="separator:a595c82a412e489c8ca65997a3ce2a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a93ff80f41d2a60ce49d9d969792f3818"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a93ff80f41d2a60ce49d9d969792f3818">type_of_conjunction</a> (const typename F::Sequence &amp;seq)</td></tr>
<tr class="separator:a93ff80f41d2a60ce49d9d969792f3818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI battery::tuple&lt; F, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a2af6441863bd25ce8c40bc31a4e988d6">extract_ty</a> (const F &amp;f, <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> ty)</td></tr>
<tr class="separator:a2af6441863bd25ce8c40bc31a4e988d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba112137663498d2a8c6c4bf498bb983"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aba112137663498d2a8c6c4bf498bb983"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI thrust::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aba112137663498d2a8c6c4bf498bb983">negate</a> (const F &amp;f)</td></tr>
<tr class="separator:aba112137663498d2a8c6c4bf498bb983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d62a73211d1d67bdc0a36a4e8fc27"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a273d62a73211d1d67bdc0a36a4e8fc27"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI thrust::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a273d62a73211d1d67bdc0a36a4e8fc27">de_morgan_law</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig_neg, const F &amp;f)</td></tr>
<tr class="separator:a273d62a73211d1d67bdc0a36a4e8fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92411b9dc03686b1a991b66159b8dd2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:af92411b9dc03686b1a991b66159b8dd2"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI thrust::optional&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af92411b9dc03686b1a991b66159b8dd2">negate_eq</a> (const F &amp;f)</td></tr>
<tr class="separator:af92411b9dc03686b1a991b66159b8dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa96505876a4dc4a73e9dcac1df80ba16">is_comparison</a> (const F &amp;f)</td></tr>
<tr class="separator:aa96505876a4dc4a73e9dcac1df80ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37723381538b58c397b57008bcc7671b"><td class="memItemLeft" align="right" valign="top">CUDA NI <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a37723381538b58c397b57008bcc7671b">converse_comparison</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a37723381538b58c397b57008bcc7671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fbc50bc2d3462ef777a93bab8d31cd"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a16fbc50bc2d3462ef777a93bab8d31cd"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a16fbc50bc2d3462ef777a93bab8d31cd">move_constants_on_rhs</a> (const F &amp;f)</td></tr>
<tr class="separator:a16fbc50bc2d3462ef777a93bab8d31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdbaf3bdbe60e23bff508ebf0f51cbc"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a7cdbaf3bdbe60e23bff508ebf0f51cbc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a7cdbaf3bdbe60e23bff508ebf0f51cbc">map_avar_to_lvar</a> (F &amp;f, const Env &amp;env)</td></tr>
<tr class="separator:a7cdbaf3bdbe60e23bff508ebf0f51cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e4cd05f6c827108d47c98443be639e"><td class="memItemLeft" align="right" valign="top">CUDA NI const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a23e4cd05f6c827108d47c98443be639e">string_of_sig</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a23e4cd05f6c827108d47c98443be639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b298de3e0cbb50bbc02bc606b7c56a"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#af2b298de3e0cbb50bbc02bc606b7c56a">is_prefix</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:af2b298de3e0cbb50bbc02bc606b7c56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf05545f06bb4e74db05c3c520cb31e8"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#abf05545f06bb4e74db05c3c520cb31e8">is_division</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:abf05545f06bb4e74db05c3c520cb31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff9ae908dd0eed685d87631506b3eb"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a97ff9ae908dd0eed685d87631506b3eb">is_modulo</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a97ff9ae908dd0eed685d87631506b3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b055c3c2499841f43012304df8c0686"><td class="memItemLeft" align="right" valign="top">CUDA constexpr NI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6b055c3c2499841f43012304df8c0686">is_associative</a> (<a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> sig)</td></tr>
<tr class="separator:a6b055c3c2499841f43012304df8c0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename ExtendedSig &gt; </td></tr>
<tr class="memitem:aa035eb336900b61d13e7f0dbc517d334"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aa035eb336900b61d13e7f0dbc517d334">operator==</a> (const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;lhs, const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;rhs)</td></tr>
<tr class="separator:aa035eb336900b61d13e7f0dbc517d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde117a37572277eb8bb7fae0fc3be0f"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:acde117a37572277eb8bb7fae0fc3be0f"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI thrust::optional&lt; const typename Env::variable_type &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#acde117a37572277eb8bb7fae0fc3be0f">var_in</a> (const F &amp;f, const Env &amp;env)</td></tr>
<tr class="separator:acde117a37572277eb8bb7fae0fc3be0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplParams" colspan="2">template&lt;class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a06f3e5ada938781bdb8c667a159242fe"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a06f3e5ada938781bdb8c667a159242fe">operator==</a> (const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;lhs, const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a06f3e5ada938781bdb8c667a159242fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaf07a75c4bb1887f47ea6fd8644528"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:aeaaf07a75c4bb1887f47ea6fd8644528"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#aeaaf07a75c4bb1887f47ea6fd8644528">join</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:aeaaf07a75c4bb1887f47ea6fd8644528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a80856147922f957700c8741b47d548"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a6a80856147922f957700c8741b47d548"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6a80856147922f957700c8741b47d548">meet</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a6a80856147922f957700c8741b47d548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1760bbb14c23377e4be9f1ddedffb5f6">operator&lt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a1760bbb14c23377e4be9f1ddedffb5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1047b3d6574fcae4465468ba6e419ba3"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a1047b3d6574fcae4465468ba6e419ba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1047b3d6574fcae4465468ba6e419ba3">operator&gt;</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a1047b3d6574fcae4465468ba6e419ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c07b747cf648832084c3fa1f89aa7"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a751c07b747cf648832084c3fa1f89aa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a751c07b747cf648832084c3fa1f89aa7">operator==</a> (const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a751c07b747cf648832084c3fa1f89aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547ed695047c53bc105eea3fe6ec28e5"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:a547ed695047c53bc105eea3fe6ec28e5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a547ed695047c53bc105eea3fe6ec28e5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;a)</td></tr>
<tr class="separator:a547ed695047c53bc105eea3fe6ec28e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8d0e97153fb6b0e1899f604a5e57dd"><td class="memTemplParams" colspan="2">template&lt;class LDual , class L &gt; </td></tr>
<tr class="memitem:a1a8d0e97153fb6b0e1899f604a5e57dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA LDual&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1a8d0e97153fb6b0e1899f604a5e57dd">dual</a> (const L &amp;x)</td></tr>
<tr class="separator:a1a8d0e97153fb6b0e1899f604a5e57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ebd6af8ce93b84643db65329ec8423"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:ae9ebd6af8ce93b84643db65329ec8423"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae9ebd6af8ce93b84643db65329ec8423">join</a> (const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:ae9ebd6af8ce93b84643db65329ec8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873e2db6e06521f181544b29cf87b9c2"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a873e2db6e06521f181544b29cf87b9c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, battery::local_memory &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a873e2db6e06521f181544b29cf87b9c2">meet</a> (const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a873e2db6e06521f181544b29cf87b9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f803b6d354330c83fbb64e336a8171"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a61f803b6d354330c83fbb64e336a8171"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a61f803b6d354330c83fbb64e336a8171">operator&lt;</a> (const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a61f803b6d354330c83fbb64e336a8171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6def29b7599b8e74a1b0ca1284ee5"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a14d6def29b7599b8e74a1b0ca1284ee5"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a14d6def29b7599b8e74a1b0ca1284ee5">operator&gt;</a> (const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a14d6def29b7599b8e74a1b0ca1284ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcb254c36b4f882ee7ec43e0618a3c7"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M1 , class M2 &gt; </td></tr>
<tr class="memitem:a6fcb254c36b4f882ee7ec43e0618a3c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a6fcb254c36b4f882ee7ec43e0618a3c7">operator==</a> (const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;a, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;b)</td></tr>
<tr class="separator:a6fcb254c36b4f882ee7ec43e0618a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28f9aa6dddc4538c78cb2dfe60fb7c9"><td class="memTemplParams" colspan="2">template&lt;class Pre , class M &gt; </td></tr>
<tr class="memitem:ae28f9aa6dddc4538c78cb2dfe60fb7c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#ae28f9aa6dddc4538c78cb2dfe60fb7c9">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M &gt; &amp;upset)</td></tr>
<tr class="separator:ae28f9aa6dddc4538c78cb2dfe60fb7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3db32c37974ff1b5936224bab4605a"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a1f3db32c37974ff1b5936224bab4605a"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a1f3db32c37974ff1b5936224bab4605a">join</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a1f3db32c37974ff1b5936224bab4605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a11211d831f8d14aee046342c41315"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc &gt; </td></tr>
<tr class="memitem:a80a11211d831f8d14aee046342c41315"><td class="memTemplItemLeft" align="right" valign="top">CUDA auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a80a11211d831f8d14aee046342c41315">meet</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;b)</td></tr>
<tr class="separator:a80a11211d831f8d14aee046342c41315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a09d08be75dca11487b354fa4bdea0c87"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a09d08be75dca11487b354fa4bdea0c87">operator&lt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a09d08be75dca11487b354fa4bdea0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a511f6fbe14852b39dd74918800f04441"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a511f6fbe14852b39dd74918800f04441">operator&gt;</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:a511f6fbe14852b39dd74918800f04441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146"><td class="memTemplParams" colspan="2">template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:af527b0d9cb84ef22cddd191486265146"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#af527b0d9cb84ef22cddd191486265146">operator==</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;a, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;b)</td></tr>
<tr class="separator:af527b0d9cb84ef22cddd191486265146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memTemplParams" colspan="2">template&lt;class L , class Alloc &gt; </td></tr>
<tr class="memitem:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelala.html#a9009ac0a37e31306fe8bd5fd738eb469">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;vstore)</td></tr>
<tr class="separator:a9009ac0a37e31306fe8bd5fd738eb469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pre-abstract universe is a lattice (with usual operations join, order, ...) equipped with a simple logical interpretation function and a next/prev functions. We consider totally ordered pre-abstract universes with an upset semantics. For any lattice \( L \), we consider an element \( a \in L \) to represent all the concrete elements equal to or above it. This set is called the upset of \( a \) and is denoted \( \mathord{\uparrow}{a} \). The concretization function \( \gamma \) formalizes this idea: \( \gamma(a) = \{x \mapsto b \;|\; b \in \mathord{\uparrow}{a} \cap U \} \) where \( U \) is the universe of discourse. The intersection with \( U \) is necessary to remove potential elements in the abstract universe that are not in the concrete universe of discourse (e.g., \( -\infty, \infty \) below).</p>
<p>The upset semantics associates each element of a lattice to its concrete upset. It is possible to decide that each element is associated to the concrete downset instead. Doing so will reverse our usage of the lattice-theoretic operations (join instead of meet, &lt;= instead of &gt;=, etc.). Instead of considering the upset semantics, it is more convenient to consider the downset semantics of the dual lattice.</p>
<p>Example: The lattice of increasing integer \( \mathit{ZInc} = \langle \{-\infty, \ldots, -2, -1, 0, 1, 2, \ldots, \infty\}, \leq \rangle \) is ordered by the natural arithmetic comparison operator. Using the upset semantics, we can represent simple constraints such as \( x \geq 3 \), in which case the upset \( \mathord{\uparrow}{3} = \{3, 4, \ldots\} \) represents all the values of \( x \) satisfying the constraints \( x \geq 3 \), that is, the solutions of the constraints. By taking the downset semantics of \( \mathit{ZInc} \), we can represent constraints such as \( x \leq 3 \). Alternatively, we can take the dual lattice of decreasing integers \( \mathit{ZDec} = \langle \{\infty, \ldots, 2, 1, 0, -1, -2, \ldots, -\infty\}, \geq \rangle \). The upset semantics of \( \mathit{ZDec} \) corresponds to the downset semantics of \( \mathit{ZInc} \).</p>
<p>From a pre-abstract universe, we obtain an abstract universe using the <code>Universe</code> class below. We also define various aliases to abstract universes such as <code>ZInc</code>, <code>ZDec</code>, etc. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a609554da1e3f1cb56804fcca736e7d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609554da1e3f1cb56804fcca736e7d70">&#9670;&nbsp;</a></span>abstract_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a609554da1e3f1cb56804fcca736e7d70">lala::abstract_ptr</a> = typedef battery::shared_ptr&lt;A, typename A::allocator_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb9f389c51804929bfb3e6d682d77ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9f389c51804929bfb3e6d682d77ff0">&#9670;&nbsp;</a></span>LVar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">lala::LVar</a> = typedef battery::string&lt;Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "logical variable" is just the name of the variable. </p>

</div>
</div>
<a id="a6c626918dd7c19ff046f5cebaabec18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c626918dd7c19ff046f5cebaabec18f">&#9670;&nbsp;</a></span>AType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">lala::AType</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each abstract domain is uniquely identified by an UID. We call it an <em>abstract type</em>. Each formula (and recursively, its subformulas) is assigned to an abstract type indicating in what abstract domain this formula should be interpreted. </p>

</div>
</div>
<a id="a2397fa063de70fb2241dc9ea08c47800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2397fa063de70fb2241dc9ea08c47800">&#9670;&nbsp;</a></span>logic_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a2397fa063de70fb2241dc9ea08c47800">lala::logic_bool</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of Boolean used in logic formulas. </p>

</div>
</div>
<a id="a303d30ab753875ab1fc49e3b4f195719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d30ab753875ab1fc49e3b4f195719">&#9670;&nbsp;</a></span>logic_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">lala::logic_int</a> = typedef long long int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of integers used in logic formulas. Integers are represented by the set \( \{-\infty, \infty\} \cup Z (\text{ with} Z \subset \mathbb{Z}) \). The minimal and maximal values of <code>logic_int</code> represents \( -\infty \) and \( \infty \) respectively. </p>

</div>
</div>
<a id="a08adbd4b2483ca2b14db01ba8769ef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08adbd4b2483ca2b14db01ba8769ef93">&#9670;&nbsp;</a></span>logic_real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a08adbd4b2483ca2b14db01ba8769ef93">lala::logic_real</a> = typedef battery::tuple&lt;double, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of real numbers used in logic formulas. Real numbers are approximated by the set \( \mathbb{F} \times \mathbb{F} \). When a real number \( r \in \mathbb{R} \) is also a floating-point number, then it is represented by \( (r, r) \), otherwise it is represented by \( (\lfloor r \rfloor, \lceil r \rceil) \) such that \( \lfloor r \rfloor &lt; r &lt; \lceil r \rceil \) and there is no floating-point number \( f \) such that \( \lfloor r \rfloor &lt; f &lt; \lceil r \rceil \). </p>

</div>
</div>
<a id="aa6a2de27857c134650693ca016c9c057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a2de27857c134650693ca016c9c057">&#9670;&nbsp;</a></span>logic_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#aa6a2de27857c134650693ca016c9c057">lala::logic_set</a> = typedef battery::vector&lt;battery::tuple&lt;F, F&gt;, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set is parametric in a universe of discourse. For instance, <code>logic_set&lt;logic_int&gt;</code> is a set of integers. Sets are defined in extension: we explicitly list the values belonging to the set. To avoid using too much memory with large sets, we use an interval representation, e.g., \( \{1..3, 5..5, 10..12\} = \{1, 2, 3, 5, 10, 11, 12\} \). When sets occur in intervals, they are ordered by set inclusion, e.g., \( \{\{1..2\}..\{1..4\}\} = \{\{1,2\}, \{1,2,3\}, \{1,2,4\}, \{1,2,3,4\}\} \). </p>

</div>
</div>
<a id="a1d79402fae1ea02a3b1f4710aff94403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d79402fae1ea02a3b1f4710aff94403">&#9670;&nbsp;</a></span>ZFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a1d79402fae1ea02a3b1f4710aff94403">lala::ZFlat</a> = typedef <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_z_inc.html">PreZInc</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat integers. </p>

</div>
</div>
<a id="a8858cfe58e899ed9f17a5409ef9555fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8858cfe58e899ed9f17a5409ef9555fd">&#9670;&nbsp;</a></span>FFlat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a8858cfe58e899ed9f17a5409ef9555fd">lala::FFlat</a> = typedef <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;<a class="el" href="structlala_1_1_pre_f_inc.html">PreFInc</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of flat floating-point numbers. </p>

</div>
</div>
<a id="a965e34fcb49caa34f1a093530d734e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965e34fcb49caa34f1a093530d734e65">&#9670;&nbsp;</a></span>ZInc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a965e34fcb49caa34f1a093530d734e65">lala::ZInc</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_z_inc.html">PreZInc</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of increasing integers. Concretization function: \( \gamma(x) = \{_ \mapsto y \;|\; x \leq y\} \). </p>

</div>
</div>
<a id="aa9f4adb447746f2f8b8382a6c7ab93ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f4adb447746f2f8b8382a6c7ab93ee">&#9670;&nbsp;</a></span>ZDec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#aa9f4adb447746f2f8b8382a6c7ab93ee">lala::ZDec</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_z_dec.html">PreZDec</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of decreasing integers. Concretization function: \( \gamma(x) = \{_ \mapsto y \;|\; x \geq y\} \). </p>

</div>
</div>
<a id="ac8260afc56449d61aa371800ee28a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8260afc56449d61aa371800ee28a307">&#9670;&nbsp;</a></span>FInc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#ac8260afc56449d61aa371800ee28a307">lala::FInc</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_f_inc.html">PreFInc</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of increasing floating-point numbers. Concretization function: \( \gamma(x) = \{_ \mapsto y \;|\; y \in \mathbb{R}, x \leq y\} \). </p>

</div>
</div>
<a id="a42806611b8397606c408f85a77a1eb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42806611b8397606c408f85a77a1eb08">&#9670;&nbsp;</a></span>FDec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a42806611b8397606c408f85a77a1eb08">lala::FDec</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_f_dec.html">PreFDec</a>&lt;VT&gt;, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of decreasing floating-point numbers. Concretization function: \( \gamma(x) = \{_ \mapsto y \;|\; y \in \mathbb{R}, x \geq y\} \). </p>

</div>
</div>
<a id="ab9c6c9e83275d6897edbb527e58f8cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c6c9e83275d6897edbb527e58f8cdf">&#9670;&nbsp;</a></span>BInc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#ab9c6c9e83275d6897edbb527e58f8cdf">lala::BInc</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_b_inc.html">PreBInc</a>, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of increasing Boolean where \( \mathit{false} \leq \mathit{true} \). </p>

</div>
</div>
<a id="a4169f8a3afcf847048a0e7e7c264e63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4169f8a3afcf847048a0e7e7c264e63e">&#9670;&nbsp;</a></span>BDec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelala.html#a4169f8a3afcf847048a0e7e7c264e63e">lala::BDec</a> = typedef <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;<a class="el" href="structlala_1_1_pre_b_dec.html">PreBDec</a>, Mem&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lattice of decreasing Boolean where \( \mathit{true} \leq \mathit{false} \). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4be41540c5051a480d0611a3e216b659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be41540c5051a480d0611a3e216b659">&#9670;&nbsp;</a></span>Sig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">lala::Sig</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A first-order signature is a triple \( (X, F, P) \) where \( X \) is the set of variables, \( F \) the set of function symbols and \( P \) the set of predicates. We represent \( X \) by strings (see <code>LVar</code>), while \( F \) and \( P \) are described in the following enumeration <code>Sig</code>. For programming conveniency, we suppose that logical connectors are included in the set of predicates and thus are in the signature as well. Finally, function symbols and predicates are at the "same level". Hence a predicate can occur as the argument of a function, which is convenient when modelling, consider for example a cardinality constraint: \( ((x &gt; 4) + (y &lt; 4) + (z = 3)) \neq 2 \).</p>
<p>Symbols are sometimes overloaded across different universe of discourse. For instance, <code>ADD</code> can be used over integers, reals and even set of integers (pairwise addition).</p>
<p>Division and modulus are defined as usual over continuous domains such as rational and real numbers. However, it gets more tricky when defined over discrete domains such as integers and floating-point numbers, since there is not a single definition of division and modulus. The various kinds of discrete divisions are explained in (Leijend D. (2003). Division and Modulus for Computer Scientists), and we add four of those definitions to the logical signature. There are several use-cases of modulus and division: If you write a constraint model, you probably want to use euclidean division and modulus (EDIV, EMOD) as this is the most "mathematical" definition. If you intend to model the semantics of a programming language, you should use the same kind of division as the one present in your programming language (most likely truncated division). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afd5c2ae3d5e7293327344b6c3485fc82"></a>NEG&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659adc30e84e5ba6fbd73512392c6d37628e"></a>ABS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a645a9c49ebbe25417ae4f4c57447aa02"></a>ADD&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae0bb1bc3a0e410d6068f020c858d190c"></a>SUB&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af1fff2ec2753a69d89e5a48ddceb6982"></a>MUL&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a6e53c3a9eb723ce5327d4052e4e30fdc"></a>POW&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a862175bb85bef55b954e572e71f4ffcd"></a>MIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aab34a3b23024271c113e7e4b1514bbe0"></a>MAX&#160;</td><td class="fielddoc"><p>Binary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab0d2cd0405a593e0af63798db2aaf539"></a>SQRT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ac70a0550fd0e44ceddd0f886c0a28a0e"></a>EXP&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8d57491689c25bef2fe14921b9f1022c"></a>LN&#160;</td><td class="fielddoc"><p>Square root, natural exponential and natural logarithm function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a58076eb396317a32d0b3c96c36dcdc91"></a>NROOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af348f0154452264ff05f2e996b32b7e6"></a>LOG&#160;</td><td class="fielddoc"><p>nth root and logarithm to base (both binary function symbols). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a04c9cc8fb81f9b1e0acaf372933d74e8"></a>SIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a69575853d96b5f4e912ca77ec1092976"></a>COS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad0a0aa9bca52b9d2e9fad534f2eae951"></a>TAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2868beee4b709daea09000a21ccba869"></a>ASIN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a19024bcd76c587a161cef23cd281700d"></a>ACOS&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a274873a784b208aff9adf762e4cbac29"></a>ATAN&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8f35a2ff52b501a44594c71615f2c049"></a>SINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aef4b43c2b2d723e9b56830551674604d"></a>COSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a22a8a8d4854fa5fe79d0acb66c33866a"></a>TANH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae04def2d3f362953b4d7ecead1e5e2cb"></a>ASINH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a57a98fd738a535ae66fbcdbefa3656cd"></a>ACOSH&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a48faca6aa5c2b752b2556ea78440ca4e"></a>ATANH&#160;</td><td class="fielddoc"><p>Trigonometric unary function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9934922159223c8b46e0774c4fc92bc0"></a>DIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3a7de24e0b0ef7e829db0e2a0d7da845"></a>MOD&#160;</td><td class="fielddoc"><p>Division and modulus over continuous domains (e.g., floating-point numbers and rational). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab5eab66ba0c0ae03ec8a337f8b2165af"></a>TDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a273a7a8c97735d8bd809835e1d402858"></a>TMOD&#160;</td><td class="fielddoc"><p>Truncated division, present in most programming languages, is defined as \( a\,\mathbf{tdiv}\,b = \mathit{trunc}(a/b) \), i.e., it rounds towards zero. Modulus is defined as \( a\,\mathbf{tmod}\,b = a - b * (a\,\mathbf{tdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659abe3e0277999e826e63b167544d8fd503"></a>FDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9be7decc85369374244b2fe67dee128f"></a>FMOD&#160;</td><td class="fielddoc"><p>Floor division (Knuth D. (1972). The Art of Computer Programming, Vol 1, Fundamental Algorithms), is defined as \( a\,\mathbf{fdiv}\,b = \lfloor a/b \rfloor \), i.e., it rounds towards negative infinity. Modulus is defined as \( a\,\mathbf{fmod}\,b = a - b * (a\,\mathbf{fdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659afbc80b6e0525f77dc53ad46af8543188"></a>CDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659af24f16fa82b2a0567f56e5982ccbc187"></a>CMOD&#160;</td><td class="fielddoc"><p>Ceil division is defined as \( a\,\mathbf{cdiv}\,b = \lceil a/b \rceil \). Modulus is defined as \( a\,\mathbf{cmod}\,b = a - b * (a\,\mathbf{cdiv}\,b) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a93128b324bdcbcac40b472275b16237f"></a>EDIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659aff90c332132c623192b0855190110fc8"></a>EMOD&#160;</td><td class="fielddoc"><p>Euclidean division (Boute T. R. (1992). The Euclidean definition of the functions div and mod). The properties satisfy by this division are: (1) \( a\,\mathbf{ediv}\,b \in \mathbb{Z} \), (2) \( a = b * (a\,\mathbf{ediv}\,b) + (a\,\mathbf{emod}\,b) \) and (3) \( 0 \leq a\,\mathbf{emod}\,b &lt; |b|\). Further, note that Euclidean division satisfies \( a\,\mathbf{ediv}\,(-b) = -(a\,\mathbf{ediv}\,b) \) and \( a\,\mathbf{emod}\,(-b) = a\,\mathbf{emod}\,b \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a531c437ac16d6dc801a22e22a2e5b0c1"></a>UNION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a8c8be3ea00a0f2eda21562d170895bac"></a>INTERSECTION&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a3c6da3ab50bf2b967f5adc12f15609d2"></a>DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a093fca71395848fe7eaf57a728d97149"></a>SYMMETRIC_DIFFERENCE&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ace4bb6cc757a876bcae29d7afb344480"></a>COMPLEMENT&#160;</td><td class="fielddoc"><p>Set functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad2a9084cc8862e00b60730731ac161ed"></a>SUBSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1838d8d029825a2bf9a9b0aa2bf7134"></a>SUBSETEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ae333ce4445ff69a85f7bf907e64afe50"></a>SUPSET&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2e5eae06a8099bfdad32f68f24293ddc"></a>SUPSETEQ&#160;</td><td class="fielddoc"><p>Set inclusion predicates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a66ca795a675e7b0f114cc986a45323b4"></a>IN&#160;</td><td class="fielddoc"><p>Set membership predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a2a7768d4977057e87dd4743ae9954cf2"></a>CARD&#160;</td><td class="fielddoc"><p>Cardinality function from set to integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a02302aa01aa754187469769f88fc461a"></a>HULL&#160;</td><td class="fielddoc"><p>Unary function performing the convex hull of a set, e.g., \( \mathit{hull}(s) = \{x \;|\; \mathit{min}(s) \leq x \leq \mathit{max}(s) \} \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a4e760ac1eb2295e09efad6fa1954c2ed"></a>CONVEX&#160;</td><td class="fielddoc"><p>Unary predicate, requiring \( s = \mathit{hull}(s) \). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a540dd9fbbe27d8900c8cd221cdc50134"></a>EQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a09229291382be14131439437cd0709c6"></a>NEQ&#160;</td><td class="fielddoc"><p>Equality relations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a17a7bbf0e65530521932e221dc59c066"></a>LEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a641b631289f14a66696ebca79e717cad"></a>GEQ&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ab511bc3f2670b98e55fc89f91b427e69"></a>LT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a9a76ae871be40983573273fc3e619651"></a>GT&#160;</td><td class="fielddoc"><p>Arithmetic comparison predicates. When applied to set, it corresponds to the lexicographic ordering of the sorted set according the underlying natural ordering of the elements in the set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad1c7a8b98bec59dc3f6ac28209040e8e"></a>AND&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a5398910447fe7bf71bd3a3bb4ae539c9"></a>OR&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a1bbad9f2ee9d2a009ac601ea93770cdd"></a>IMPLY&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad60ed828472e93a9450a506013af502b"></a>EQUIV&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a18f2489be7b8b3ac8699bdf3508e1a6e"></a>NOT&#160;</td><td class="fielddoc"><p>Unary arithmetic function symbols. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a027b109c9077f7a388b91ef4df848041"></a>XOR&#160;</td><td class="fielddoc"><p>Logical connector. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659a051196d5892baae923f11b3feea1cfb5"></a>ITE&#160;</td><td class="fielddoc"><p>If-then-else. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad20094bfd86b4eb408d39956ec443856"></a>MAXIMIZE&#160;</td><td class="fielddoc"><p>Unary "meta-predicate" indicating that its argument must be maximized, according to the increasing ordering of the underlying universe of discourse. This is not a predicate because it is defined on the solutions space of the whole formulas. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4be41540c5051a480d0611a3e216b659ad31b4d2b16f0588a88f952ed29ddace6"></a>MINIMIZE&#160;</td><td class="fielddoc"><p>Same as MAXIMIZE, but for minimization. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27d5b0b23c11433345924cf591019cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d5b0b23c11433345924cf591019cf8">&#9670;&nbsp;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t i, class... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt;As...&gt;::template type_of&lt;i&gt;&amp; lala::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>cp.template project&lt;i&gt;()</code>, just to avoid the ".template" syntax. </p>

</div>
</div>
<a id="a0d3c3a3e1c850baa795fb4d8b9572b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3c3a3e1c850baa795fb4d8b9572b26">&#9670;&nbsp;</a></span>join() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcup (b_1, \ldots, b_n) = (a_1 \sqcup_1 b_1, \ldots, a_n \sqcup_n b_n) \) </p>

</div>
</div>
<a id="a91b06e6b8c7980ad89104ac051f4be2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b06e6b8c7980ad89104ac051f4be2e">&#9670;&nbsp;</a></span>meet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\( (a_1, \ldots, a_n) \sqcap (b_1, \ldots, b_n) = (a_1 \sqcap_1 b_1, \ldots, a_n \sqcap_n b_n) \) </p>

</div>
</div>
<a id="ae8916c6ad403391101e59fa3292d0898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8916c6ad403391101e59fa3292d0898">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd6379ad7a7bb2e8e51d1c137c9260d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6379ad7a7bb2e8e51d1c137c9260d9">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f9ed7b6bbb550e292c2131e7fded337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9ed7b6bbb550e292c2131e7fded337">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... As, class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; Bs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa495590c545ec6cdb20f4ae45b1649d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa495590c545ec6cdb20f4ae45b1649d5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class... As&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_cartesian_product.html">CartesianProduct</a>&lt; A, As... &gt; &amp;&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12b3311d4f0ae191fda5354efd5c221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b3311d4f0ae191fda5354efd5c221a">&#9670;&nbsp;</a></span>join() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a919ae2f765f696bd7fe6795c3cc88421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919ae2f765f696bd7fe6795c3cc88421">&#9670;&nbsp;</a></span>meet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA auto lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae508a71503241549919b188c5d372194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae508a71503241549919b188c5d372194">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac67cd603d201f2f6df30d4fe521fd427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67cd603d201f2f6df30d4fe521fd427">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a972f62a10e87e036d30d453ad4b3f59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972f62a10e87e036d30d453ad4b3f59e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ff81ccef2fad201c1b2061fbaf3ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff81ccef2fad201c1b2061fbaf3ad9f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_interval.html">Interval</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>itv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a095313c4ac1c353450411ecd930b24c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095313c4ac1c353450411ecd930b24c9">&#9670;&nbsp;</a></span>is_v_op_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable &lt;sig&gt; constant</code>. </dd></dl>

</div>
</div>
<a id="a8264bf97bc739bc4ef3de14b159d4d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8264bf97bc739bc4ef3de14b159d4d6c">&#9670;&nbsp;</a></span>is_v_op_z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator , class ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_v_op_z </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula <code>f</code> has the shape <code>variable op integer constant</code>, e.g., <code>x &lt; 4</code>. </dd></dl>

</div>
</div>
<a id="a92bcc6c6ade58edab3b25b01c07ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bcc6c6ade58edab3b25b01c07ceaf3">&#9670;&nbsp;</a></span>make_v_op_z() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator&gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#acb9f389c51804929bfb3e6d682d77ff0">LVar</a>&lt; Allocator &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em> = <code><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affdfb7f9d029a06bfb08f0fb9d561abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdfb7f9d029a06bfb08f0fb9d561abc">&#9670;&nbsp;</a></span>make_v_op_z() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator&gt; lala::make_v_op_z </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a303d30ab753875ab1fc49e3b4f195719">logic_int</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em> = <code><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1049d2d782b268501633b424c0c61b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049d2d782b268501633b424c0c61b68">&#9670;&nbsp;</a></span>var_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt;Allocator, ExtendedSig&gt;&amp; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first variable occurring in the formula, or any other subformula if the formula does not contain a variable. It returns either a logical variable, an abstract variable or a quantifier. </dd></dl>

</div>
</div>
<a id="ac68fae34e298f9dc08e81209a98dea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68fae34e298f9dc08e81209a98dea89">&#9670;&nbsp;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI int lala::num_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in the formula <code>F</code> including existential quantifier, logical variables and abstract variables. Each occurrence of a variable is added up (duplicates are counted). </dd></dl>

</div>
</div>
<a id="a7ea742778e40b41e47d53e2f205b7f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea742778e40b41e47d53e2f205b7f33">&#9670;&nbsp;</a></span>num_quantified_vars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA int lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of existential quantifiers. </dd></dl>

</div>
</div>
<a id="a595c82a412e489c8ca65997a3ce2a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c82a412e489c8ca65997a3ce2a199">&#9670;&nbsp;</a></span>num_quantified_vars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA int lala::num_quantified_vars </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>aty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of variables occurring in an existential quantifier that have type <code>aty</code>. </dd></dl>

</div>
</div>
<a id="a93ff80f41d2a60ce49d9d969792f3818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ff80f41d2a60ce49d9d969792f3818">&#9670;&nbsp;</a></span>type_of_conjunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a> lala::type_of_conjunction </td>
          <td>(</td>
          <td class="paramtype">const typename F::Sequence &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2af6441863bd25ce8c40bc31a4e988d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af6441863bd25ce8c40bc31a4e988d6">&#9670;&nbsp;</a></span>extract_ty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI battery::tuple&lt;F,F&gt; lala::extract_ty </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a6c626918dd7c19ff046f5cebaabec18f">AType</a>&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a conjunctive formula <code>f</code> of the form \( c_1 \land ... \land c_n \), it returns a pair \( \langle c_i \land .. \land c_j, c_k \land ... \land c_l \rangle \) such that the first component contains all formulas with the type <code>ty</code>, and the second component, all other formulas. </p>

</div>
</div>
<a id="aba112137663498d2a8c6c4bf498bb983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba112137663498d2a8c6c4bf498bb983">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI thrust::optional&lt; F &gt; lala::negate </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a273d62a73211d1d67bdc0a36a4e8fc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d62a73211d1d67bdc0a36a4e8fc27">&#9670;&nbsp;</a></span>de_morgan_law()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI thrust::optional&lt;F&gt; lala::de_morgan_law </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig_neg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>not(f1 \/ ... \/ fn) --&gt; not(f1) /\ ... /\ not(fn) not(f1 /\ ... /\ fn) --&gt; not(f1) \/ ... \/ not(fn) </p>

</div>
</div>
<a id="af92411b9dc03686b1a991b66159b8dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92411b9dc03686b1a991b66159b8dd2">&#9670;&nbsp;</a></span>negate_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI thrust::optional&lt;F&gt; lala::negate_eq </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa96505876a4dc4a73e9dcac1df80ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96505876a4dc4a73e9dcac1df80ba16">&#9670;&nbsp;</a></span>is_comparison()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::is_comparison </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True for the operators &lt;=, &lt;, &gt;, &gt;=, =, !=, subset, subseteq, supset, supseteq </p>

</div>
</div>
<a id="a37723381538b58c397b57008bcc7671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37723381538b58c397b57008bcc7671b">&#9670;&nbsp;</a></span>converse_comparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a> lala::converse_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the converse of a comparison operator (see <code>is_comparison</code>). </p>

</div>
</div>
<a id="a16fbc50bc2d3462ef777a93bab8d31cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fbc50bc2d3462ef777a93bab8d31cd">&#9670;&nbsp;</a></span>move_constants_on_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI F lala::move_constants_on_rhs </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a predicate of the form <code>t &lt;op&gt; u</code> (e.g., <code>x + y &lt;= z + 4</code>), it transforms it into an equivalent predicate of the form <code>s &lt;op&gt; k</code> where <code>k</code> is a constant (e.g., <code>x + y - (z + 4) &lt;= 0</code>). If the formula is not a predicate, it is returned unchanged. </p>

</div>
</div>
<a id="a7cdbaf3bdbe60e23bff508ebf0f51cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdbaf3bdbe60e23bff508ebf0f51cbc">&#9670;&nbsp;</a></span>map_avar_to_lvar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI void lala::map_avar_to_lvar </td>
          <td>(</td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code>, we transform all occurrences of <code><a class="el" href="classlala_1_1_a_var.html">AVar</a></code> into logical variables. </p>

</div>
</div>
<a id="a23e4cd05f6c827108d47c98443be639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e4cd05f6c827108d47c98443be639e">&#9670;&nbsp;</a></span>string_of_sig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI const char* lala::string_of_sig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2b298de3e0cbb50bbc02bc606b7c56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b298de3e0cbb50bbc02bc606b7c56a">&#9670;&nbsp;</a></span>is_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf05545f06bb4e74db05c3c520cb31e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf05545f06bb4e74db05c3c520cb31e8">&#9670;&nbsp;</a></span>is_division()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_division </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97ff9ae908dd0eed685d87631506b3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ff9ae908dd0eed685d87631506b3eb">&#9670;&nbsp;</a></span>is_modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b055c3c2499841f43012304df8c0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b055c3c2499841f43012304df8c0686">&#9670;&nbsp;</a></span>is_associative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA constexpr NI bool lala::is_associative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a4be41540c5051a480d0611a3e216b659">Sig</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa035eb336900b61d13e7f0dbc517d334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035eb336900b61d13e7f0dbc517d334">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename ExtendedSig &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator, ExtendedSig &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acde117a37572277eb8bb7fae0fc3be0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde117a37572277eb8bb7fae0fc3be0f">&#9670;&nbsp;</a></span>var_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI thrust::optional&lt;const typename Env::variable_type&amp;&gt; lala::var_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a formula <code>f</code> and an environment, return the first variable occurring in <code>f</code> or <code>{}</code> if <code>f</code> has no variable in <code>env</code>. </p>

</div>
</div>
<a id="a06f3e5ada938781bdb8c667a159242fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3e5ada938781bdb8c667a159242fe">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc1 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_sort.html">Sort</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaaf07a75c4bb1887f47ea6fd8644528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaf07a75c4bb1887f47ea6fd8644528">&#9670;&nbsp;</a></span>join() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;Pre, battery::local_memory&gt; lala::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a80856147922f957700c8741b47d548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a80856147922f957700c8741b47d548">&#9670;&nbsp;</a></span>meet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt;Pre, battery::local_memory&gt; lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1760bbb14c23377e4be9f1ddedffb5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1760bbb14c23377e4be9f1ddedffb5f6">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1047b3d6574fcae4465468ba6e419ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1047b3d6574fcae4465468ba6e419ba3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a751c07b747cf648832084c3fa1f89aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751c07b747cf648832084c3fa1f89aa7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a547ed695047c53bc105eea3fe6ec28e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547ed695047c53bc105eea3fe6ec28e5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_flat_universe.html">FlatUniverse</a>&lt; Pre, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a8d0e97153fb6b0e1899f604a5e57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8d0e97153fb6b0e1899f604a5e57dd">&#9670;&nbsp;</a></span>dual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LDual , class L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA LDual lala::dual </td>
          <td>(</td>
          <td class="paramtype">const L &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is useful when we need to convert a value to its dual. The dual is the downset of the current element, therefore, if we have \( x &gt;= 10 \), the dual is given by the formula \( x &lt;= 10 \) interpreted in the dual lattice. In that case, it just changes the type of the lattice without changing the value. A difference occurs on the bottom and top element. Indeed, by our representation of bot and top, the bottom value in a lattice L equals the top value in its dual, but we need them to remain the same, so the dual of <code>L::bot()</code> is <code>LDual::bot()</code>. </p>

</div>
</div>
<a id="ae9ebd6af8ce93b84643db65329ec8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebd6af8ce93b84643db65329ec8423">&#9670;&nbsp;</a></span>join() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;Pre, battery::local_memory&gt; lala::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a873e2db6e06521f181544b29cf87b9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873e2db6e06521f181544b29cf87b9c2">&#9670;&nbsp;</a></span>meet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt;Pre, battery::local_memory&gt; lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61f803b6d354330c83fbb64e336a8171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f803b6d354330c83fbb64e336a8171">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d6def29b7599b8e74a1b0ca1284ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d6def29b7599b8e74a1b0ca1284ee5">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fcb254c36b4f882ee7ec43e0618a3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcb254c36b4f882ee7ec43e0618a3c7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M1 , class M2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae28f9aa6dddc4538c78cb2dfe60fb7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28f9aa6dddc4538c78cb2dfe60fb7c9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pre , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_primitive_upset.html">PrimitiveUpset</a>&lt; Pre, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>upset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f3db32c37974ff1b5936224bab4605a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3db32c37974ff1b5936224bab4605a">&#9670;&nbsp;</a></span>join() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80a11211d831f8d14aee046342c41315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a11211d831f8d14aee046342c41315">&#9670;&nbsp;</a></span>meet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA auto lala::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d08be75dca11487b354fa4bdea0c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d08be75dca11487b354fa4bdea0c87">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a511f6fbe14852b39dd74918800f04441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511f6fbe14852b39dd74918800f04441">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af527b0d9cb84ef22cddd191486265146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af527b0d9cb84ef22cddd191486265146">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class K , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool lala::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; K, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9009ac0a37e31306fe8bd5fd738eb469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9009ac0a37e31306fe8bd5fd738eb469">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; lala::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; L, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vstore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
