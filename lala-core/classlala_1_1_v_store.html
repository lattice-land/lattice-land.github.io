<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Land Core Library: lala::VStore&lt; U, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lattice Land Core Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classlala_1_1_v_store.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlala_1_1_v_store-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lala::VStore&lt; U, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vstore_8hpp_source.html">vstore.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_v_store_1_1var__dom.html">var_dom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6aa6f686a32cf610325253ac2be3b51f" id="r_a6aa6f686a32cf610325253ac2be3b51f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> = U</td></tr>
<tr class="separator:a6aa6f686a32cf610325253ac2be3b51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ed6bcff683cb7d93f29f0e5d06e916" id="r_a78ed6bcff683cb7d93f29f0e5d06e916"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ed6bcff683cb7d93f29f0e5d06e916">local_universe</a> = typename universe_type::local_type</td></tr>
<tr class="separator:a78ed6bcff683cb7d93f29f0e5d06e916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1fdfa842f2712d8ee378621b8384c" id="r_afab1fdfa842f2712d8ee378621b8384c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> = Allocator</td></tr>
<tr class="separator:afab1fdfa842f2712d8ee378621b8384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f73b45df4ed4462b79d0d59c6c44ab2" id="r_a2f73b45df4ed4462b79d0d59c6c44ab2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> = <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt;<a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a>, <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>&gt;</td></tr>
<tr class="separator:a2f73b45df4ed4462b79d0d59c6c44ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02740d662b4d7a2806998f6a9d9d144f" id="r_a02740d662b4d7a2806998f6a9d9d144f"><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:a02740d662b4d7a2806998f6a9d9d144f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a> = battery::vector&lt;<a class="el" href="structlala_1_1_v_store_1_1var__dom.html">var_dom</a>&lt;Alloc&gt;, Alloc&gt;</td></tr>
<tr class="separator:a02740d662b4d7a2806998f6a9d9d144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387a5725d2a750c7829a88c1f7c53ea2" id="r_a387a5725d2a750c7829a88c1f7c53ea2"><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:a387a5725d2a750c7829a88c1f7c53ea2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a387a5725d2a750c7829a88c1f7c53ea2">ask_type</a> = <a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt;Alloc&gt;</td></tr>
<tr class="separator:a387a5725d2a750c7829a88c1f7c53ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614fae6892d84d8a93cbbf1e962be812" id="r_a614fae6892d84d8a93cbbf1e962be812"><td class="memTemplParams" colspan="2">template&lt;class Alloc  = allocator_type&gt; </td></tr>
<tr class="memitem:a614fae6892d84d8a93cbbf1e962be812"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a614fae6892d84d8a93cbbf1e962be812">snapshot_type</a> = battery::vector&lt;<a class="el" href="#a78ed6bcff683cb7d93f29f0e5d06e916">local_universe</a>, Alloc&gt;</td></tr>
<tr class="separator:a614fae6892d84d8a93cbbf1e962be812"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa638b858396b19454bcd9c0fc55bbf56" id="r_aa638b858396b19454bcd9c0fc55bbf56"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa638b858396b19454bcd9c0fc55bbf56">VStore</a> (const <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp;other)</td></tr>
<tr class="separator:aa638b858396b19454bcd9c0fc55bbf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6239f39c39f1a7dd67373da811349d" id="r_a2e6239f39c39f1a7dd67373da811349d"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6239f39c39f1a7dd67373da811349d">VStore</a> (<a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a> atype, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>())</td></tr>
<tr class="separator:a2e6239f39c39f1a7dd67373da811349d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868ab6c579bd4303c6d7c804b2e289d7" id="r_a868ab6c579bd4303c6d7c804b2e289d7"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a868ab6c579bd4303c6d7c804b2e289d7">VStore</a> (<a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a> atype, size_t size, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>())</td></tr>
<tr class="separator:a868ab6c579bd4303c6d7c804b2e289d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7f38d67b15dfa9c3cb16a320604fe" id="r_a6ef7f38d67b15dfa9c3cb16a320604fe"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a6ef7f38d67b15dfa9c3cb16a320604fe"><td class="memTemplItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ef7f38d67b15dfa9c3cb16a320604fe">VStore</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &gt; &amp;other)</td></tr>
<tr class="separator:a6ef7f38d67b15dfa9c3cb16a320604fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b573e6a89c965029f18f732c19b9e4" id="r_ae7b573e6a89c965029f18f732c19b9e4"><td class="memTemplParams" colspan="2">template&lt;class R , class Alloc2 &gt; </td></tr>
<tr class="memitem:ae7b573e6a89c965029f18f732c19b9e4"><td class="memTemplItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7b573e6a89c965029f18f732c19b9e4">VStore</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, Alloc2 &gt; &amp;other, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>())</td></tr>
<tr class="separator:ae7b573e6a89c965029f18f732c19b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31cf75b06e07652f51dd6778d6cb482" id="r_af31cf75b06e07652f51dd6778d6cb482"><td class="memTemplParams" colspan="2">template&lt;class R , class Alloc2 , class... Allocators&gt; </td></tr>
<tr class="memitem:af31cf75b06e07652f51dd6778d6cb482"><td class="memTemplItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af31cf75b06e07652f51dd6778d6cb482">VStore</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, Alloc2 &gt; &amp;other, const <a class="el" href="classlala_1_1_abstract_deps.html">AbstractDeps</a>&lt; Allocators... &gt; &amp;deps)</td></tr>
<tr class="separator:af31cf75b06e07652f51dd6778d6cb482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5491c7ee3a839a55b7579c02bdd141b" id="r_aa5491c7ee3a839a55b7579c02bdd141b"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5491c7ee3a839a55b7579c02bdd141b">VStore</a> (<a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp;&amp;other)</td></tr>
<tr class="separator:aa5491c7ee3a839a55b7579c02bdd141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457d82333e45ab37c2002006e0f201eb" id="r_a457d82333e45ab37c2002006e0f201eb"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457d82333e45ab37c2002006e0f201eb">get_allocator</a> () const</td></tr>
<tr class="separator:a457d82333e45ab37c2002006e0f201eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0cc0aa74e143054796a5c027ebd1ef" id="r_a2c0cc0aa74e143054796a5c027ebd1ef"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0cc0aa74e143054796a5c027ebd1ef">aty</a> () const</td></tr>
<tr class="separator:a2c0cc0aa74e143054796a5c027ebd1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeace8e8f76a313cf98e9fc8b4fad691d" id="r_aeace8e8f76a313cf98e9fc8b4fad691d"><td class="memItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeace8e8f76a313cf98e9fc8b4fad691d">vars</a> () const</td></tr>
<tr class="separator:aeace8e8f76a313cf98e9fc8b4fad691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685c90b32f5a8f12c89df0e91a0fda62" id="r_a685c90b32f5a8f12c89df0e91a0fda62"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a685c90b32f5a8f12c89df0e91a0fda62">is_bot</a> () const</td></tr>
<tr class="separator:a685c90b32f5a8f12c89df0e91a0fda62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096690d0928f5f736201f9207c67c287" id="r_a096690d0928f5f736201f9207c67c287"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096690d0928f5f736201f9207c67c287">is_top</a> () const</td></tr>
<tr class="separator:a096690d0928f5f736201f9207c67c287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7776949f7c413050f586445735b633e5" id="r_a7776949f7c413050f586445735b633e5"><td class="memTemplParams" colspan="2">template&lt;class Alloc  = allocator_type&gt; </td></tr>
<tr class="memitem:a7776949f7c413050f586445735b633e5"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="#a614fae6892d84d8a93cbbf1e962be812">snapshot_type</a>&lt; Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7776949f7c413050f586445735b633e5">snapshot</a> (const Alloc &amp;alloc=Alloc()) const</td></tr>
<tr class="separator:a7776949f7c413050f586445735b633e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87478b6148d299ab2504bbf2e616101e" id="r_a87478b6148d299ab2504bbf2e616101e"><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:a87478b6148d299ab2504bbf2e616101e"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87478b6148d299ab2504bbf2e616101e">restore</a> (const <a class="el" href="#a614fae6892d84d8a93cbbf1e962be812">snapshot_type</a>&lt; Alloc &gt; &amp;snap)</td></tr>
<tr class="separator:a87478b6148d299ab2504bbf2e616101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861e3e786bdfb130e9c8173ac4584cce" id="r_a861e3e786bdfb130e9c8173ac4584cce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F , class Env , class I &gt; </td></tr>
<tr class="memitem:a861e3e786bdfb130e9c8173ac4584cce"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a861e3e786bdfb130e9c8173ac4584cce">interpret</a> (const F &amp;f, Env &amp;env, I &amp;intermediate, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics) const</td></tr>
<tr class="separator:a861e3e786bdfb130e9c8173ac4584cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6cb43aa94cfddf3e74134c947e2c06" id="r_afe6cb43aa94cfddf3e74134c947e2c06"><td class="memTemplParams" colspan="2">template&lt;bool diagnose = false, class F , class Env , class Alloc2 &gt; </td></tr>
<tr class="memitem:afe6cb43aa94cfddf3e74134c947e2c06"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe6cb43aa94cfddf3e74134c947e2c06">interpret_tell</a> (const F &amp;f, Env &amp;env, <a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt; Alloc2 &gt; &amp;tell, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics) const</td></tr>
<tr class="separator:afe6cb43aa94cfddf3e74134c947e2c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e7e828f9eefd27aa7f229d04285a64" id="r_aa4e7e828f9eefd27aa7f229d04285a64"><td class="memTemplParams" colspan="2">template&lt;bool diagnose = false, class F , class Env , class Alloc2 &gt; </td></tr>
<tr class="memitem:aa4e7e828f9eefd27aa7f229d04285a64"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4e7e828f9eefd27aa7f229d04285a64">interpret_ask</a> (const F &amp;f, const Env &amp;env, <a class="el" href="#a387a5725d2a750c7829a88c1f7c53ea2">ask_type</a>&lt; Alloc2 &gt; &amp;<a class="el" href="#a4b2fe08bf99080f74568e977a5557610">ask</a>, <a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;diagnostics) const</td></tr>
<tr class="separator:aa4e7e828f9eefd27aa7f229d04285a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e39fdd5d9cef6942829d1fb025b3dec" id="r_a1e39fdd5d9cef6942829d1fb025b3dec"><td class="memTemplParams" colspan="2">template&lt;class Group , class Store &gt; </td></tr>
<tr class="memitem:a1e39fdd5d9cef6942829d1fb025b3dec"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e39fdd5d9cef6942829d1fb025b3dec">copy_to</a> (Group &amp;group, Store &amp;store) const</td></tr>
<tr class="separator:a1e39fdd5d9cef6942829d1fb025b3dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e2f2ac28a9e7bfa7fb4b31a67932b" id="r_ad07e2f2ac28a9e7bfa7fb4b31a67932b"><td class="memItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07e2f2ac28a9e7bfa7fb4b31a67932b">reset_data</a> (<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> alloc)</td></tr>
<tr class="separator:ad07e2f2ac28a9e7bfa7fb4b31a67932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efce47f74ce4ef6700c5c22856d005d" id="r_a4efce47f74ce4ef6700c5c22856d005d"><td class="memTemplParams" colspan="2">template&lt;class Univ &gt; </td></tr>
<tr class="memitem:a4efce47f74ce4ef6700c5c22856d005d"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4efce47f74ce4ef6700c5c22856d005d">project</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> x, Univ &amp;u) const</td></tr>
<tr class="separator:a4efce47f74ce4ef6700c5c22856d005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f6b4a071db30091eb714d6a2397f5" id="r_a245f6b4a071db30091eb714d6a2397f5"><td class="memItemLeft" align="right" valign="top">CUDA const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245f6b4a071db30091eb714d6a2397f5">project</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> x) const</td></tr>
<tr class="separator:a245f6b4a071db30091eb714d6a2397f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3d33d8385cad76c5b40ea08361f9cb" id="r_a8f3d33d8385cad76c5b40ea08361f9cb"><td class="memItemLeft" align="right" valign="top">CUDA const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f3d33d8385cad76c5b40ea08361f9cb">operator[]</a> (int x) const</td></tr>
<tr class="separator:a8f3d33d8385cad76c5b40ea08361f9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ceff91c486f410beba9fdc92ecf5c" id="r_aa16ceff91c486f410beba9fdc92ecf5c"><td class="memItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16ceff91c486f410beba9fdc92ecf5c">meet_bot</a> ()</td></tr>
<tr class="separator:aa16ceff91c486f410beba9fdc92ecf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c63a2061fb3a599a19cf0e96b53e4" id="r_a851c63a2061fb3a599a19cf0e96b53e4"><td class="memItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a851c63a2061fb3a599a19cf0e96b53e4">embed</a> (int x, const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;dom)</td></tr>
<tr class="separator:a851c63a2061fb3a599a19cf0e96b53e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c67508bb36c069269a82375196456da" id="r_a5c67508bb36c069269a82375196456da"><td class="memItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c67508bb36c069269a82375196456da">embed</a> (<a class="el" href="classlala_1_1_a_var.html">AVar</a> x, const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;dom)</td></tr>
<tr class="separator:a5c67508bb36c069269a82375196456da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05990b94d6b467a49f2f8765a5945ebe" id="r_a05990b94d6b467a49f2f8765a5945ebe"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a05990b94d6b467a49f2f8765a5945ebe"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05990b94d6b467a49f2f8765a5945ebe">deduce</a> (const <a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt; Alloc2 &gt; &amp;t)</td></tr>
<tr class="separator:a05990b94d6b467a49f2f8765a5945ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142273351fbef43eab9bbe68c8b51f0c" id="r_a142273351fbef43eab9bbe68c8b51f0c"><td class="memTemplParams" colspan="2">template&lt;class U2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a142273351fbef43eab9bbe68c8b51f0c"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a142273351fbef43eab9bbe68c8b51f0c">meet</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;other)</td></tr>
<tr class="separator:a142273351fbef43eab9bbe68c8b51f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c01587b9ba7aee943c254672adb3390" id="r_a5c01587b9ba7aee943c254672adb3390"><td class="memItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c01587b9ba7aee943c254672adb3390">join_top</a> ()</td></tr>
<tr class="separator:a5c01587b9ba7aee943c254672adb3390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbaf0555e781809d123f3761070a657" id="r_a0fbaf0555e781809d123f3761070a657"><td class="memTemplParams" colspan="2">template&lt;class U2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a0fbaf0555e781809d123f3761070a657"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fbaf0555e781809d123f3761070a657">join</a> (const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;other)</td></tr>
<tr class="separator:a0fbaf0555e781809d123f3761070a657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2fe08bf99080f74568e977a5557610" id="r_a4b2fe08bf99080f74568e977a5557610"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a4b2fe08bf99080f74568e977a5557610"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b2fe08bf99080f74568e977a5557610">ask</a> (const <a class="el" href="#a387a5725d2a750c7829a88c1f7c53ea2">ask_type</a>&lt; Alloc2 &gt; &amp;t) const</td></tr>
<tr class="separator:a4b2fe08bf99080f74568e977a5557610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5590087224ca302d2e67a854c5eb2c4" id="r_ad5590087224ca302d2e67a854c5eb2c4"><td class="memItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5590087224ca302d2e67a854c5eb2c4">num_deductions</a> () const</td></tr>
<tr class="separator:ad5590087224ca302d2e67a854c5eb2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d773ddf77438addd206ae4c59c5828" id="r_ac1d773ddf77438addd206ae4c59c5828"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1d773ddf77438addd206ae4c59c5828">deduce</a> (size_t) const</td></tr>
<tr class="separator:ac1d773ddf77438addd206ae4c59c5828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca95a73f4f1a9eb96d60be6882106d1" id="r_a3ca95a73f4f1a9eb96d60be6882106d1"><td class="memTemplParams" colspan="2">template&lt;class ExtractionStrategy  = NonAtomicExtraction&gt; </td></tr>
<tr class="memitem:a3ca95a73f4f1a9eb96d60be6882106d1"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ca95a73f4f1a9eb96d60be6882106d1">is_extractable</a> (const ExtractionStrategy &amp;strategy=ExtractionStrategy()) const</td></tr>
<tr class="separator:a3ca95a73f4f1a9eb96d60be6882106d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5593fc2cca2c7bd7c55321807121767" id="r_ae5593fc2cca2c7bd7c55321807121767"><td class="memTemplParams" colspan="2">template&lt;class U2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:ae5593fc2cca2c7bd7c55321807121767"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5593fc2cca2c7bd7c55321807121767">extract</a> (<a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;ua) const</td></tr>
<tr class="separator:ae5593fc2cca2c7bd7c55321807121767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c04d6386245ce915acaab9c7c15da" id="r_ae40c04d6386245ce915acaab9c7c15da"><td class="memTemplParams" colspan="2">template&lt;class Env , class Allocator2  = typename Env::allocator_type&gt; </td></tr>
<tr class="memitem:ae40c04d6386245ce915acaab9c7c15da"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae40c04d6386245ce915acaab9c7c15da">deinterpret</a> (const Env &amp;env, const Allocator2 &amp;allocator=Allocator2()) const</td></tr>
<tr class="separator:ae40c04d6386245ce915acaab9c7c15da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4815630fd9457eb6186119aab5d04b05" id="r_a4815630fd9457eb6186119aab5d04b05"><td class="memTemplParams" colspan="2">template&lt;class I , class Env , class Allocator2  = typename Env::allocator_type&gt; </td></tr>
<tr class="memitem:a4815630fd9457eb6186119aab5d04b05"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4815630fd9457eb6186119aab5d04b05">deinterpret</a> (const I &amp;intermediate, const Env &amp;env, const Allocator2 &amp;allocator=Allocator2()) const</td></tr>
<tr class="separator:a4815630fd9457eb6186119aab5d04b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341c1611707b468fc65ec4a6d3e8206" id="r_a4341c1611707b468fc65ec4a6d3e8206"><td class="memItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4341c1611707b468fc65ec4a6d3e8206">print</a> () const</td></tr>
<tr class="separator:a4341c1611707b468fc65ec4a6d3e8206"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0276be0cdf35873f0363596b846c78b8" id="r_a0276be0cdf35873f0363596b846c78b8"><td class="memItemLeft" align="right" valign="top">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0276be0cdf35873f0363596b846c78b8">top</a> (<a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a> atype=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{})</td></tr>
<tr class="separator:a0276be0cdf35873f0363596b846c78b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a77de93ae9d623dae73dc910eb6d74" id="r_a22a77de93ae9d623dae73dc910eb6d74"><td class="memItemLeft" align="right" valign="top">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22a77de93ae9d623dae73dc910eb6d74">bot</a> (<a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a> atype=<a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a>, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{})</td></tr>
<tr class="separator:a22a77de93ae9d623dae73dc910eb6d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec81b82a44c1812f5debc824c58b8c3" id="r_afec81b82a44c1812f5debc824c58b8c3"><td class="memTemplParams" colspan="2">template&lt;class Env &gt; </td></tr>
<tr class="memitem:afec81b82a44c1812f5debc824c58b8c3"><td class="memTemplItemLeft" align="right" valign="top">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afec81b82a44c1812f5debc824c58b8c3">bot</a> (Env &amp;env, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{})</td></tr>
<tr class="separator:afec81b82a44c1812f5debc824c58b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a0fe8a57a95d575e2c2c30f2297adc" id="r_a43a0fe8a57a95d575e2c2c30f2297adc"><td class="memTemplParams" colspan="2">template&lt;class Env &gt; </td></tr>
<tr class="memitem:a43a0fe8a57a95d575e2c2c30f2297adc"><td class="memTemplItemLeft" align="right" valign="top">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43a0fe8a57a95d575e2c2c30f2297adc">top</a> (Env &amp;env, const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;alloc=<a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{})</td></tr>
<tr class="separator:a43a0fe8a57a95d575e2c2c30f2297adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0510ecd324b57306b12d848225496ece" id="r_a0510ecd324b57306b12d848225496ece"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0510ecd324b57306b12d848225496ece">is_abstract_universe</a> = false</td></tr>
<tr class="separator:a0510ecd324b57306b12d848225496ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76f47ea103745383d7a3f8f446f7bf" id="r_a2e76f47ea103745383d7a3f8f446f7bf"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e76f47ea103745383d7a3f8f446f7bf">sequential</a> = universe_type::sequential</td></tr>
<tr class="separator:a2e76f47ea103745383d7a3f8f446f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae743529c60336a8ab2c8c0fb0eca493" id="r_aae743529c60336a8ab2c8c0fb0eca493"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae743529c60336a8ab2c8c0fb0eca493">is_totally_ordered</a> = false</td></tr>
<tr class="separator:aae743529c60336a8ab2c8c0fb0eca493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d106375554ff6a1c4848e764c5afe51" id="r_a0d106375554ff6a1c4848e764c5afe51"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d106375554ff6a1c4848e764c5afe51">preserve_bot</a> = true</td></tr>
<tr class="separator:a0d106375554ff6a1c4848e764c5afe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c851a0b13d967e3190f7de1b8c7d6" id="r_a072c851a0b13d967e3190f7de1b8c7d6"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a072c851a0b13d967e3190f7de1b8c7d6">preserve_top</a> = true</td></tr>
<tr class="separator:a072c851a0b13d967e3190f7de1b8c7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb96161027dc513e2eab6aa7183a3c" id="r_a6bdb96161027dc513e2eab6aa7183a3c"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bdb96161027dc513e2eab6aa7183a3c">preserve_join</a> = universe_type::preserve_join</td></tr>
<tr class="separator:a6bdb96161027dc513e2eab6aa7183a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add027ddd3e5d5a831fb4cb22742466f8" id="r_add027ddd3e5d5a831fb4cb22742466f8"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add027ddd3e5d5a831fb4cb22742466f8">preserve_meet</a> = universe_type::preserve_meet</td></tr>
<tr class="separator:add027ddd3e5d5a831fb4cb22742466f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdba4fd71e31dd7349bdfa363cba31c" id="r_a8fdba4fd71e31dd7349bdfa363cba31c"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fdba4fd71e31dd7349bdfa363cba31c">injective_concretization</a> = universe_type::injective_concretization</td></tr>
<tr class="separator:a8fdba4fd71e31dd7349bdfa363cba31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ede6c750cc77760db73f21e1de3db2" id="r_a95ede6c750cc77760db73f21e1de3db2"><td class="memItemLeft" align="right" valign="top">static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ede6c750cc77760db73f21e1de3db2">preserve_concrete_covers</a> = universe_type::preserve_concrete_covers</td></tr>
<tr class="separator:a95ede6c750cc77760db73f21e1de3db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bdda7d3d99121dee14dae139746c6e" id="r_a72bdda7d3d99121dee14dae139746c6e"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72bdda7d3d99121dee14dae139746c6e">name</a> = &quot;VStore&quot;</td></tr>
<tr class="separator:a72bdda7d3d99121dee14dae139746c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a79cea18e9c8234923d4efd31316c6da8" id="r_a79cea18e9c8234923d4efd31316c6da8"><td class="memTemplParams" colspan="2">template&lt;class U2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a79cea18e9c8234923d4efd31316c6da8"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79cea18e9c8234923d4efd31316c6da8">VStore</a></td></tr>
<tr class="separator:a79cea18e9c8234923d4efd31316c6da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class U, class Allocator&gt;<br />
class lala::VStore&lt; U, Allocator &gt;</div><p>The variable store abstract domain is a <em>domain transformer</em> built on top of an abstract universe <code>U</code>. Concretization function: \( \gamma(\rho) := \bigcap_{x \in \pi(\rho)} \gamma_{U_x}(\rho(x)) \). The bot element is smashed and the equality between two stores is represented by the following equivalence relation, for two stores \( S \) and \( T \): \( S \equiv T \Leftrightarrow \forall{x \in \mathit{Vars}},~S(x) = T(x) \lor \exists{x \in \mathit{dom}(S)},\exists{y \in \mathit{dom}(T)},~S(x) = \bot \land T(y) = \bot \). Intuitively, it means that either all elements are equal or both stores have a bot element, in which case they "collapse" to the bot element, and are considered equal.</p>
<p>The top element is the element \( \langle \top, \ldots \rangle \), that is an infinite number of variables initialized to top. In practice, we cannot represent infinite collections, so we represent top either as the empty collection or with a finite number of top elements. Any finite store \( \langle x_1, \ldots, x_n \rangle \) should be seen as the concrete store \( \langle x_1, \ldots, x_n, \top, \ldots \rangle \).</p>
<p>This semantics has implication when joining or merging two elements. For instance, \( \langle 1 \rangle.\mathit{meet}(\langle \bot, 4 \rangle) \) will be equal to bottom, in that case represented by \( \langle \bot \rangle \).</p>
<p>Template parameters:</p><ul>
<li><code>U</code> is the type of the abstract universe.</li>
<li><code>Allocator</code> is the allocator of the underlying array of universes. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6aa6f686a32cf610325253ac2be3b51f" name="a6aa6f686a32cf610325253ac2be3b51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa6f686a32cf610325253ac2be3b51f">&#9670;&#160;</a></span>universe_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::universe_type = U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78ed6bcff683cb7d93f29f0e5d06e916" name="a78ed6bcff683cb7d93f29f0e5d06e916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ed6bcff683cb7d93f29f0e5d06e916">&#9670;&#160;</a></span>local_universe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::local_universe = typename universe_type::local_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afab1fdfa842f2712d8ee378621b8384c" name="afab1fdfa842f2712d8ee378621b8384c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab1fdfa842f2712d8ee378621b8384c">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::allocator_type = Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f73b45df4ed4462b79d0d59c6c44ab2" name="a2f73b45df4ed4462b79d0d59c6c44ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f73b45df4ed4462b79d0d59c6c44ab2">&#9670;&#160;</a></span>this_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::this_type = <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt;<a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a>, <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02740d662b4d7a2806998f6a9d9d144f" name="a02740d662b4d7a2806998f6a9d9d144f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02740d662b4d7a2806998f6a9d9d144f">&#9670;&#160;</a></span>tell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::tell_type = battery::vector&lt;<a class="el" href="structlala_1_1_v_store_1_1var__dom.html">var_dom</a>&lt;Alloc&gt;, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a387a5725d2a750c7829a88c1f7c53ea2" name="a387a5725d2a750c7829a88c1f7c53ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387a5725d2a750c7829a88c1f7c53ea2">&#9670;&#160;</a></span>ask_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::ask_type = <a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt;Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a614fae6892d84d8a93cbbf1e962be812" name="a614fae6892d84d8a93cbbf1e962be812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614fae6892d84d8a93cbbf1e962be812">&#9670;&#160;</a></span>snapshot_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc  = allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::snapshot_type = battery::vector&lt;<a class="el" href="#a78ed6bcff683cb7d93f29f0e5d06e916">local_universe</a>, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa638b858396b19454bcd9c0fc55bbf56" name="aa638b858396b19454bcd9c0fc55bbf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa638b858396b19454bcd9c0fc55bbf56">&#9670;&#160;</a></span>VStore() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e6239f39c39f1a7dd67373da811349d" name="a2e6239f39c39f1a7dd67373da811349d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6239f39c39f1a7dd67373da811349d">&#9670;&#160;</a></span>VStore() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>atype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty store. </p>

</div>
</div>
<a id="a868ab6c579bd4303c6d7c804b2e289d7" name="a868ab6c579bd4303c6d7c804b2e289d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868ab6c579bd4303c6d7c804b2e289d7">&#9670;&#160;</a></span>VStore() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>atype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ef7f38d67b15dfa9c3cb16a320604fe" name="a6ef7f38d67b15dfa9c3cb16a320604fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7f38d67b15dfa9c3cb16a320604fe">&#9670;&#160;</a></span>VStore() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7b573e6a89c965029f18f732c19b9e4" name="ae7b573e6a89c965029f18f732c19b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b573e6a89c965029f18f732c19b9e4">&#9670;&#160;</a></span>VStore() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class R , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af31cf75b06e07652f51dd6778d6cb482" name="af31cf75b06e07652f51dd6778d6cb482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31cf75b06e07652f51dd6778d6cb482">&#9670;&#160;</a></span>VStore() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class R , class Alloc2 , class... Allocators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; R, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_deps.html">AbstractDeps</a>&lt; Allocators... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>deps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the vstore <code>other</code> in the current element. <code>deps</code> can be empty and is not used besides to get the allocator (since this abstract domain does not have dependencies). </p>

</div>
</div>
<a id="aa5491c7ee3a839a55b7579c02bdd141b" name="aa5491c7ee3a839a55b7579c02bdd141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5491c7ee3a839a55b7579c02bdd141b">&#9670;&#160;</a></span>VStore() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::VStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a457d82333e45ab37c2002006e0f201eb" name="a457d82333e45ab37c2002006e0f201eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457d82333e45ab37c2002006e0f201eb">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c0cc0aa74e143054796a5c027ebd1ef" name="a2c0cc0aa74e143054796a5c027ebd1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0cc0aa74e143054796a5c027ebd1ef">&#9670;&#160;</a></span>aty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::aty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeace8e8f76a313cf98e9fc8b4fad691d" name="aeace8e8f76a313cf98e9fc8b4fad691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeace8e8f76a313cf98e9fc8b4fad691d">&#9670;&#160;</a></span>vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::vars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of variables currently represented by this abstract element. </p>

</div>
</div>
<a id="a0276be0cdf35873f0363596b846c78b8" name="a0276be0cdf35873f0363596b846c78b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0276be0cdf35873f0363596b846c78b8">&#9670;&#160;</a></span>top() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>atype</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22a77de93ae9d623dae73dc910eb6d74" name="a22a77de93ae9d623dae73dc910eb6d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a77de93ae9d623dae73dc910eb6d74">&#9670;&#160;</a></span>bot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::bot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a2b9e4be0630d656d38a75c914de03c40">AType</a></td>          <td class="paramname"><span class="paramname"><em>atype</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="sort_8hpp.html#af5d67e1d1856b2c01653a0f9ab95d391">UNTYPED</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A special symbolic element representing top. </p>

</div>
</div>
<a id="afec81b82a44c1812f5debc824c58b8c3" name="afec81b82a44c1812f5debc824c58b8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec81b82a44c1812f5debc824c58b8c3">&#9670;&#160;</a></span>bot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::bot </td>
          <td>(</td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43a0fe8a57a95d575e2c2c30f2297adc" name="a43a0fe8a57a95d575e2c2c30f2297adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a0fe8a57a95d575e2c2c30f2297adc">&#9670;&#160;</a></span>top() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::top </td>
          <td>(</td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a>{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a685c90b32f5a8f12c89df0e91a0fda62" name="a685c90b32f5a8f12c89df0e91a0fda62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685c90b32f5a8f12c89df0e91a0fda62">&#9670;&#160;</a></span>is_bot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::is_bot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one element is equal to bot in the store, <code>false</code> otherwise. @parallel @order-preserving @increasing </dd></dl>

</div>
</div>
<a id="a096690d0928f5f736201f9207c67c287" name="a096690d0928f5f736201f9207c67c287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096690d0928f5f736201f9207c67c287">&#9670;&#160;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::is_top </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The bottom element of a store of <code>n</code> variables is when all variables are at bottom, or the store is empty. We do not expect to use this operation a lot, so its complexity is linear in the number of variables. @parallel @order-preserving @decreasing </p>

</div>
</div>
<a id="a7776949f7c413050f586445735b633e5" name="a7776949f7c413050f586445735b633e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7776949f7c413050f586445735b633e5">&#9670;&#160;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#a614fae6892d84d8a93cbbf1e962be812">snapshot_type</a>&lt; Alloc &gt; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take a snapshot of the current variable store. </p>

</div>
</div>
<a id="a87478b6148d299ab2504bbf2e616101e" name="a87478b6148d299ab2504bbf2e616101e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87478b6148d299ab2504bbf2e616101e">&#9670;&#160;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="#a2f73b45df4ed4462b79d0d59c6c44ab2">this_type</a> &amp; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::restore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a614fae6892d84d8a93cbbf1e962be812">snapshot_type</a>&lt; Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>snap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a861e3e786bdfb130e9c8173ac4584cce" name="a861e3e786bdfb130e9c8173ac4584cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861e3e786bdfb130e9c8173ac4584cce">&#9670;&#160;</a></span>interpret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacelala.html#ac24a8d85a4dfb9ed5e5ffcd09a4c60ed">IKind</a> kind, bool diagnose = false, class F , class Env , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::interpret </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;</td>          <td class="paramname"><span class="paramname"><em>intermediate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe6cb43aa94cfddf3e74134c947e2c06" name="afe6cb43aa94cfddf3e74134c947e2c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6cb43aa94cfddf3e74134c947e2c06">&#9670;&#160;</a></span>interpret_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;bool diagnose = false, class F , class Env , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::interpret_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt; Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The store of variables lattice expects a formula with a single variable (including existential quantifiers) that can be handled by the abstract universe <code>U</code>.</p>
<p>Variables must be existentially quantified before a formula containing variables can be interpreted. Variables are immediately assigned to an index of <code><a class="el" href="classlala_1_1_v_store.html">VStore</a></code> and initialized to \( \top_U \). Shadowing/redeclaration of variables with existential quantifier is not supported. The variable mapping is added to the environment only if the interpretation succeeds.</p>
<p>There is a small quirk: different stores might be produced if quantifiers do not appear in the same order. This is because we attribute the first available index to variables when interpreting the quantifier. In that case, the store will only be equivalent modulo the <code>env</code> structure. </p>

</div>
</div>
<a id="aa4e7e828f9eefd27aa7f229d04285a64" name="aa4e7e828f9eefd27aa7f229d04285a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e7e828f9eefd27aa7f229d04285a64">&#9670;&#160;</a></span>interpret_ask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;bool diagnose = false, class F , class Env , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::interpret_ask </td>
          <td>(</td>
          <td class="paramtype">const F &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a387a5725d2a750c7829a88c1f7c53ea2">ask_type</a>&lt; Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_i_diagnostics.html">IDiagnostics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <code>interpret_tell</code> but do not support existential quantifier and therefore leaves <code>env</code> unchanged. </p>

</div>
</div>
<a id="a1e39fdd5d9cef6942829d1fb025b3dec" name="a1e39fdd5d9cef6942829d1fb025b3dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e39fdd5d9cef6942829d1fb025b3dec">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Group , class Store &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">Group &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Store &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad07e2f2ac28a9e7bfa7fb4b31a67932b" name="ad07e2f2ac28a9e7bfa7fb4b31a67932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07e2f2ac28a9e7bfa7fb4b31a67932b">&#9670;&#160;</a></span>reset_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::reset_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afab1fdfa842f2712d8ee378621b8384c">allocator_type</a></td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the allocator of the underlying data, and reallocate the memory without copying the old data. </p>

</div>
</div>
<a id="a4efce47f74ce4ef6700c5c22856d005d" name="a4efce47f74ce4ef6700c5c22856d005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efce47f74ce4ef6700c5c22856d005d">&#9670;&#160;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Univ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Univ &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a245f6b4a071db30091eb714d6a2397f5" name="a245f6b4a071db30091eb714d6a2397f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f6b4a071db30091eb714d6a2397f5">&#9670;&#160;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3d33d8385cad76c5b40ea08361f9cb" name="a8f3d33d8385cad76c5b40ea08361f9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3d33d8385cad76c5b40ea08361f9cb">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This projection must stay const, otherwise the user might tell new information in the universe, but we need to know in case we reach <code>top</code>. </p>

</div>
</div>
<a id="aa16ceff91c486f410beba9fdc92ecf5c" name="aa16ceff91c486f410beba9fdc92ecf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ceff91c486f410beba9fdc92ecf5c">&#9670;&#160;</a></span>meet_bot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::meet_bot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a851c63a2061fb3a599a19cf0e96b53e4" name="a851c63a2061fb3a599a19cf0e96b53e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c63a2061fb3a599a19cf0e96b53e4">&#9670;&#160;</a></span>embed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::embed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dom</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an abstract variable <code>v</code>, <code>embed(VID(v), dom)</code> will update the domain of this variable with the new information <code>dom</code>. This <code>embed</code> method follows PCCP's model, but the variable <code>x</code> must already be initialized in the store. @parallel @order-preserving @increasing </p>

</div>
</div>
<a id="a5c67508bb36c069269a82375196456da" name="a5c67508bb36c069269a82375196456da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c67508bb36c069269a82375196456da">&#9670;&#160;</a></span>embed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_a_var.html">AVar</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6aa6f686a32cf610325253ac2be3b51f">universe_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dom</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This <code>embed</code> method follows PCCP's model, but the variable <code>x</code> must already be initialized in the store. </p>

</div>
</div>
<a id="a05990b94d6b467a49f2f8765a5945ebe" name="a05990b94d6b467a49f2f8765a5945ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05990b94d6b467a49f2f8765a5945ebe">&#9670;&#160;</a></span>deduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::deduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a02740d662b4d7a2806998f6a9d9d144f">tell_type</a>&lt; Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This deduce method can grow the store if required, and therefore do not satisfy the PCCP model. @sequential @order-preserving @increasing </p>

</div>
</div>
<a id="a142273351fbef43eab9bbe68c8b51f0c" name="a142273351fbef43eab9bbe68c8b51f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142273351fbef43eab9bbe68c8b51f0c">&#9670;&#160;</a></span>meet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Precondition: <code>other</code> must be smaller or equal in size than the current store. </p>

</div>
</div>
<a id="a5c01587b9ba7aee943c254672adb3390" name="a5c01587b9ba7aee943c254672adb3390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c01587b9ba7aee943c254672adb3390">&#9670;&#160;</a></span>join_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::join_top </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fbaf0555e781809d123f3761070a657" name="a0fbaf0555e781809d123f3761070a657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbaf0555e781809d123f3761070a657">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Precondition: <code>other</code> must be smaller or equal in size than the current store. </p>

</div>
</div>
<a id="a4b2fe08bf99080f74568e977a5557610" name="a4b2fe08bf99080f74568e977a5557610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2fe08bf99080f74568e977a5557610">&#9670;&#160;</a></span>ask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::ask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a387a5725d2a750c7829a88c1f7c53ea2">ask_type</a>&lt; Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when we can deduce the content of <code>t</code> from the current domain. For instance, if we have in the store <code>x = [0..10]</code>, we can deduce <code>x = [-1..11]</code> but we cannot deduce <code>x = [5..8]</code>. @parallel @order-preserving @decreasing </dd></dl>

</div>
</div>
<a id="ad5590087224ca302d2e67a854c5eb2c4" name="ad5590087224ca302d2e67a854c5eb2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5590087224ca302d2e67a854c5eb2c4">&#9670;&#160;</a></span>num_deductions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::num_deductions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1d773ddf77438addd206ae4c59c5828" name="ac1d773ddf77438addd206ae4c59c5828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d773ddf77438addd206ae4c59c5828">&#9670;&#160;</a></span>deduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="namespacelala_1_1local.html#ae1dbdea88ccb59298d935bba5d3e1843">local::B</a> <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::deduce </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ca95a73f4f1a9eb96d60be6882106d1" name="a3ca95a73f4f1a9eb96d60be6882106d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca95a73f4f1a9eb96d60be6882106d1">&#9670;&#160;</a></span>is_extractable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ExtractionStrategy  = NonAtomicExtraction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::is_extractable </td>
          <td>(</td>
          <td class="paramtype">const ExtractionStrategy &amp;</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ExtractionStrategy()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An abstract element is extractable when it is not equal to bot. If the strategy is <code>atoms</code>, we check the domains are singleton. </p>

</div>
</div>
<a id="ae5593fc2cca2c7bd7c55321807121767" name="ae5593fc2cca2c7bd7c55321807121767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5593fc2cca2c7bd7c55321807121767">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_v_store.html">VStore</a>&lt; U2, Alloc2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ua</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whenever <code>this</code> is different from <code>bot</code>, we extract its data into <code>ua</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="#a3ca95a73f4f1a9eb96d60be6882106d1">is_extractable()</a></code> must be <code>true</code>. For now, we suppose <a class="el" href="classlala_1_1_v_store.html">VStore</a> is only used to store under-approximation, I'm not sure yet how we would interact with over-approximation. </dd></dl>

</div>
</div>
<a id="ae40c04d6386245ce915acaab9c7c15da" name="ae40c04d6386245ce915acaab9c7c15da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c04d6386245ce915acaab9c7c15da">&#9670;&#160;</a></span>deinterpret() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Env , class Allocator2  = typename Env::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator2 &gt; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::deinterpret </td>
          <td>(</td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator2 &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator2()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4815630fd9457eb6186119aab5d04b05" name="a4815630fd9457eb6186119aab5d04b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4815630fd9457eb6186119aab5d04b05">&#9670;&#160;</a></span>deinterpret() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class I , class Env , class Allocator2  = typename Env::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_t_formula.html">TFormula</a>&lt; Allocator2 &gt; <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::deinterpret </td>
          <td>(</td>
          <td class="paramtype">const I &amp;</td>          <td class="paramname"><span class="paramname"><em>intermediate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator2 &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator2()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4341c1611707b468fc65ec4a6d3e8206" name="a4341c1611707b468fc65ec4a6d3e8206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341c1611707b468fc65ec4a6d3e8206">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::print </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a79cea18e9c8234923d4efd31316c6da8" name="a79cea18e9c8234923d4efd31316c6da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cea18e9c8234923d4efd31316c6da8">&#9670;&#160;</a></span>VStore</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classlala_1_1_v_store.html">VStore</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0510ecd324b57306b12d848225496ece" name="a0510ecd324b57306b12d848225496ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0510ecd324b57306b12d848225496ece">&#9670;&#160;</a></span>is_abstract_universe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::is_abstract_universe = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e76f47ea103745383d7a3f8f446f7bf" name="a2e76f47ea103745383d7a3f8f446f7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76f47ea103745383d7a3f8f446f7bf">&#9670;&#160;</a></span>sequential</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::sequential = universe_type::sequential</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae743529c60336a8ab2c8c0fb0eca493" name="aae743529c60336a8ab2c8c0fb0eca493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae743529c60336a8ab2c8c0fb0eca493">&#9670;&#160;</a></span>is_totally_ordered</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::is_totally_ordered = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d106375554ff6a1c4848e764c5afe51" name="a0d106375554ff6a1c4848e764c5afe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d106375554ff6a1c4848e764c5afe51">&#9670;&#160;</a></span>preserve_bot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::preserve_bot = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a072c851a0b13d967e3190f7de1b8c7d6" name="a072c851a0b13d967e3190f7de1b8c7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072c851a0b13d967e3190f7de1b8c7d6">&#9670;&#160;</a></span>preserve_top</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::preserve_top = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bdb96161027dc513e2eab6aa7183a3c" name="a6bdb96161027dc513e2eab6aa7183a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdb96161027dc513e2eab6aa7183a3c">&#9670;&#160;</a></span>preserve_join</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::preserve_join = universe_type::preserve_join</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add027ddd3e5d5a831fb4cb22742466f8" name="add027ddd3e5d5a831fb4cb22742466f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add027ddd3e5d5a831fb4cb22742466f8">&#9670;&#160;</a></span>preserve_meet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::preserve_meet = universe_type::preserve_meet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fdba4fd71e31dd7349bdfa363cba31c" name="a8fdba4fd71e31dd7349bdfa363cba31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdba4fd71e31dd7349bdfa363cba31c">&#9670;&#160;</a></span>injective_concretization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::injective_concretization = universe_type::injective_concretization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95ede6c750cc77760db73f21e1de3db2" name="a95ede6c750cc77760db73f21e1de3db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ede6c750cc77760db73f21e1de3db2">&#9670;&#160;</a></span>preserve_concrete_covers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::preserve_concrete_covers = universe_type::preserve_concrete_covers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72bdda7d3d99121dee14dae139746c6e" name="a72bdda7d3d99121dee14dae139746c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bdda7d3d99121dee14dae139746c6e">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classlala_1_1_v_store.html">lala::VStore</a>&lt; U, Allocator &gt;::name = &quot;VStore&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/lala/<a class="el" href="vstore_8hpp_source.html">vstore.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li><li class="navelem"><a class="el" href="classlala_1_1_v_store.html">VStore</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
