<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lattice Land Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Lattice Land</a></li><li class="chapter-item expanded affix "><li class="part-title">CUDA Battery Library</li><li class="chapter-item expanded "><a href="1-cuda-battery.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="2-cuda-battery.html"><strong aria-hidden="true">3.</strong> Data from CPU to GPU</a></li><li class="chapter-item expanded "><a href="3-cuda-battery.html"><strong aria-hidden="true">4.</strong> CMake Project</a></li><li class="chapter-item expanded "><a href="4-cuda-battery.html"><strong aria-hidden="true">5.</strong> In-Kernel Allocation</a></li><li class="chapter-item expanded "><a href="5-cuda-battery.html"><strong aria-hidden="true">6.</strong> Shared Memory Allocator</a></li><li class="chapter-item expanded "><a href="6-cuda-battery.html"><strong aria-hidden="true">7.</strong> Caution</a></li><li class="chapter-item expanded affix "><li class="part-title">Seminars</li><li class="chapter-item expanded "><a href="abstract-week.html"><strong aria-hidden="true">8.</strong> Abstract Interpretation Workshop (2024)</a></li><li class="chapter-item expanded affix "><li class="part-title">Turbo Technical Journal</li><li class="chapter-item expanded "><a href="1-turbo.html"><strong aria-hidden="true">9.</strong> Introducing Turbo</a></li><li class="chapter-item expanded "><a href="2-turbo.html"><strong aria-hidden="true">10.</strong> v1.0.1: Unoptimized Turbo</a></li><li class="chapter-item expanded "><a href="3-turbo.html"><strong aria-hidden="true">11.</strong> v1.1.{0-1}: Preprocessing</a></li><li class="chapter-item expanded "><a href="4-turbo.html"><strong aria-hidden="true">12.</strong> v1.1.2: (Dis)equality Propagator</a></li><li class="chapter-item expanded "><a href="5-turbo.html"><strong aria-hidden="true">13.</strong> v1.1.3: Warp Synchronization</a></li><li class="chapter-item expanded "><a href="6-turbo.html"><strong aria-hidden="true">14.</strong> v1.1.{4-5}: Sorting Propagators</a></li><li class="chapter-item expanded "><a href="7-turbo.html"><strong aria-hidden="true">15.</strong> v1.1.{6-7}: Sharing Propagators</a></li><li class="chapter-item expanded "><a href="8-turbo.html"><strong aria-hidden="true">16.</strong> v1.2.0: Refactoring</a></li><li class="chapter-item expanded "><a href="9-turbo.html"><strong aria-hidden="true">17.</strong> Open Hackathon</a></li><li class="chapter-item expanded affix "><li class="part-title">About</li><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">18.</strong> About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lattice Land Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lattice-land"><a class="header" href="#lattice-land">Lattice Land</a></h1>
<p>Hello! You just arrived in lattice land!
Lattice land is a collection of C++ libraries compatible with NVIDIA CUDA framework.
Most of the libraries implement <em>abstract domains for constraint reasoning</em> a new kind of data structure based on <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">abstract interpretation</a>, <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice theory</a> and <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction">constraint reasoning</a>.
This is a book presenting our research project, the involved research papers and the code documentation.</p>
<p>This project is available on <a href="https://github.com/lattice-land">github</a>.</p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<ul>
<li><a href="https://lattice-land.github.io/cuda-battery">cuda-battery</a>: Memory allocators, vector, utilities and more which run on both CPU and GPU (CUDA).
See also the chapter <a href="1-cuda-battery.html">CUDA-Battery Library</a>.</li>
<li><a href="https://lattice-land.github.io/lala-core">lala-core</a>: Core definitions of the formula AST and abstract domain.</li>
<li><a href="https://lattice-land.github.io/lala-parsing">lala-parsing</a>: Utilities to parse combinatorial formats including flatzinc (.fzn) and XCSP3 (.xml).</li>
<li><a href="https://lattice-land.github.io/lala-pc">lala-pc</a>: <em>Propagator completion abstract domain</em> representing a collection of refinement functions. It implements propagators, an essential component of constraint solver.</li>
<li><a href="https://lattice-land.github.io/lala-power">lala-power</a>: Abstract domains representing disjunctive collections of information. It includes the search tree and branch-and-bound.</li>
<li><a href="https://lattice-land.github.io/turbo">turbo</a>: Abstract constraint solver building on all other libraries.</li>
<li><a href="https://github.com/lattice-land/lattice-land.github.io">lattice-land.github.io</a>: The repository hosting this book and the libraries documentation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The main objective of the CUDA battery library is to make it easier to develop software fully executing on the GPU.
This is in contrast to applications where the CPU is the "director", and the GPU is only there to execute small kernels performing specific parallel tasks.
We want to have the whole computation on the GPU when possible.
Why you asked?
Because it is more efficient as we avoid round-trips between CPU and GPU; although calling a kernel is very fast, the memory transfers are still costly.
In the research project <a href="https://github.com/lattice-land">lattice-land</a>, we also explore pure GPU computation as a new paradigm where many small functions collaborate in parallel to reach a common goal.</p>
<p>Developing systems in CUDA is a daunting task because the CUDA API is reminiscent of C programming, and it lacks modern C++ idioms and data structures.
For instance, memory allocations and deallocations are managed by malloc/free variants, arrays are pointers and we do not have access to the C++ STL.
Moreover, due to the specificities of the CUDA API, it is usually difficult to program a single function working on both the CPU and the GPU.
Although it is rarely possible to have the exact same algorithm on both CPU and GPU, there are often algorithmic components that are shared.
Having them both on CPU and GPU can help to verify the parallel version produces the same result as the sequential version, and it also allows us to benchmark CPU vs GPU.</p>
<p>The <a href="https://github.com/lattice-land/cuda-battery">cuda-battery</a> library reimplements basic data structures from the STL in a way such that the same code runs on both CPU and GPU.
One of the only technical differences between CPU and GPU is memory allocation.
To overcome this difference, we provide various allocators that allocate memory in the CPU memory, unified memory, and GPU global and shared memory.
The idea is then to parametrize your classes (through a C++ template) with an allocator type and, depending on whether you run your algorithm on the CPU or GPU, to instantiate it with a suited allocator type.
Among the supported data structures, we have <code>vector</code>, <code>string</code>, <code>variant</code>, <code>tuple</code>, <code>unique_ptr</code>, <code>shared_ptr</code>, a variant of <code>bitset</code> and many utility functions.
In addition to the STL, we provide an abstraction of the memory accesses to enable non-atomic (sequential) and atomic (parallel) read and write operations.
The memory abstraction is necessary when writing code working on both GPU and CPU, but also when writing GPU parallel code that can work in global and shared memory, and at the thread, block, grid and multi-grid level.</p>
<p>This library aims to be generic and usable in different kind of projects, but when a design decision needs to be made, it will be influenced by the needs of the project <a href="https://github.com/lattice-land">lattice-land</a>.</p>
<p>Everything is under the namespace <code>battery::</code>.
The Doxygen documentation is available <a href="cuda-battery/index.html">here</a>.
Due to lack of time, these are often partial implementation of their STL counterpart, and there are sometimes (documented) differences.</p>
<p>NVIDIA is developing <a href="https://nvidia.github.io/libcudacxx/">libcudacxx</a>, a version of the standard C++ library compatible with GPU, and with extensions specific to CUDA.
<em>cuda-battery</em> can be seen as an extension of <em>libcudacxx</em>, and we intend to remove the data structures proposed here as soon as they become available in <em>libcudacxx</em>.
Another well-known library is <a href="https://github.com/NVIDIA/thrust">thrust</a>, but it does not share the same goal since it hides the parallel computation inside the data structure, e.g. <code>reduce</code> on a <code>vector</code> is automatically parallelized on the GPU.</p>
<p>Note that this tutorial does not introduce basic CUDA concepts: it is for (possibly beginners) CUDA programmers who want to simplify their code.
For an introduction to CUDA, you can first refer to <a href="https://ulhpc-tutorials.readthedocs.io/en/latest/gpu/cuda2023/">this tutorial</a>.
Finally, the full code of all examples given here is available in a <a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo">demo project</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transferring-data-from-the-cpu-to-the-gpu"><a class="header" href="#transferring-data-from-the-cpu-to-the-gpu">Transferring data from the CPU to the GPU</a></h1>
<p>(<a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo/src/demo.cpp">code of this section</a>)</p>
<p>One of the first tasks a CUDA programmer is facing is to transfer data from the CPU to the GPU.
Using this library, it is very straightforward, and it is always the same scheme.
To illustrate the concepts of this library, we implement a <code>map(v, f)</code> function which applies a function <code>f</code> to all elements of the sequence <code>v</code> in-place.</p>
<p>We firstly need to transfer the data <code>v</code> to the GPU using managed memory, and it is as simple as that:</p>
<pre><code class="language-c++">int main() {
  std::vector&lt;int&gt; v(1000, 50);
  battery::vector&lt;int, battery::managed_allocator&gt; gpu_v(v);
  return 0;
}
</code></pre>
<p>Now we must pass <code>gpu_v</code> to a CUDA kernel.
However, there is a slight technical issue due to the weird parameters passing semantics of CUDA kernel (<code>__global__</code> function): we must pass primitive types or pointers to the functions.
Indeed, trying to pass an object by reference or copy <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#function-parameters">is undefined behavior</a>.
This is only a restriction on <code>__global__</code> functions, and once inside the kernel, passing by reference or copy works well (when calling <code>__device__</code> functions).
You could simply pass the data as <code>kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(gpu_v.data(), gpu_v.size())</code>, but you lose all the advantages of vector when programming in the kernel.
The solution is to wrap <code>gpu_v</code> inside a pointer, which we can still do the C++ way using <code>unique_ptr</code>:</p>
<pre><code class="language-c++">using mvector = battery::vector&lt;int, battery::managed_allocator&gt;;

__global__ void map_kernel(mvector* v_ptr) {
  mvector&amp; v = *v_ptr;
  // ... Compute on `v` in parallel.
}

void map(std::vector&lt;int&gt;&amp; v) {
  auto gpu_v = battery::make_unique&lt;mvector, battery::managed_allocator&gt;(v);
  map_kernel&lt;&lt;&lt;256, 256&gt;&gt;&gt;(gpu_v.get());
  CUDAEX(cudaDeviceSynchronize());
  // Transfering the new data to the initial vector.
  for(int i = 0; i &lt; v.size(); ++i) {
    v[i] = (*gpu_v)[i];
  }
}
</code></pre>
<p>Due to the <a href="https://en.cppreference.com/w/cpp/language/raii">C++ RAII idiom</a>, the managed memory of both the GPU <code>unique_ptr</code> and <code>mvector</code> is automatically freed when leaving the scope of the function.
Importantly, the memory allocated on the CPU must be freed by the CPU, even if it is accessible by the GPU, and vice-versa.
But you should not encounter this issue if you use this idiom to pass data from the CPU to the GPU.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-cuda-project"><a class="header" href="#cmake-cuda-project">CMake CUDA Project</a></h1>
<p>(<a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo/CMakeLists.txt">code of this section</a>)</p>
<p>In order to compile and test the code presented above, you will need to add the headers of this library to <code>nvcc</code>.</p>
<pre><code class="language-bash">nvcc -I cuda-battery/include demo.cu
</code></pre>
<p>We prefer to delegate the management of dependencies to <a href="https://cmake.org/">CMake</a>, a build automation tool.
However, creating a CMake project for hybrid CPU/GPU code is not an easy task, and we provide a demonstration CMake project in <a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo">cuda-battery/demo</a>.
You can start your own project by copying the <code>demo</code> folder and modifying the name of the project inside the file <code>CMakeLists.txt</code>.
To compile and run this project, you can write:</p>
<pre><code>cd cuda-battery/demo
mkdir -p build/gpu-debug
cmake -DCMAKE_BUILD_TYPE=Debug -Bbuild/gpu-debug
cmake --build build/gpu-debug
./build/gpu-debug/demo
</code></pre>
<p>It compiles the demo project in debug mode using the GPU compiler (<code>nvcc</code>), along with the unit tests (using the Google testing framework GTest).
You can also compile it in release mode by simply changing <code>debug</code> to <code>release</code> in the previous commands.
To run the tests, the command <code>ctest</code> can be used as follows:</p>
<pre><code>ctest --test-dir build/gpu-debug/
</code></pre>
<p>Among the characteristics of this project:</p>
<ul>
<li>Files have the <code>.cpp</code> extension instead of the <code>.cu</code> extension.</li>
<li>It compiles code for the native GPU architecture by default (so for the GPU of the computer you are compiling your code on).
This can easily be changed if you are cross-compiling by defining the flag <code>CMAKE_CUDA_ARCHITECTURES</code> at the configuration stage:</li>
</ul>
<pre><code>cmake -DCMAKE_CUDA_ARCHITECTURES=70 -DCMAKE_BUILD_TYPE=Release -Bbuild/gpu-release
</code></pre>
<ul>
<li>Several useful options inherited from cuda-battery (enabling C++20 and constexpr extension).</li>
<li>A testing framework where you can write your CPU tests using Google Test framework (see <code>demo/tests/demo_test.cpp</code>) and your hand-made GPU tests (see <code>demo/tests/demo_test_gpu.cpp</code>).</li>
<li>Moreover, when testing GPU code, we verify there is no memory leaks or some data races (using <code>compute-sanitizer</code>).</li>
</ul>
<p>We have documented the <a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo/CMakeLists.txt">CMakeLists.txt</a> so you can adjust it to your own project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-kernel-memory-allocation"><a class="header" href="#in-kernel-memory-allocation">In-Kernel Memory Allocation</a></h1>
<p>(<a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo/src/inkernel_allocation.cpp">code of this section</a>)</p>
<p>The typical way to allocate data structures shared by all threads or blocks in a CUDA kernel is to get all the memory allocations done before the kernel starts.
However, when developing a larger CUDA kernel, it is frequent to rely on intermediate structures that are only temporary and are deleted before the end of the kernel.
It might be difficult, or at best inconvenient, to allocate everything before the start of the kernel.
Moreover, to follow good software engineering practice, these temporary structures should be hidden from the user of the kernel.</p>
<h2 id="thread-local-memory"><a class="header" href="#thread-local-memory">Thread-local Memory</a></h2>
<p>Thread-local memory is a chunk of memory that is only accessed by a single thread.
This is the default allocation mode when declaring a variable in CUDA kernel, hence it does not need any support from this library.</p>
<h2 id="block-local-memory"><a class="header" href="#block-local-memory">Block-local Memory</a></h2>
<p>Block-local memory is a chunk of memory that is only accessed by the threads of a single block.
To avoid any ambiguity: "block-local memory" is conceptual and might reside in global memory; it is not necessarily in shared memory.</p>
<p>A simple use-case is when blocks need to work on different copies of an original array.
Suppose <code>*v_ptr</code> is an array shared by all blocks.
In the following kernel, we show how to use <code>battery::make_unique_block</code> to copy <code>*v_ptr</code> into a block-local vector <code>v_block</code>.</p>
<pre><code class="language-c++">using gvector = battery::vector&lt;int, battery::global_allocator&gt;;
__global__ void block_vector_copy(mvector* v_ptr) {
  battery::unique_ptr&lt;gvector, battery::global_allocator&gt; v_block_ptr;
  gvector&amp; v_block = battery::make_unique_block(v_block_ptr, *v_ptr);
  // Now each block has its own local copy of the vector `*v_ptr`.
  // ...
  // We must synchronize the threads at the end, in case the thread holding the pointer in `unique_ptr` terminates before the other.
  cooperative_groups::this_thread_block().sync(); // Alternatively, `__syncthreads();`
}
</code></pre>
<p>Without this facility, we would need to initialize <code>n</code> copies of the vector in the host code and pass them as parameters to the kernel.
Finally, the function <code>make_unique_block</code> synchronizes all threads of the current block before returning, therefore <code>v_block</code> is directly usable by all threads.
Before you use this technique, keep reading because you might need to increase the size of the heap and stack.</p>
<h2 id="avoiding-obscure-cuda-runtime-errors"><a class="header" href="#avoiding-obscure-cuda-runtime-errors">Avoiding Obscure CUDA Runtime Errors</a></h2>
<p>Developing an entire system within a single kernel can easily lead to CUDA runtime error due to overflow of the allowed heap and stack memory.
The heap memory is by-default limited to 8 MB for allocations taking place in the kernel.
If you allocate more than 8 MB, which is not very difficult, you will run into an error of the style "CUDA runtime error an illegal memory access was encountered".
In that case, you must increase the size of the heap, and this can be done as follows:</p>
<pre><code class="language-c++">// Multiply by 10 the default value, so now we have 80MB.
void increase_heap_size() {
  size_t max_heap_size;
  cudaDeviceGetLimit(&amp;max_heap_size, cudaLimitMallocHeapSize);
  CUDAE(cudaDeviceSetLimit(cudaLimitMallocHeapSize, max_heap_size*10));
  cudaDeviceGetLimit(&amp;max_heap_size, cudaLimitMallocHeapSize);
  printf("%%GPU_max_heap_size=%zu (%zuMB)\n", max_heap_size, max_heap_size/1000/1000);
}

int main() {
  increase_heap_size();
  auto vptr = battery::make_unique&lt;mvector, battery::managed_allocator&gt;(100000, 42);
  auto ptr = vptr.get();

  block_vector_copy&lt;&lt;&lt;256, 256&gt;&gt;&gt;(ptr);
  CUDAEX(cudaDeviceSynchronize());
}
</code></pre>
<p>For the stack, which is allocated per-thread, the problem can quickly arrive if you have many function calls and local variables.
In that case you can increase the size of the stack as follows:</p>
<pre><code class="language-c++">void increase_stack_size() {
  size_t max_stack_size = 1024;
  CUDAE(cudaDeviceSetLimit(cudaLimitStackSize, max_stack_size*10));
  cudaDeviceGetLimit(&amp;max_stack_size, cudaLimitStackSize);
  printf("%%GPU_max_stack_size=%zu (%zuKB)\n", max_stack_size, max_stack_size/1000);
}
</code></pre>
<p>For information, the stack frames are stored in global memory, but the compiler will try its best to place them in the registers and caches when possible.</p>
<h2 id="grid-local-memory"><a class="header" href="#grid-local-memory">Grid-local Memory</a></h2>
<p>Similarly to the previous section, we sometimes wish to initialize, inside the kernel, data that is shared by all blocks.
Once again, we suppose to have an original array <code>*v_ptr</code> that we wish to copy, but per-grid and not per-block.</p>
<pre><code class="language-c++">__global__ void grid_vector_copy(mvector* v_ptr) {
  battery::unique_ptr&lt;gvector, battery::global_allocator&gt; v_copy_ptr;
  gvector&amp; v_copy = battery::make_unique_grid(v_copy_ptr, *v_ptr);
  // `v_copy` is now accessible by all blocks.
  // ...
  // Same as with block-local memory, we want to guard against destructing the pointer too early.
  cooperative_groups::this_grid().sync();
}
</code></pre>
<p>To synchronize among threads, both <code>make_unique_block</code> and <code>make_unique_grid</code> rely on <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cooperative-groups">cooperative groups</a>.
In the case of <code>make_unique_grid</code>, CUDA requires the kernel to be launched with a <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#grid-synchronization">different syntax</a>:</p>
<pre><code class="language-c++">int main() {
  increase_heap_size();
  auto vptr = battery::make_unique&lt;mvector, battery::managed_allocator&gt;(100000, 42);
  auto ptr = vptr.get();
  void *kernelArgs[] = { &amp;ptr }; // be careful, we need to take the address of the parameter we wish to pass.
  dim3 dimBlock(256, 1, 1);
  dim3 dimGrid(256, 1, 1);
  cudaLaunchCooperativeKernel((void*)grid_vector_copy, dimGrid, dimBlock, kernelArgs);
  CUDAE(cudaDeviceSynchronize());
  return 0;
}
</code></pre>
<p>I am not sure why the syntax is different, but since it is a fairly recent feature, it might be improved in future releases.</p>
<h2 id="multi-grid-memory"><a class="header" href="#multi-grid-memory">Multi-grid Memory</a></h2>
<p>For now, we do not support multi-grid memory allocation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-memory-allocator"><a class="header" href="#shared-memory-allocator">Shared Memory Allocator</a></h1>
<p>(<a href="https://github.com/lattice-land/cuda-battery/tree/v1.0.0/demo/src/demo.cpp">code of this section</a>)</p>
<p>We show how to use shared memory using a memory pool allocator.</p>
<pre><code class="language-c++">using pvector = battery::vector&lt;int, battery::pool_allocator&gt;;

__global__ void map_kernel_shared(mvector* v_ptr, size_t shared_mem_capacity) {
  // I. Create a pool of shared memory.
  extern __shared__ unsigned char shared_mem[];
  battery::unique_ptr&lt;battery::pool_allocator, battery::global_allocator&gt; pool_ptr;
  // /!\ We must take a reference to the pool_allocator to avoid copying it, because its copy-constructor is not thread-safe! (It can only be used by one thread at a time).
  battery::pool_allocator&amp; shared_mem_pool = battery::make_unique_block(pool_ptr, static_cast&lt;unsigned char*&gt;(shared_mem), shared_mem_capacity);

  // II. Transfer from global memory to shared memory.
  battery::unique_ptr&lt;pvector, battery::global_allocator&gt; shared_vector;
  size_t chunk_size = chunk_size_per_block(*v_ptr, gridDim.x);
  auto span = make_safe_span(*v_ptr, chunk_size * blockIdx.x, chunk_size);
  pvector&amp; v = battery::make_unique_block(shared_vector, span.data(), span.size(), shared_mem_pool);

  // III. Run the algorithm on the shared memory.
  block_par_map(v, [](int x){ return x * 2; }, blockDim.x, threadIdx.x);
  __syncthreads();

  // IV. Transfer back from shared memory to global memory.
  for(int i = threadIdx.x; i &lt; v.size(); i += blockDim.x) {
    (*v_ptr)[chunk_size * blockIdx.x + i] = v[i];
  }
}
</code></pre>
<p>We initialize one pool allocator per-block using the same technique as shown before.
However, we must be careful to take the <code>pool_allocator</code> by reference because its copy-constructor is not thread-safe; similarly to <code>shared_ptr</code> it maintains a shared counter to its memory pool.
Since memory allocation is done by only one thread anyway, it does not make sense to have multiple copies of this allocator.</p>
<p>The next step is to transfer the vector to the shared memory.
Each block works on a chunk of the initial array.
Therefore, we do not want to move the whole array in shared memory, but only the part of interest for that block.
To achieve that, we compute the size of the chunk using <code>chunk_size_per_block</code> and create a view of the vector covering only that chunks.
We use <a href="https://en.cppreference.com/w/cpp/container/span">std::span</a> to model the view.
Note that we can use the STL <code>std::span</code> because all its methods are <code>constexpr</code>, and we have the NVCC flag <code>--expt-relaxed-constexpr</code> inherited from cuda-battery.
We then copy this span into the vector <code>v</code> which is in shared memory.</p>
<p>The algorithm <code>block_par_map</code> is then called on <code>v</code> for each block.
The last step is to transfer the memory from the shared memory to the global memory.
After each block finished computing, the <code>map</code> function has been applied to each element of the initial vector.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-word-of-caution-on-shared-state-parallelism"><a class="header" href="#a-word-of-caution-on-shared-state-parallelism">A Word of Caution on Shared-State Parallelism</a></h1>
<p>Developing a parallel algorithm is relatively easy as long as threads read and write independent memory chunks.
Such an algorithm is referred as <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a>.
As a rule of thumb, it is best if you can stay within this paradigm.
For instance using map-reduce operations, where all threads work on separate memory cells during the map operation, and then a single thread performs a reduction of all temporary results obtained.
Sometimes this is not possible, or you want to get to the next level to get better performance.
Beware, designing <em>correct and efficient</em> parallel algorithms with threads communicating in a shared memory system is a whole new world.
We cannot even scratch the surface here, and this library does not provide much support for it.
Nevertheless, it is possible to write such algorithms in CUDA using <a href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives.html">atomics and synchronization primitives</a>.
To use them well, I would advise to take a class (or <a href="https://arxiv.org/abs/1701.00854">read a book</a>) on parallel programming and memory consistency models.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-interpretation-workshop"><a class="header" href="#abstract-interpretation-workshop">Abstract Interpretation Workshop</a></h1>
<p>Hello! During a full week in June, we gather together to study <em>abstract interpretation</em> from its theoretical foundation (lattice theory) to its latest applications (constraint programming, neural network verification).</p>
<p>Abstract interpretation is a formal theory of software verification invented by Radhia and Patrick Cousot in the seventies to detect bugs in programs statically ("at compile-time") and directly on the source code (not on a model of the program).
The main contribution of abstract interpretation is to overapproximate the semantics of a program: violations of properties are always discovered, but we sometimes obtain false-positives.
The mathematical framework of abstract interpretation is rich and the papers in the field are complicated for beginners.
During this week, we take our time to understand and digest the main ingredients of abstract interpretation.</p>
<p>Further, this framework of approximation turns out to be very general and goes beyond program verification.
It was recently applied to constraint reasoning and neural network verification, two topics we also discuss during the week.</p>
<p>PS: Dear PhD students, this workshop <em>does not</em> grant ECTS (but you will still learn something!).</p>
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>To have an idea if the rooms are big enough and to avoid running out of coffee, please <a href="https://forms.office.com/e/VLTf7ziA5h">register here</a>.</p>
<h2 id="schedule"><a class="header" href="#schedule">Schedule</a></h2>
<p>Week of the 17th June 2024. The coffee (from Jolt coffee shop, mmh, delicious) and pastries will be offered every morning :-)
For the brave ones coming to the practice sessions on Monday and Tuesday, coffee and pastries are offered again!</p>
<ul>
<li>Monday:
<ul>
<li>09:00-10:30 (MNO 1.050): <em>Introduction to Lattice Theory (part 1)</em>, Bruno Teheux, <a href="abstract-week-2024/slides-session-1-lattice-theory.pdf">slides</a>.</li>
<li>14:00-16:00 (MNO 1.010): Practice session, <a href="abstract-week-2024/exercises-session-1-lattice-theory.pdf">exercises</a>.</li>
</ul>
</li>
<li>Tuesday:
<ul>
<li>09:00-10:30 (MNO 1.020): <em>Introduction to Lattice Theory (part 2)</em>, Bruno Teheux, <a href="abstract-week-2024/slides-session-2-lattice-theory.pdf">slides</a>.</li>
<li>14:00-16:00 (MNO 1.010): Practice session <a href="abstract-week-2024/exercises-session-2-lattice-theory.pdf">exercises</a>.</li>
</ul>
</li>
<li>Wednesday (MNO 1.050):
<ul>
<li>9:00-10:30: <em>Introduction to Abstract Interpretation</em>, Pierre Talbot, <a href="abstract-week-2024/slides-session-3-abstract-interpretation.pdf">slides</a>.</li>
<li>11:00-13:00: <em>Introduction to Constraint Programming</em>, Manuel Combarro, <a href="abstract-week-2024/slides-session-4-introduction-to-constraint-programming.pdf">slides</a>, <a href="abstract-week-2024/N-queens.mzn">N-queens.mzn</a>, <a href="abstract-week-2024/N-queens_alldifferent.mzn">N-queens-alldifferent.mzn</a>.</li>
</ul>
</li>
<li>Thursday (MNO 1.040):
<ul>
<li>9:00-10:30: <em>Abstract Constraint Programming</em>, Pierre Talbot, <a href="abstract-week-2024/slides-session-5-abstract-constraint-programming.pdf">slides</a>.</li>
<li>11:00-12:00: <em>Octagon Abstract Domain</em>, Thibault Falque, <a href="abstract-week-2024/slides-session-6-octagon-abstract-domain.pdf">slides</a>.</li>
</ul>
</li>
<li>Friday (MNO 1.010):
<ul>
<li>9:00-10:30: <em>Introduction to Neural Network Verification by Abstract Interpretation</em>, Yi-Nung Tsao, <a href="abstract-week-2024/slides-session-7-neural-network-verification-by-abstract-interpretation.pdf">slides</a></li>
<li>11:00-12:00: <em>Parallel Lattice Programming</em>, Pierre Talbot, <a href="abstract-week-2024/slides-session-8-parallel-lattice-programming.pdf">slides</a></li>
</ul>
</li>
</ul>
<h2 id="speakers"><a class="header" href="#speakers">Speakers</a></h2>
<img src="pierre.jpg" alt="isolated" width="160" style="border-radius: 50%;"/>
<img src="bruno.jpg" alt="isolated" width="160" style="border-radius: 50%;"/>
<img src="thibault.jpg" alt="isolated" width="160" style="border-radius: 50%;"/>
<img src="manuel.jpg" alt="isolated" width="160" style="border-radius: 50%;"/>
<img src="yinung.jpg" alt="isolated" width="160" style="border-radius: 50%;"/>
<p>Pierre Talbot (research scientist) ▪ Bruno Teheux (assistant professor) ▪ Thibault Falque (postdoctoral researcher) ▪ Manuel Combarro (PhD candidate) ▪ Yi-Nung Tsao (PhD candidate)</p>
<h2 id="detailed-program"><a class="header" href="#detailed-program">Detailed Program</a></h2>
<p>Find below a detailed description of each session with keywords.</p>
<h3 id="introduction-to-lattice-theory"><a class="header" href="#introduction-to-lattice-theory">Introduction to Lattice Theory</a></h3>
<p>Partial order ▪ Lattice ▪ Monotone functions ▪ Cartesian product ▪ Complete lattice ▪ Fixpoint ▪ Galois connection</p>
<p>Recommended prerequisite: None.</p>
<p>The goal of these two lectures is to have a first grasp of the mathematical theory underlying abstract interpretation.
On the first day, we study partial order and lattices, properties of functions over lattices and several lattice constructions such as products and powerset.
On the second day, we overview more advanced concepts such as fixpoint and Galois connection which are particularly useful in abstract interpretation.</p>
<h3 id="introduction-to-abstract-interpretation"><a class="header" href="#introduction-to-abstract-interpretation">Introduction to Abstract Interpretation</a></h3>
<p>Syntax ▪ Reachability semantics ▪ Chaotic iterations ▪ Abstract domains ▪ Widening ▪ Reduced products</p>
<p>Recommended prerequisite: <em>Introduction to Lattice Theory</em>.</p>
<p>The goal is to understand how we can use lattice theory to overapproximate the semantics of program and certify the absence of bugs.
We start by reviewing existing verification techniques (e.g., model checking, theorem proving) and discuss the position of abstract interpretation in this landscape.</p>
<h3 id="introduction-to-constraint-programming"><a class="header" href="#introduction-to-constraint-programming">Introduction to Constraint Programming</a></h3>
<p>Constraint satisfaction problem ▪ Constraint modelling ▪ Propagation ▪ Consistency ▪ Search ▪ Minizinc</p>
<p>Recommended prerequisite: None.</p>
<p>Constraint programming is a powerful paradigm to model problems in terms of constraints over variables.
This declarative paradigm solves many practical problems including scheduling, vehicle routing or biology problems, as well as more unusual problems such as in musical composition.
Constraint programming describes <em>what</em> the problem is, whereas procedural approaches describe <em>how</em> a problem is solved.
The programmer declares the constraints of its problem, and relies on a generic constraint solver to obtain a solution.
In this talk, we formally define what is a constraint satisfaction problem (CSP) and the underlying solving procedure.
Further, this session will be interactive and time will be allocated so you can try to model and solve your own combinatorial problem in the Minizinc constraint modelling language!</p>
<h3 id="abstract-constraint-programming"><a class="header" href="#abstract-constraint-programming">Abstract Constraint Programming</a></h3>
<p>Abstract satisfaction ▪ Solver cooperation ▪ Propagator completion ▪ Table abstract domain</p>
<p>Recommended prerequisites: <em>Introduction to Lattice Theory</em>, <em>Introduction to Abstract Interpretation</em>, <em>Introduction to Constraint Programming</em>.</p>
<p>This talk presents a recent research field!</p>
<p>Combinatorial optimization is a large field of research aiming at finding (best) solutions of logical formulas.
There are many research communities working separately on reasoning procedures that work well on different kinds of problems (essentially depending on the underlying domain of discourse and logic predicates).
For instances, linear programming solvers are the best to solve linear equations over real numbers but has more difficulty over integers and are unable to deal with non-linearity.
SAT solvers can solve very large Boolean formulas but problems can be hard to express compactly when only Boolean variables are available.
Constraint programming is a general approach to constraint solving but this generality makes it slower the classes of problem mentioned above.
The issue is that each approach is based on different theoretical foundation which makes solver cooperation hard to achieve.
We believe abstract interpretation can provide a unified theory of constraint reasoning by abstracting each solving approach in abstract domains, that can then be combined with different products.
The first step is to cast the theory of each approach in the framework of abstract interpretation.
It has already been started for linear solvers, SAT and constraint programming solvers.
In this talk, we focus on the constraint programming approach and present our latest research on this topic.</p>
<h3 id="octagon-abstract-domain"><a class="header" href="#octagon-abstract-domain">Octagon Abstract Domain</a></h3>
<p>Octagon ▪ Temporal constraints ▪ Scheduling problems</p>
<p>Recommended prerequisites: <em>Abstract Constraint Programming</em>.</p>
<p>An octagon is an abstract domain able to reason over conjunction of temporal constraints which are restricted linear equation of the form <code>±x ± y ≤ k</code> where <code>x,y</code> are variables and <code>k</code> a constant.
Octagons offer a particularly interesting compromise between expressiveness and efficiency since they can compute the solutions of a set of temporal constraints in cubic time using the Floyd Warshall shortest path algorithm.
We explain octagon in the context of abstract constraint programming and show how it can enhance solver performance, particularly in scheduling problems.
We also discuss a particular case of reduced product between the propagator completion and octagon abstract domains.</p>
<h3 id="introduction-to-neural-network-verification-by-abstract-interpretation"><a class="header" href="#introduction-to-neural-network-verification-by-abstract-interpretation">Introduction to Neural Network Verification by Abstract Interpretation</a></h3>
<p>Neural network verification ▪ Robustness metrics ▪ Zonotope abstract domain</p>
<p>Recommended prerequisites: <em>Introduction to Lattice Theory</em>, <em>Introduction to Abstract Interpretation</em>.</p>
<p>This talk presents a recent research field!</p>
<p>Neural networks have become powerful and popular machine learning techniques in recent years.
There are many safety-critical applications based on neural networks, such as autonomous driving systems.
However, they can be vulnerable to adversarial examples, which are instances with imperceptible perturbations that can lead to incorrect results from neural networks.
Therefore, in these safety applications, if any adversarial examples exist, the neural network may make wrong decisions, potentially causing serious consequences.
Nowadays, many algorithms and frameworks have been proposed to verify the robustness of neural networks.
In this talk, we will introduce how to use abstract interpretation to evaluate the robustness of neural networks.
Additionally, we will provide a simple example to demonstrate how to construct a zonotope, which is one of the abstract domains, to verify neural networks.</p>
<h3 id="parallel-lattice-programming"><a class="header" href="#parallel-lattice-programming">Parallel Lattice Programming</a></h3>
<p>GPU ▪ Asynchronous iterations ▪ Concurrent constraint programming ▪ Memory consistency ▪ Parallel graph algorithms</p>
<p>Recommended prerequisites: <em>Introduction to Lattice Theory</em>.</p>
<p>This talk presents a recent research field!</p>
<p>We introduce a programming language in which data are lattices, programs are monotone functions, and the execution model is a fixpoint loop.
The peculiarity of this language is to have a native parallel operator (P || Q) but no sequence operator (P;Q).
Due to its lattice execution model, data races are natively supported (they do not modify the final results), no deadlock can occur, and the implementation is lock-free.
We study several algorithms that can be written in this paradigm including a sorting algorithm and the Floyd-Warshall shortest path algorithm.
We discuss how this paradigm was applied to write Turbo, a constraint solver based on abstract interpretation that fully executes on the GPU.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Here are some references relevant to the various sessions:</p>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li>Davey, Brian A., and Hilary A. Priestley. <em>Introduction to Lattices and Order</em>. Cambridge University Press, 2002.</li>
<li>Cousot, Patrick. <em>Principles of Abstract Interpretation.</em> MIT Press, 2021.</li>
<li>Apt, Krzysztof. <em>Principles of Constraint Programming.</em> Cambridge University Press, 2003.</li>
<li>Aws Albarghouthi, <em>Introduction to Neural Network Verification</em>. Foundations and Trends® in Programming Languages (2021).</li>
<li>Changliu Liu, Tomer Arnon, Christopher Lazarus, Christopher Strong, Clark Barrett and Mykel J. Kochenderfer, <em>Algorithms for Verifying Deep Neural Networks</em>. Foundations and Trends® in Optimization (2021).</li>
</ul>
<h3 id="selected-papers"><a class="header" href="#selected-papers">Selected Papers</a></h3>
<ul>
<li>D'Silva, Vijay, Leopold Haller, and Daniel Kroening. <em>Abstract Satisfaction</em>. POPL 2014.</li>
<li>Miné, Antoine. <em>The Octagon Abstract Domain.</em> Higher-order and symbolic computation (2006).</li>
</ul>
<h3 id="our-papers"><a class="header" href="#our-papers">Our Papers</a></h3>
<ul>
<li>Manuel Combarro Simón, Pierre Talbot, Grégoire Danoy, Jedrzej Musial, Mohammed Alswaitti, and Pascal Bouvry. <em>Constraint Model for the Satellite Image Mosaic Selection Problem.</em> CP 2023.</li>
<li>Talbot, Pierre, Frédéric Pinel, and Pascal Bouvry. <em>A Variant of Concurrent Constraint Programming on GPU.</em> AAAI 2022.</li>
<li>Talbot, Pierre, Éric Monfroy, and Charlotte Truchet. <em>Modular Constraint Solver Cooperation via Abstract Interpretation.</em> Theory and Practice of Logic Programming (2020).</li>
<li>Talbot, Pierre, David Cachera, Eric Monfroy, and Charlotte Truchet. <em>Combining Constraint Languages via Abstract Interpretation.</em> ICTAI 2019.</li>
</ul>
<h2 id="sponsors"><a class="header" href="#sponsors">Sponsors</a></h2>
<p>This project occurs in the context of the project COMOC (ref. C21/IS/16101289), 2021-2025.
We thank the Luxembourg National Research Fund (FNR) for this opportunity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turbo"><a class="header" href="#turbo">Turbo</a></h1>
<p>(For a concise introduction to GPU programming, you can check out my <a href="https://ulhpc-tutorials.readthedocs.io/en/latest/gpu/cuda2023/">tutorial</a> and go through the slides; it is especially useful to know the CUDA vocabulary).</p>
<p><em>30 August 2023.</em> Turbo is a constraint solver running entirely on the GPU with an architecture based on abstract domains.
Intuitively, due to their complex architecture and dynamic data structures, constraint solvers seem to be a poor match for GPUs.
Moreover, over the years, new solving techniques have been primarily developed within a sequential mindset, without consideration for parallel execution.
The most successful approach to parallel constraint solving is <em>embarrassingly parallel search</em> (EPS) where the problem is decomposed into many subproblems that are solved independently on different cores.
Although GPUs have thousands of cores, it is not reasonable to execute one subproblem per core.
The primary reason is that a single core does not have its own cache.
Cores are actually grouped in streaming multiprocessors (SMs), and all cores in one SM share the same cache (called L1 cache).
The L1 cache is only 256KB on the most recent NVIDIA Hopper GPUs (which I don't have).
A quick calculation shows why one subproblem per core is not a viable option.
Suppose the domain of a variable is represented by an interval (the lightest you can do, it is more often represented by a set of intervals), hence 8 bytes, a store of 1000 variables takes 8KB of memory.
Suppose an SM has 64 (integer) cores, then we need 64*8 = 512KB of cache to fit all the stores at once.
We should also store the propagators, and although the stateless propagators can be shared among subproblems, it easily takes up dozens of KB; memory that will not be available for the stores.
The threads will end up competing for the caches, and it will generate many memory transfers among the global memory, L2 cache and L1 cache.
Memory transfers are usually the most costly operation, hence you try to avoid (or hide) them in a GPU; loading data from the global memory is about 10x slower than from the L1 cache.
I am not saying it is impossible to do efficiently, but it seems quite complicated, especially when taking into account warps that are SIMD units of the GPUs (blocks of 32 threads), and thus must all have their data ready in the cache at the same time when executing.
This is a hypothesis based on intuition and discussion with GPU experts, but it has not been verified experimentally.</p>
<p>Instead of relying on a "one subproblem per core" design that is so commonly used in parallel constraint solvers, we can execute one subproblem per SM.
And parallelism within an SM is achieved by parallelizing propagation!
It is worth mentioning that no attempt to parallelize propagation resulted in a faster solver in comparison to simply parallelizing the search.
In fact, no modern solver parallelizes propagation.
Because most solvers are designed for CPU, it seems that adapting an existing solver to work on GPU is doomed to fail.
The design rationale of Turbo is to aim first at a <em>simple but correct</em> parallel design.</p>
<p>I write this technical journal to document my attempts to obtain an efficient GPU-based constraint solver named Turbo.
Moreover, because I like my life to be (too) complicated, Turbo is also based on abstract interpretation and implements so-called <em>abstract domains</em> which are mathematical generalizations of the representation of constraints.
Let's embark on this journey!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v101-unoptimized-turbo"><a class="header" href="#v101-unoptimized-turbo">v1.0.1: Unoptimized Turbo</a></h1>
<p><em>08 November 2023.</em> We start this adventure with a functional but slow GPU solver.
To make it work on the GPU, we had to simplify the architecture of mainstream CPU-based constraint solver in many regards.
Let's start with the current design decisions behind Turbo:</p>
<ul>
<li><em>Pure GPU</em>: From the beginning, we decided to develop Turbo entirely on the GPU, primarily to eliminate memory transfers between the CPU and GPU.
We are also forced to design each component with a parallel mindset.</li>
<li><em>Propagation</em>: The propagation loop is based on the very first AC1 algorithm: we simply take the first N propagators, run them in parallel, then take the next N propagators, and so on until they are all executed, where N is the number of cores available in the current block.
We repeat this operation in a fixed point loop until no change is detected anymore.
This implies we do not have a queue of propagators to be woken up or any notion of events in the solver.</li>
<li><em>Backtracking</em>: It is based on full recomputation, each time we backtrack, we re-apply all the decisions from the root node; actually, from the root of the current EPS subproblem being solved.</li>
<li><em>Embarrassingly parallel search</em>: We dynamically create subproblems that are explored individually by GPU blocks, hence the parallel propagation only happens inside one block.</li>
<li><em>Abstract domains</em>: The solver architecture is based on abstract domains which encapsulate solving algorithms dedicated to a particular constraint language, similarly to theories in SMT.
However, abstract domains are semantic objects while SMT theories are syntactic objects (and a formal connection exists between the two).
Our opinion is that abstract domains are closer to the actual implementation code than SMT theories.
Moreover, since a product of abstract domains is also an abstract domain, this framework offers promising perspectives for combining solving algorithms.</li>
<li><em>No conflict learning</em>: Conflicts require dynamic data structures to represent the implication graph, and memory allocation is quite costly on GPU, so we currently have no conflict learning.</li>
<li><em>Lock-free</em>: Although propagators are sharing the memory, we do not have locks on variables, and actually no lock at all (this is a lie: a single lock used for printing purposes).</li>
<li><em>Formally correct</em>: Parallel programming is hard and prone to bugs. The theory behind Turbo relies on lattice theory which enabled us to prove that our lock-free propagation loop is correct.</li>
</ul>
<p>We have thrown away many optimizations considered essential in mainstream CPU-based constraint solvers.
Incidentally, the GPU solver is simpler than a CPU solver, while obtaining similar performances; of course, when comparing to a pure CP solver without SAT learning.
Back in 2021, our hypothesis was that drastically simplifying the solver design was necessary to implement a GPU solver and that it could be efficient.
We implemented a <a href="https://github.com/ptal/turbo/tree/aaai2022">prototype (Turbo)</a> demonstrating it could work: we obtained similar performances between Turbo and Gecode (on a 6-cores CPU with 12 threads) on RCPSP.
More importantly, we laid out the theory behind parallel constraint propagation on GPU and show that, despite the absence of locks, it yielded correct results.
These findings were summarized in our <a href="http://hyc.io/papers/aaai2022.pdf">AAAI 2022 paper</a>.</p>
<p>For more than one year, I have been refactoring and extending this initial prototype in multiple ways.
One goal has been achieved now and Turbo can solve MiniZinc model with two limitations: for now, it only supports integer variables, and all global constraints are decomposed into primitive constraints.
The solver Turbo is part of a larger project called <em>Lattice Land</em>, which is a collection of libraries representing lattice data structures.
The long-term goal is to be able to reuse these libraries outside of constraint solving, for instance in static analysis by abstract interpretation and in distributed computing using CRDT.
The code of Turbo is the glue putting together the required libraries to solve a constraint problem.
The new <em>abstract domain</em> design comes with a price: it is less efficient than the prototype.
It was expected since the prototype could only handle a very small constraint language with limited architectural overhead.
I will try to integrate one by one various optimizations and attempt to first reach the previous efficiency, and then go beyond it.</p>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>To benchmark our progresses, I think it is reasonable to start with a set of easy instances (J30 benchmarks on RCPSP) and a set of harder instances (from MiniZinc competition 2022).
I have selected a subset of the MiniZinc competition benchmarks where I discarded models with set variables (unsupported by Turbo).
For a representative but quicker benchmarking, I selected 1 or 2 instances per problems, arbitrarily varying between small and large instances.
For RCPSP, I randomly selected 19 instances of the J30 dataset.
In the following table, I describe the problems of the benchmarking suite (<code>diffn</code> (1) indicates one occurrence of the global constraint, <code>alldifferent</code> (*) indicates the global constraint occurs in redundant or symmetry breaking constraints).</p>
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<ul>
<li>Wordpress: Assign software components to hardware units under some constraints.</li>
<li>ACCAP: Airport check-in counter allocation problem (ACCAP) with fixed opening/closing times.</li>
<li>Tower: Assign handsets to communication towers to maximize connection quality.</li>
<li>Team: Make teams of players to maximize happiness and balancing.</li>
<li>NFC: Network flow global constraint.</li>
<li>Diameterc-mst: Diameter Constrained Minimum Spanning Tree.</li>
<li>Stripboard: Layout for electrical components on stripboard: find the most compact layout.</li>
<li>Blocks world: Find a path of minimum length from an initial configuration to a final configuration of the puzzle.</li>
<li>Triangular: Puzzle.</li>
<li>Generalized-peacable Queens: A variant of n-queens with several armies of queens.</li>
<li>Roster Sickness: Assign employees to work shifts with expertise constraints.</li>
<li>GFD Schedule: Productions of group of items in various facilities.</li>
<li>RCPSP: Minimize makespan of tasks under resources constraints.</li>
<li>Spot 5: Select a subset of photograph to be taken maximizing a weight.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Problem</th><th>#Inst</th><th>Kind</th><th>Global Constraints</th><th>Shape</th></tr></thead><tbody>
<tr><td>Wordpress</td><td>1</td><td>Allocation</td><td>None</td><td>Many <code>sum()()</code>.</td></tr>
<tr><td>ACCAP</td><td>2</td><td>Allocation</td><td><code>diffn</code> (1)</td><td>Precedence constraints.</td></tr>
<tr><td>Tower</td><td>1</td><td>Allocation</td><td>None</td><td></td></tr>
<tr><td>Team Assignment</td><td>1</td><td>Allocation</td><td><code>bin_packing_load</code>, <code>alldifferent</code> (*), <code>bin_packing</code> (1*)</td><td>Sums of Boolean.</td></tr>
<tr><td>NFC</td><td>1</td><td>Graph</td><td><code>network_flow_cost</code></td><td>Equality/sum constraints.</td></tr>
<tr><td>Diameterc-mst</td><td>1</td><td>Graph</td><td>None</td><td>Many implications / disjunctions.</td></tr>
<tr><td>Stripboard</td><td>2</td><td>Packing</td><td><code>diffn</code> (1), <code>disjunctive</code> (1), <code>alldifferent</code> (1*), <code>strictly_decreasing</code> (1*)</td><td>Many implications.</td></tr>
<tr><td>Blocks world</td><td>1</td><td>Planning</td><td><code>increasing</code> (1), <code>global_cardinality_closed</code></td><td></td></tr>
<tr><td>Triangular</td><td>2</td><td>Puzzle</td><td>None</td><td>Sum constraints.</td></tr>
<tr><td>Generalized-peacable Queens</td><td>1</td><td>Puzzle</td><td><code>regular</code>, <code>global_cardinality</code> (1), <code>all_equal</code> (1), <code>value_precede_chain</code> (1*), <code>lex_lesseq</code> (*)</td><td>Almost only global constraints.</td></tr>
<tr><td>Roster Sickness</td><td>1</td><td>Scheduling</td><td>None</td><td>Lexicographic optimization.</td></tr>
<tr><td>GFD Schedule</td><td>1</td><td>Scheduling</td><td><code>cumulative</code>, <code>at_most</code>, <code>nvalue</code></td><td>Many implications / disjunctions.</td></tr>
<tr><td>RCPSP</td><td>18</td><td>Scheduling</td><td><code>cumulative</code></td><td>Precedence constraints, disjunctions.</td></tr>
<tr><td>Spot 5</td><td>1</td><td>Ad-hoc</td><td><code>table</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="analysis"><a class="header" href="#analysis">Analysis</a></h3>
<p>The primary goal of our initial benchmarking session is to gauge how Turbo measures up against contemporary, state-of-the-art constraint solvers (spoiler: there's room for improvement).
In order to assess the efficiency of Turbo, I compared it against Choco and Or-Tools:</p>
<ul>
<li><a href="https://github.com/ptal/turbo/tree/v1.0.1">Turbo</a> v1.0.1: C++/CUDA constraint solver without SAT clause learning and without global constraints.</li>
<li><a href="https://github.com/chocoteam/choco-solver">Choco</a> v4.10.13: Java constraint solver without SAT clause learning and with global constraints.</li>
<li><a href="https://github.com/google/or-tools">Or-Tools</a> v9.6: C++ constraint solver with SAT clause learning and global constraints.</li>
</ul>
<p>Since Turbo has no global constraint, I also benchmarked the two previous solvers on problem with decomposition of global constraints, named <code>choco.noglobal</code> and <code>or-tools.noglobal</code> below.
Turbo is developed to run on both CPU and GPU, although it is primarily optimized for GPU use.
We run on the CPU mainly for debugging and comparative efficiency analysis.</p>
<p>The machine on which I performed the benchmarks is a Dell Precision 5820 (desktop computer):</p>
<ul>
<li>CPU: Intel Core i9-10900X (3,7GHz, 4,7GHz Turbo, 10C, cache 19,25Mo, HT, 165W).</li>
<li>RAM: 64 Go, 2 x 32 Go, DDR4 UDIMM.</li>
<li>GPU: NVIDIA RTX A5000, 24Go, 64 streaming multiprocessors (8192 CUDA cores), 230W.</li>
</ul>
<p>About the details of the experiments:</p>
<ul>
<li>Timeout: 5 minutes per instance (it is relatively small in order to quickly iterate and test new optimizations of Turbo).</li>
<li>EPS (TurboGPU): generate 1024 subproblems (<code>-sub 10</code> for "2^10").</li>
</ul>
<p><em>Warning</em>: Before we start, let's get something straight: <em>the comparison between TurboGPU and other solver is relatively unfair.</em>
In particular, because of EPS, TurboGPU uses breadth-first search at the top of the tree, and thus sometimes can get better bounds, while the others use depth-first search and might stay stuck in the left part of the search tree longer.
In contrast, on some problems, depth-first search allows TurboCPU to find a better bound because it goes deeper in the search tree.
To be completely fair, we should enable parallelism for each solver since most of them support it.
We don't because when you run a race, you don't try to overtake the 1th runner when you are at the back of the race, you first focus on overtaking the runner in front of you ;-)</p>
<p>Alright, let's go with the benchmarks, the full Jupyter notebook is available <a href="https://github.com/ptal/turbo/blob/v1.0.1/benchmarks/analysis-v1.0.1.ipynb">here</a>.
We first start by an overview:</p>
<p><img src="turbo-v1.0.1/overall.png" alt="Status comparison" /></p>
<p>The overall results are not surprising.
When looking at Choco and Or-Tools, we might wonder if global constraints are worth the investment, especially when clause learning is activated (Or-Tools).
In the following, we take a closer look at Choco and Or-Tools:</p>
<p><img src="baseline/or-tools-vs-or-tools-noglobal.png" alt="OrTools vs OrTools.noglobal" />
<img src="baseline/choco-vs-choco-noglobal.png" alt="Choco vs Choco.noglobal" /></p>
<p>Here, we only compare the objective bounds and not the time needed to reach the best found objective.
Back to Turbo, let's compare it to our its CPU-version and the baseline solvers:</p>
<p><img src="turbo-v1.0.1/turbocpu-vs-turbogpu.png" alt="TurboCPU vs TurboGPU" />
<img src="turbo-v1.0.1/turbogpu-vs-ortools.png" alt="TurboGPU vs OrTools" />
<img src="turbo-v1.0.1/turbogpu-vs-ortools-noglobal.png" alt="TurboGPU vs OrTools.noglobal" />
<img src="turbo-v1.0.1/turbogpu-vs-choco.png" alt="TurboGPU vs Choco" />
<img src="turbo-v1.0.1/turbogpu-vs-choco-noglobal.png" alt="TurboGPU vs Choco.noglobal" /></p>
<p>For future references, it is interesting to have an average of some speed and memory metrics across all problems:</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Median</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>1246.77</td><td>35.07</td></tr>
<tr><td>Fixpoint iterations per second</td><td>10014.91</td><td>257.84</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.48</td><td>7.11</td></tr>
<tr><td>IDLE SMs at timeout</td><td>13</td><td></td></tr>
<tr><td>Propagators memory</td><td>16.41MB</td><td>13.07MB</td></tr>
<tr><td>Variables store memory</td><td>167.78KB</td><td>174.01KB</td></tr>
<tr><td>#Problems at optimality</td><td>5</td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>27</td><td></td></tr>
<tr><td>#Problems unknown</td><td>3</td><td></td></tr>
</tbody></table>
</div>
<p>When comparing the number of nodes per second, we can see that TurboGPU explores around 5 to 10 times more nodes per second than TurboCPU; showing a "purely computational gain" when using the GPU.
Just 5x to 10x quicker is actually not that much quicker considering we have 64 streaming multiprocessors, and indicate we are under-using the parallel capacities of the GPU.
In the future, I'll benchmark how efficiently Turbo is using the GPU using the profiling tools of NVIDIA.</p>
<p><img src="turbo-v1.0.1/number-of-nodes-per-second.png" alt="TurboGPU nodes per second" /></p>
<p>You might notice that on RCPSP, TurboCPU is actually better in terms of nodes per second.
The reason is that the number of subproblems is not large enough, and some streaming multiprocessors become IDLE because no more problems can be consumed.
On two problems, we have only one streaming multiprocessors working, meaning only 1/64 of the GPU is used at the end...
We need to improve the EPS algorithm and the decomposition into subproblems.</p>
<p><img src="turbo-v1.0.1/turbo-eps-nodes.png" alt="TurboGPU EPS" /></p>
<p>Finally, let's look at the fixpoint iterations.
On average, Turbo needs to execute each propagator 8 times before reaching a fixpoint, of course it depends on the problem:</p>
<p><img src="turbo-v1.0.1/number-of-fixpoint-iterations-per-node.png" alt="TurboGPU fixpoint iterations" /></p>
<p>To conclude this first benchmarking session, I found the results encouraging, especially when considering how primitive is the propagation loop.
I think two important missing optimizations are:</p>
<ol>
<li>Preprocessing in the root node, potentially root nodes of each subproblem, to reduce the number of constraints and variables, and avoid useless propagation.</li>
<li>Disable propagators that are entailed.</li>
</ol>
<p>See you next time for more benchmarking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v110-1-preprocessing"><a class="header" href="#v110-1-preprocessing">v1.1.{0-1}: Preprocessing</a></h1>
<p><em>27 December 2023.</em> A simple definition of <em>preprocessing</em> is to prepare the constraint problem hence it can be solved more efficiently by the underlying solver.
The goal of preprocessing is usually to eliminate fixed variables, eliminate satisfied constraints and simplify constraints, for instance by propagating the constants.
In the context of GPU, there is an additional incentive to preprocessing: reducing the memory footprint in order to store the problem in the shared memory (L2 cache).
For now, most of the problems are too large to be entirely stored in shared memory (store of variables and propagators), but the variables can be entirely stored in the shared memory for around 30% of the problems considered.
We have implemented a simple preprocessing class called <code>Simplifier</code> (in lala-core).
After propagating the root node, the preprocessor performs the following simplifications:</p>
<ol>
<li>Replace all assigned variables by the constant they are assigned to.</li>
<li>Create equivalence classes among variables (by detecting <code>x = y</code> constraints), select a representative variable in each class, and replace all occurrences of the variables in the equivalence classes by their representative variables.</li>
<li>Remove entailed constraints.</li>
</ol>
<p>The preprocessing algorithm is in theory suitable for parallel execution on GPU, but it is currently executed on the CPU.
The reason is that we want to reduce the problem size to store the variables in the shared memory.
But we must decide in which memory to put the variables before we start the GPU kernel; hence we would need to launch the preprocessing in a kernel, to return the data to the CPU and relaunch another kernel with the right shared memory size.
There is a solution using CUDA dynamic parallelism, but I did not take the time to explore it yet!</p>
<p>This simple preprocessing step doubles the raw efficiency of the solver as measured by the number of nodes explored per second.
Indeed, reducing the problem leads to fewer propagators that need to be executed, which is observed by a reduction of the number of iterations to reach a fixpoint (-14% on average).
But the additional speed is also explained by the variables store that has been cut by half on average and the propagators' memory decreased by 22%.
It reduces the pressure on the L1 and L2 caches and more problems can be stored in the shared memory; in our case, one more problem can be stored in shared memory when simplifying.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.0.1</th><th>Median</th><th>Δ v1.0.1</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>2379.95</td><td>+91%</td><td>611.27</td><td>+1742%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>12303.02</td><td>+23%</td><td>2273.83</td><td>+882%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>7.31</td><td>-14%</td><td>5.9</td><td>-17%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>13</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>12.65MB</td><td>-22%</td><td>7.79MB</td><td>-40%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>-57%</td><td>84.1KB</td><td>-52%</td></tr>
<tr><td>#Problems at optimality</td><td>10</td><td>5</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>27</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>3</td><td>3</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.0.1-vs-turbogpu-v1.1.0.png" alt="TurboGPU-v1.0.1 vs TurboGPU-v1.1.0" /></p>
<h2 id="v110b-increasing-the-number-of-subproblems"><a class="header" href="#v110b-increasing-the-number-of-subproblems">v1.1.0b Increasing the number of subproblems</a></h2>
<p>By default, the number of subproblems created is 1024 (2^10) (option <code>-sub 10</code>).
This choice is rather arbitrary, so I ran additional experiments to see if increasing that number could lead to better results.
The answer is that it is quite hard to choose a good generic number, but overall 4096 (2^12) subproblems gave better results and is the new default for the future versions.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.0</th><th>Median</th><th>Δ v1.1.0</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>2529.68</td><td>+6%</td><td>809.31</td><td>+32%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>12449.48</td><td>+1%</td><td>3306.37</td><td>+45%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>6.77</td><td>-7%</td><td>5.19</td><td>-12%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>7</td><td>9</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>12.65MB</td><td>0%</td><td>7.79MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.1KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>21</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>3</td><td>3</td><td></td><td></td></tr>
</tbody></table>
</div>
<p>In particular, we see that increasing the number of subproblems to 4096 contributes to a better average of nodes per second and to solving one more problem to optimality.
With more subproblems, the advantage is not as clear, but it is definitely an experiment to try again on future versions of Turbo.</p>
<p><img src="turbo-v1.1/turbogpu-v1.1.0-1024-vs-turbogpu-v1.1.0-4096.png" alt="TurboGPU-v1.1.0 vs TurboGPU-v1.1.0b" /></p>
<h2 id="v111-partial-evaluation"><a class="header" href="#v111-partial-evaluation">v1.1.1 Partial evaluation</a></h2>
<p>The version 1.1.1 brings partial evaluation of the logical formulas, essentially by aggregating constants and rewriting constraints with fewer operators.
We fully evaluate the expressions without variables, using distributivity laws for addition and multiplication (e.g. in <code>4 + x + 1</code> we evaluate <code>4 + 1</code>).
We apply some standard simplification laws:</p>
<ul>
<li>Propagating neutral and absorber elements (using identity and annihilator laws) of conjunction, disjunction, implication, equivalence, addition, subtraction, multiplication and division.</li>
<li>Eliminating double arithmetic and logical negations.</li>
</ul>
<p>We also have a bunch of rules to simplify constraints that are generated by the MiniZinc to FlatZinc conversion (let <code>eval</code> be a function evaluating the constant expressions):</p>
<ul>
<li>Detecting equalities: <code>x + (-y) == 0</code> is rewritten to <code>x == y</code>.</li>
<li>Detecting inequalities: <code>x + (-y) != 0</code> is rewritten to <code>x != y</code>.</li>
<li>Aggregating constants: <code>x + i != j</code> is rewritten to <code>x != eval(j - i)</code>.</li>
<li>Eliminating variable negation: <code>-x != j</code> is rewritten to <code>x != eval(-j)</code> (and similarly for <code>j != -x</code>).</li>
</ul>
<p>These rules could be generalized in the future.</p>
<p>This simple optimization leads to another big leap in the number of nodes per second and reduces significantly the memory footprint of propagators.
For the first time, there is a problem (nfc_24_4_2) that can be entirely stored in the shared memory (store of variables and propagators).
However, the impact of being entirely in the shared memory is not very impressive, with "only" 42% more nodes per second in comparison to v1.1.0b, knowing the average is at 62%.
We should validate experimentally if manually managing the shared memory is really worth it, or if the default caching policy of CUDA does a good enough job.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.0b</th><th>Median</th><th>Δ v1.1.0b</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>4087.42</td><td>+62%</td><td>976.72</td><td>+21%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>17837.83</td><td>+43%</td><td>3878.13</td><td>+17%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>6.79</td><td>+0.3%</td><td>5.17</td><td>-0.4%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>8</td><td>7</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>10.34MB</td><td>-18%</td><td>7.39MB</td><td>-5%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.1KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>3</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="overall-standing"><a class="header" href="#overall-standing">Overall standing</a></h2>
<p><img src="turbo-v1.1/overall-standing-v1.1.0.png" alt="Overall standing" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v112-disequality-propagator"><a class="header" href="#v112-disequality-propagator">v1.1.2: (Dis)equality Propagator</a></h1>
<p><em>07 March 2024.</em> When developing Turbo, I try to keep the number of propagators minimal as it reduces the code and eases the maintenance.
The propagators are represented in an abstract domain called <em>propagators completion</em> (PC) which is essentially an encapsulation of a traditional propagators-based constraint solver inside an abstract domain.
One of the peculiarities is that PC does not contain the store of variables but is parametrized by another abstract domain <code>A</code> that provides access to the variables.
<code>A</code> can be an array of integer intervals or bitsets, as seen in traditional constraint solver, but can be more complicated such as an octagon abstract domain.
This generic design also allows us to parametrize PC by the Cartesian product of any abstract domains, for instance to obtain mixed domains such as interval of integers and interval of floating-point numbers.
It means that we have a single propagator for the constraint <code>x + y &lt;= 10</code> where <code>x</code> is an integer variable and <code>y</code> a real variable; this is in theory because Turbo does not support floating-point variables yet.
The direct consequence of this abstraction is that we must develop generic propagator functions that do not know exactly the shape of the variables' domains.
To achieve that, I have a lattice-based propagator of the form <code>t &gt;= u</code> where <code>t</code> is any term (e.g. <code>x + y</code> or <code>S ∪ T</code>), <code>u</code> is a lattice element such as an interval and <code>&gt;=</code> is the associated lattice ordering.
Let <code>project(a, x)</code> be a function of the abstract domain <code>a</code> projecting the domain of the variable <code>x</code> and let's suppose the type of <code>project(a, x)</code> is the same as the type of <code>u</code>.
For instance, if I write <code>x + y &gt;= [0..5]</code>, it means that <code>project(a, x) + project(a, y)</code> should be included in the interval <code>[0..5]</code> according to the interval ordering.
From a logical perspective, it implements the constraints <code>x + y &gt;= 0</code> and <code>x + y &lt;= 5</code>.
Using some generic lattice operations (essentially projection, ordering and join operator), we can perform the propagation of this constraint.
If the underlying domain is an interval, it will achieve bound consistency, and if it is a bitset, it should achieve arc consistency; I say "should" because I did not formally prove that yet.</p>
<p>This lattice-based propagator is quite compact because it can represent many primitive constraints, for instance:</p>
<ul>
<li><code>x == y</code> is <code>x - y &gt;= [0..0]</code>.</li>
<li><code>x != y</code> is <code>x - y &gt;= [1.. ∞] \/ x - y &gt;= [-∞..-1]</code>.</li>
<li><code>x + y &gt;= 1</code> is <code>x + y &gt;= [1..∞]</code>.</li>
<li>...</li>
</ul>
<p>Therefore, we do not need one propagator per arithmetic comparison operator, but one propagator for all of them.
However, this minimalism is problematic for the disequality propagator which is represented by a disjunction.
Instead, we have implemented a dedicated propagator for disequality which does not rely on subtraction and disjunction.
By duality, this propagator can also be used for propagating equality which avoids a subtraction operation.
More fundamentally, for lattices that are pseudo-complemented (usually domains that support holes such as bitset), the disequality propagator is stronger than its disjunctive decomposition.</p>
<p>Interestingly, this propagator does not help to explore more nodes per second, but it finds better objective values for more problems (see the pie diagram below).
The number of nodes per second is due to an increase in the number of fixpoint iterations per nodes.
As the propagation strength between the two propagators should be the same (at least for intervals), I'm not sure why it takes more iterations to reach the fixpoint.
Finally, using these dedicated propagators reduces the propagators' memory in average, but the median increases.
The benchmarking set consists of many instances of the RCPSP problem, for which using these propagators increases the memory.
When discarding the RCPSP benchmarks, the median memory footprint of the propagators is actually reduced by a factor of 3, and the average memory is reduced by about 30%!
I'm unsure which constraints of the RCPSP model lead to this issue, but due to the limited impact I decided not to investigate.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.1</th><th>Median</th><th>Δ v1.1.1</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>3778.83</td><td>-8%</td><td>1049.48</td><td>+7%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>16935.39</td><td>-5%</td><td>3847.91</td><td>-1%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>7.34</td><td>+8%</td><td>5.16</td><td>0%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>8</td><td>8</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>-13%</td><td>8.08MB</td><td>+9%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.1.1-vs-turbogpu-v1.1.2.png" alt="TurboGPU-v1.1.1 vs TurboGPU-v1.1.2" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v113-warp-synchronization"><a class="header" href="#v113-warp-synchronization">v1.1.3: Warp Synchronization</a></h1>
<p><em>07 March 2024.</em> We increase by 15% the number of nodes per second by adding a single line of CUDA code.
The trick is to synchronize the warps in the fixpoint loop to reunite threads that have diverged.</p>
<p>In Turbo, the propagators are called "refinement operators" and are essentially monotone function over a lattice structure, we will use both terms interchangeably.
For instance, the octagon abstract domain consists of many small refinement operators implementing the Floyd-Warshall shortest path algorithm.
We compute the fixpoint of the refinement operators over the abstract domain <code>a</code> in a fixpoint loop.
For the curious, the loop in version 1.1.2 is implemented as:</p>
<pre><code class="language-cpp">for(size_t i = 1; changed[(i-1)%3] &amp;&amp; !is_top[(i-1)%3]; ++i) {
  size_t n = a.num_refinements();
  for (size_t t = group.thread_rank(); t &lt; n; t += group.num_threads()) {
    a.refine(t, changed[i%3]);
  }
  changed[(i+1)%3].dtell_bot(); // reinitialize changed for the next iteration.
  is_top[i%3].tell(a.is_top());
  is_top[i%3].tell(local::BInc{*stop});
  __syncthreads();
}
</code></pre>
<p>Depending on the number of available threads (<code>group.num_threads()</code>), the inner loop iterates the propagators array, refining the first N propagators, then the next N, and so on until all propagators have been executed once.
We keep iterating while at least one refinement operator changes <code>a</code>, and we did not reach an inconsistent state (<code>is_top</code>).</p>
<p>The optimization we introduce in v1.1.3 requires a bit of background explanations on CUDA.
Remember that each streaming multiprocessor (SM) is responsible for solving one subproblem (generated by an EPS-like strategy), thus the fixpoint loop is executed on one SM.
Each SM has 64 physical cores (A5000 GPU), so in theory at most 64 propagators are executed in parallel at the same time.
Similarly to CPU multithreading, it is usually more efficient to have more threads than cores in order to hide data transfer latency.
In Turbo, we obtained the best results by quadrupling the number of cores, to obtain 256 threads per SM.
This group of threads is called a <em>block</em>.
The CUDA scheduler is scheduling groups of 32 threads called <em>warps</em> instead of scheduling individual threads.
A block of 256 threads is thus made of 8 warps, and due to the number of cores, there are only 2 warps at any moment that are executed together.
When talking about GPU, it is common to hear that the GPU "can only execute in parallel the same instructions with different data" (SIMD parallelism).
But this is only true at the level of a warp, for 32 threads.
Two warps can execute completely different instructions without any penalty.
Now, let's look at what happens if two threads within a warp execute two different instructions.
Suppose <code>if c then P else Q</code> such that the condition is true for 5 threads and false for 27 threads, then the warp is split into two parts and <em>each part is executed sequentially</em>.
For the propagators, it happens quite often that 32 successive propagators are not exactly the same.
For instance, <code>x + y &lt;= k</code> and <code>x - y &lt;= k</code> would cause divergence due to the different arithmetic operators.
Even worst is <code>x * y &lt;= k</code> and <code>x * z &lt;= k</code> that can diverge due to interval multiplication which is not the same depending on the signs of the intervals' bounds.
In recent versions of CUDA, once threads have diverged, they are not merged back automatically.
It is only when encountering a barrier such as <code>__syncthreads()</code> that they are put back together.
The optimization in version 1.1.3 is to synchronize the threads of each warp (<code>__syncwarp()</code>) after each iteration of the inner loop:</p>
<pre><code class="language-cpp">for (size_t t = group.thread_rank(); t &lt; n; t += group.num_threads()) {
  a.refine(t, changed[i%3]);
  if((t-group.thread_rank()) + group.num_threads() &lt; n) __syncwarp();
}
</code></pre>
<p>It leads to better parallelism since at each iteration we start with the full warp of 32 threads and not a warp already split by a previous iteration.
The results show the efficiency of this approach.
Interestingly, it also shows that we need more iterations to reach the fixpoint, which might be due to the fact that the propagators are running in a different order due to <code>__syncwarp()</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.2</th><th>Median</th><th>Δ v1.1.2</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>4328.83</td><td>+15%</td><td>1240.06</td><td>+18%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>21347.57</td><td>+26%</td><td>6519.14</td><td>+69%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.60</td><td>+17%</td><td>5.31</td><td>+3%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>8</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>0%</td><td>8.08MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p>There are many possible optimizations to improve the efficiency of the fixpoint loop, in particular to avoid thread divergence.
I'm going next to try something very simple: to sort the propagators according to their structures, which should reduce divergence, we'll see!</p>
<p>The following pie charts show that the version v1.1.3 is strictly better than all others before, which validate the usefulness of our optimizations.</p>
<p><img src="turbo-v1.1/turbogpu-v1.1.2-vs-turbogpu-v1.1.3.png" alt="TurboGPU-v1.1.2 vs TurboGPU-v1.1.3" />
<img src="turbo-v1.1/turbogpu-v1.1.1-vs-turbogpu-v1.1.3.png" alt="TurboGPU-v1.1.1 vs TurboGPU-v1.1.3" />
<img src="turbo-v1.1/turbogpu-v1.1.0-vs-turbogpu-v1.1.3.png" alt="TurboGPU-v1.1.0 vs TurboGPU-v1.1.3" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v114-5-sorting-propagators"><a class="header" href="#v114-5-sorting-propagators">v1.1.{4-5}: Sorting Propagators</a></h1>
<p><em>28 August 2024.</em> We perform two experiments to reduce thread divergence by sorting propagators, for the reasons mentioned in the <a href="5-turbo.html">previous post</a>.
Given a list of propagators representing constraints, we sort on the syntactic shape of the constraint:</p>
<ul>
<li>v1.1.4: Sort on the symbol of the outermost predicate of the formula, e.g. <code>x &lt; y</code> is equal to <code>z + y &lt; x * x</code>, but less than <code>x &lt;= y</code> for an arbitrary ordering between &lt; and &lt;=.</li>
<li>v1.1.5: Lexicographic sort on the first predicate symbol followed by the length of the formula, e.g. <code>length(x &lt; y) = 2 &lt; 3 = length(z + y &lt; x * x)</code>.</li>
</ul>
<p>These are quite simple solutions to reduce divergence while avoiding spending too much time on a sorting algorithm specialized to minimize divergence.
The results are not impressive, and it shows that thread divergence is perhaps not the biggest bottleneck of Turbo.
Nevertheless, given how cheap this optimization is, I decided to keep it.
Note that on some benchmarks where the propagators are very unsorted (e.g. <code>gfd_schedule</code>), sorting increases by 50% the number of nodes explored.</p>
<h2 id="results-v114"><a class="header" href="#results-v114">Results v1.1.4</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.3</th><th>Median</th><th>Δ v1.1.3</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>4439.68</td><td>+3%</td><td>1236.87</td><td>0%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>21659.62</td><td>+1%</td><td>6492.20</td><td>0%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.69</td><td>+1%</td><td>5.07</td><td>-5%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>9</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>0%</td><td>8.08MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.1.3-vs-turbogpu-v1.1.4.png" alt="TurboGPU-v1.1.3 vs TurboGPU-v1.1.4" /></p>
<h2 id="results-v115"><a class="header" href="#results-v115">Results v1.1.5</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.3</th><th>Median</th><th>Δ v1.1.3</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>4513.37</td><td>+4%</td><td>1243.61</td><td>0%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>21787.61</td><td>+2%</td><td>6612.26</td><td>+1%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.50</td><td>-1%</td><td>5.38</td><td>+1%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>9</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>0%</td><td>8.08MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.1.3-vs-turbogpu-v1.1.5.png" alt="TurboGPU-v1.1.3 vs TurboGPU-v1.1.5" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v116-sharing-propagators"><a class="header" href="#v116-sharing-propagators">v1.1.6: Sharing Propagators</a></h1>
<p><em>28 August 2024.</em> Each subproblem is currently solved independently in a CUDA block, and the solver state is duplicated on each block.
The propagators are never modified during solving and thus, can safely be shared among the blocks.
Considering the propagators consume on average 9MB (hence 64*9 = 576MB for all blocks) and the L2 cache is only 4MB (on my A5000 card), the data transfers between the global memory and the L2 cache only because of the propagators are quite intense.
In version 1.1.6, I share the propagators among the blocks using a new pointer type called <code>root_ptr</code> (from <a href="https://github.com/lattice-land/cuda-battery">cuda-battery</a>).
A more classical <code>shared_ptr</code> is not safe to use to share data among blocks because the references counter is not protected against concurrent accesses, which can happen when two blocks call the copy constructor or the destructor of the shared pointer at the same time.
And this can lead to a segmentation fault.
The new <code>root_ptr</code> consider that the first owner of the pointer is the one that will also destroy it, which has the advantage of not required a references counter.
Of course, it is the responsibility of the programmer to delete the pointer after all blocks have terminated.</p>
<p>Once again, and similarly to the version 1.1.5, the improvement is not as great as expected with only 5% more nodes explored on average.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.5</th><th>Median</th><th>Δ v1.1.5</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>4758.85</td><td>+5%</td><td>1287.70</td><td>+4%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>23376.47</td><td>+7%</td><td>7228.01</td><td>+9%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.74</td><td>+3%</td><td>5.39</td><td>0%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>9</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>0%</td><td>8.08MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.1.5-vs-turbogpu-v1.1.6.png" alt="TurboGPU-v1.1.5 vs TurboGPU-v1.1.6" /></p>
<h2 id="v117-changing-the-eps-search-strategy-bonus"><a class="header" href="#v117-changing-the-eps-search-strategy-bonus">v1.1.7: Changing the EPS Search Strategy (Bonus)</a></h2>
<p>For fun and profits, I try to change the EPS search strategy to improve the benchmarks in a cheap and easy way.
It happens that selecting the smallest value of the smallest domain (first-fail) is a bit better than performing a bisection.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Average</th><th>Δ v1.1.6</th><th>Median</th><th>Δ v1.1.6</th></tr></thead><tbody>
<tr><td>Nodes per seconds</td><td>4527.37</td><td>-5%</td><td>1287.14</td><td>0%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>25015.74</td><td>+7%</td><td>7100.85</td><td>-2%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>8.93</td><td>+2%</td><td>5.39</td><td>0%</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>9</td><td>9</td><td></td><td></td></tr>
<tr><td>Propagators memory</td><td>9.01MB</td><td>0%</td><td>8.08MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>72.29KB</td><td>0%</td><td>84.10KB</td><td>0%</td></tr>
<tr><td>#Problems at optimality</td><td>11</td><td>11</td><td></td><td></td></tr>
<tr><td>#Problems satisfiable</td><td>22</td><td>22</td><td></td><td></td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td><td></td><td></td></tr>
<tr><td>#Problem with store in shared memory</td><td>10</td><td>10</td><td></td><td></td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.1/turbogpu-v1.1.6-vs-turbogpu-v1.1.7.png" alt="TurboGPU-v1.1.6 vs TurboGPU-v1.1.7" /></p>
<h2 id="summary-v11"><a class="header" href="#summary-v11">Summary v1.1</a></h2>
<p>The CUDA optimizations performed in the versions 1.1.* did not help to get amazing gain in performance.
The best optimization was the preprocessing of the problem (v1.1.1) which has actually nothing to do with GPUs.</p>
<p>After a quick chat with Nvidia engineers that could have a look at a profiling report of Turbo, we identified that the main bottleneck is the high number of registers needed by each block.
Turbo is a full application with thousands of lines of code and the call to a single propagator is deep in the functions stack.
When the first version of Turbo was developed for the AAAI-2022 paper, it was very simple in terms of capabilities and could only manage scheduling problems.
We now manage any kind of discrete constraints, and the solver is based on <em>abstract interpretation</em>, the abstract domain architecture has a cost due to various abstractions.
Before we reach the code required for a thread to execute a propagator, we find many local variables on the way that might need to be stored in register.
Clearly, the code is not suited at all for a GPU architecture, it could even be surprising it works "that well".</p>
<p>In the next versions 1.2.*, we are going to focus on splitting the kernel into smaller kernels, perhaps doing the search on the CPU and only the propagation loop on the GPU.
Doing it all on the GPU was mainly to reduce data transfers, but clearly, with only 4527 nodes explored per second, the data bandwidth is far from being the bottleneck.</p>
<p><img src="turbo-v1.1/overall-standing-v1.1.png" alt="Overall Standing v1.1" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v120-refactoring"><a class="header" href="#v120-refactoring">v1.2.0: Refactoring</a></h1>
<p><em>21 September 2024.</em> Version 1.2 introduces a significant refactoring. Previously, the system operated using a lattice ordering where computations began from bottom and progressed upwards. This resulted in lattices being reversed compared to both abstract interpretation and the conventional ordering in lattice theory, such as with the interval lattice, where bottom typically represents the empty interval. All lattices now follow the standard ordering. Turbo now aligns more closely with the abstract satisfaction framework and terminology as presented by D’Silva et al. in their 2014 paper, <a href="https://dl.acm.org/doi/pdf/10.1145/2535838.2535868">Abstract Satisfaction</a>, published at the POPL conference.</p>
<p>Another issue addressed in this update is the incorrect handling of multiplication and division over infinite intervals.
While this feature hadn’t been used in prior experiments, resolving it proved non-trivial.
It is now sound, although the consistency could be stronger.
For instance, I haven’t yet established the rules for dividing by infinity, so the result is currently overapproximated to top. You can find the full changelog <a href="https://github.com/ptal/turbo/releases/tag/v1.2.0">here</a>.</p>
<p>Starting with this release, we’ve removed RCPSP instances from the experimental dataset to avoid skewing the metrics.
We continue to track the number of nodes processed per second.
Thibault, a postdoc on the team, mentioned that this was the first time he had encountered anyone monitoring this particular metric, so I’d like to explain its importance.
This metric allows us to compare solvers that are similar in terms of constraint consistency, yet differ in terms of algorithms and optimizations.
As noted in earlier posts, some optimizations, such as sharing or sorting propagators, have little to do with constraint programming itself.
In these cases, comparing the number of nodes explored per second provides valuable insights.
However, it doesn’t make sense to compare nodes-per-second between Choco and OrTools, as their underlying algorithms are different.
For now, we’ll continue evaluating this metric across different Turbo versions.
To better assess the impact of optimizations, we’re also calculating the normalized average, which, in hindsight, should have been implemented from the start, given that nodes-per-second can vary widely between problems.</p>
<p>Overall, we observed a 7% improvement in exploration speed, with performance dips in only four problems.
For the WordPress instance, we noted a small decrease in nodes processed, from 91775 to 86468, which accounts for the lower objective.
For ACCAP (a40_f800), the objectives found are very close (2549 vs. 2545), and after rerunning the problem on a laptop, we obtained an objective of 2542, which we’ll attribute to (insignificant) machine fluctuations.
The median nodes-per-second metric decreased by 17%, but after closer inspection, the only substantial drop occurred in the triangular/n39.dzn problem, where the nodes-per-second decreased from 828,963 to 686,341.
This is because this problem happens to sit at the midpoint of the distribution.</p>
<p>The number of fixpoint iterations per node increased slightly (+4%) on average, likely due to the 16% rise in the number of propagators.
The increase in propagators is due to the removal of the "lattice propagator" mentioned in v1.1.2, it did not prove as useful as expected.
However, the number of fixpoint iterations is compensated by an 11% increase in the number of iterations per second, so overall efficiency has improved.
In conclusion, the refactoring has positively impacted efficiency in terms of nodes-per-second, without significantly affecting the quality of objective bounds.</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.1.7</th><th>#best (_/15)</th><th>Average</th><th>Δ v1.1.7</th><th>Median</th><th>Δ v1.1.7</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>97.45</td><td>+7%</td><td>11</td><td>10846.81</td><td>+21%</td><td>2287.35</td><td>-17%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>98.33</td><td>+11%</td><td>13</td><td>61386.99</td><td>+23%</td><td>27328.03</td><td>+15%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>99.18</td><td>+4%</td><td>4</td><td>14.67</td><td>+3%</td><td>8.59</td><td>+7%</td></tr>
<tr><td>Propagators memory</td><td>99.50</td><td>+16%</td><td>2</td><td>10.97MB</td><td>+16%</td><td>4.30MB</td><td>+34%</td></tr>
<tr><td>Variables store memory</td><td>99.97</td><td>0%</td><td>1</td><td>51.43KB</td><td>0%</td><td>6.74KB</td><td>0%</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Count</th><th>Δ v1.1.7</th></tr></thead><tbody>
<tr><td>#Problems at optimality</td><td>0</td><td>0</td></tr>
<tr><td>#Problems satisfiable</td><td>13</td><td>13</td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td></tr>
<tr><td>#Problem with store in shared memory</td><td>9</td><td>9</td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>2</td><td>1</td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.2/turbogpu-v1.1.7-vs-turbogpu-v1.2.0.png" alt="TurboGPU-v1.1.7 vs TurboGPU-v1.2.0" /></p>
<h2 id="shared-memory-vs-global-memory"><a class="header" href="#shared-memory-vs-global-memory">Shared Memory vs Global Memory</a></h2>
<p>On GPUs, each streaming multiprocessor has an L1 cache, which is extremely fast but relatively small (around 100KB, depending on the GPU model).
A portion of the L1 cache, known as shared memory, can be reserved to store frequently accessed data, reducing the need for roundtrips between L1 cache, L2 cache, and global memory.</p>
<p>In our case, there are seven problems where the variable store can be held in shared memory, and one additional problem where both the propagators and the variables store can fit in shared memory.
Implementing this optimization is complex, as it requires using C++-templates for all data structures with the memory allocator's type.</p>
<p>The key question is: does this optimization improve efficiency?
To find out, we ran experiments on these seven problems, comparing the performance of Turbo with shared memory optimization against a version of Turbo that uses global memory exclusively (v1.2.0-gmem).</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.0-gmem</th><th>#best (_/7)</th><th>Average</th><th>Δ v1.2.0-gmem</th><th>Median</th><th>Δ v1.2.0-gmem</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>100.00</td><td>+5%</td><td>7</td><td>19068.33</td><td>+4%</td><td>22729.96</td><td>+5%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>100.00</td><td>+4%</td><td>7</td><td>109048.09</td><td>+4%</td><td>58060.52</td><td>+3%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>99.76</td><td>0%</td><td>4</td><td>6.16</td><td>0%</td><td>5.38</td><td>0%</td></tr>
<tr><td>Propagators memory</td><td>100.00</td><td>0%</td><td>0</td><td>7.07MB</td><td>0%</td><td>0.63MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>100.00</td><td>0%</td><td>0</td><td>4.98KB</td><td>0%</td><td>4.22KB</td><td>0%</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Count</th><th>Δ v1.2.0-gmem</th></tr></thead><tbody>
<tr><td>#Problems at optimality</td><td>0</td><td>0</td></tr>
<tr><td>#Problems satisfiable</td><td>6</td><td>6</td></tr>
<tr><td>#Problems unknown</td><td>1</td><td>1</td></tr>
<tr><td>#Problem with store in shared memory</td><td>6</td><td>0</td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>0</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>0.0</td><td>0.0</td></tr>
</tbody></table>
</div>
<p>Using shared memory consistently improved the number of nodes processed per second on these problems, and there were no cases where performance was negatively affected.
But honestly, +5% was hardly worth the troubles of programming with allocators.
That said, it's possible that the benefits of this optimization are being overshadowed by other GPU-related issues, such as the high number of registers in use.
We plan to benchmark it again in the future to determine whether it delivers a more substantial performance boost.</p>
<h2 id="the-impact-of-atomics"><a class="header" href="#the-impact-of-atomics">The Impact of Atomics</a></h2>
<p>For correctness, every integer load and store operation must be wrapped in an atomic transaction.
Without this, there's a risk that one thread could write to the first two bytes of an integer while another thread writes to the last two, leading to corrupted data.
But what happens if we transgress the rule and remove atomics?
To explore this, we address two questions: are the results still correct without atomics, and what is the performance cost of using them?</p>
<p>In terms of raw efficiency, the number of nodes explored per second increased by 13%, which is an interesting gain.
Additionally, we didn’t encounter any bugs—all the results were correct.
This suggests one of two possibilities: either 32-bit integer loads and stores are inherently atomic on this hardware, or race conditions are so rare that they weren’t detected, even after several hours of computation.
Since we can’t be sure, we have to adhere to the formal CUDA semantics, and therefore keep atomics to guarantee correctness!</p>
<div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Normalized average [0,100]</th><th>Δ v1.2.0</th><th>#best (_/15)</th><th>Average</th><th>Δ v1.2.0</th><th>Median</th><th>Δ v1.2.0</th></tr></thead><tbody>
<tr><td>Nodes per second</td><td>100.00</td><td>+13%</td><td>15</td><td>12146.40</td><td>+12%</td><td>2680.12</td><td>+17%</td></tr>
<tr><td>Fixpoint iterations per second</td><td>99.52</td><td>+13%</td><td>14</td><td>74963.50</td><td>+22%</td><td>30621.28</td><td>+12%</td></tr>
<tr><td>Fixpoint iterations per node</td><td>96.84</td><td>0%</td><td>7</td><td>15.24</td><td>+4%</td><td>8.74</td><td>+2%</td></tr>
<tr><td>Propagators memory</td><td>100.00</td><td>0%</td><td>0</td><td>10.97MB</td><td>0%</td><td>4.30MB</td><td>0%</td></tr>
<tr><td>Variables store memory</td><td>100.00</td><td>0%</td><td>0</td><td>51.43KB</td><td>0%</td><td>6.74KB</td><td>0%</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Metrics</th><th>Count</th><th>Δ v1.2.0</th></tr></thead><tbody>
<tr><td>#Problems at optimality</td><td>0</td><td>0</td></tr>
<tr><td>#Problems satisfiable</td><td>13</td><td>13</td></tr>
<tr><td>#Problems unknown</td><td>2</td><td>2</td></tr>
<tr><td>#Problem with store in shared memory</td><td>9</td><td>9</td></tr>
<tr><td>#Problem with prop in shared memory</td><td>1</td><td>1</td></tr>
<tr><td>#Problems with IDLE SMs at timeout</td><td>2</td><td>2</td></tr>
</tbody></table>
</div>
<p><img src="turbo-v1.2/turbogpu-v1.2.0-vs-turbogpu-v1.2.0-noatomics.png" alt="TurboGPU-v1.2.0 vs TurboGPU-v1.2.0-noatomics" /></p>
<h2 id="more-benchmarks"><a class="header" href="#more-benchmarks">More Benchmarks</a></h2>
<p>We did additional benchmarks to run OrTools and Choco in parallel, Choco with Java11 and Java22, and Turbo on CPU.</p>
<p><img src="turbo-v1.2/overall-standing-v1.2.0.png" alt="Overall Standing v1.2.0" /></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: right">Average nodes-per-second</th><th style="text-align: right">#Problems at optimality</th><th style="text-align: right">#Problems SAT</th><th style="text-align: right">#Problems unknown</th></tr></thead><tbody>
<tr><td style="text-align: left">ortools_9.9_20threads</td><td style="text-align: right">-</td><td style="text-align: right">13</td><td style="text-align: right">2</td><td style="text-align: right">0</td></tr>
<tr><td style="text-align: left">ortools_9.9</td><td style="text-align: right">13453.8</td><td style="text-align: right">10</td><td style="text-align: right">4</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">ortools.noglobal_9.9</td><td style="text-align: right">15035.4</td><td style="text-align: right">9</td><td style="text-align: right">5</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15_10threads</td><td style="text-align: right">26081.2</td><td style="text-align: right">7</td><td style="text-align: right">7</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15_java11_10threads</td><td style="text-align: right">21082.7</td><td style="text-align: right">7</td><td style="text-align: right">7</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15_20threads</td><td style="text-align: right">9564.2</td><td style="text-align: right">5</td><td style="text-align: right">9</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15_java11_20threads</td><td style="text-align: right">12708.8</td><td style="text-align: right">4</td><td style="text-align: right">10</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15</td><td style="text-align: right">11527.6</td><td style="text-align: right">2</td><td style="text-align: right">12</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">choco_4.10.15_java11</td><td style="text-align: right">10459.6</td><td style="text-align: right">2</td><td style="text-align: right">12</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: left">turbo.gpu_1.2.0_4096_64_256_noatomics</td><td style="text-align: right">12146.4</td><td style="text-align: right">0</td><td style="text-align: right">13</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.gpu_1.2.0_4096_64_256</td><td style="text-align: right">10846.8</td><td style="text-align: right">0</td><td style="text-align: right">13</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.gpu_1.1.7_4096_64_256</td><td style="text-align: right">8997.1</td><td style="text-align: right">0</td><td style="text-align: right">13</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: left">turbo.cpu_1.2.0</td><td style="text-align: right">3673.46</td><td style="text-align: right">0</td><td style="text-align: right">13</td><td style="text-align: right">2</td></tr>
</tbody></table>
</div>
<p>The version of Java plays a significant role in performance, showing a speedup of 10% to 25% when moving from Java 11 to Java 22, which is now the default version for our experiments.
Interestingly, Choco doesn't handle excessive threading well-one thread per core consistently outperforms two threads per core.</p>
<p>The sequential CPU version of Turbo isn't performing too badly, exploring 3673 nodes per second.
With this in mind, it's reasonable to target a similar rate per streaming multiprocessor (SM) on the GPU.
Given that we have 64 SMs, we should aim to reach at least 235k nodes per second overall.</p>
<p>Improving this metric will be the primary focus for future 1.2.* versions.</p>
<h2 id="roadmap-for-12"><a class="header" href="#roadmap-for-12">Roadmap for 1.2.*</a></h2>
<p>The full GPU design is approaching its limits as the code has grown significantly.
After discussions with Nvidia engineers, who are partners in the COMOC project, it appears that the primary inefficiency may be due to the excessive number of registers used.
Here’s the plan moving forward:</p>
<ol>
<li>Implement a parallel version of the CPU-based Turbo.</li>
<li>Replace the CPU-based propagation with GPU-based propagation using the parallel version.</li>
<li>Limit memory transfers, if they become a bottleneck, by transferring only the variables involved in the search strategy.</li>
<li>Improve the propagators abstract domain to disable entailed propagators.</li>
<li>Minimize thread divergence by applying a binary decomposition to all constraints.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-hackathon"><a class="header" href="#open-hackathon">Open Hackathon</a></h1>
<p><em>17 October 2024</em> We are participating in the <a href="https://www.openhackathons.org/s/siteevent/a0C5e000009W8MqEAK/se000307?p=4OVal7qBAY6%2FFLWHyETbkwh66SClhyelBl79%2FR1tID1ERZR9ly9oZEseBU%2B%2FQOAe%2B1PJ%2BAdY%2F%2F62bDJM0SlZYg%3D%3D">Poland Open Hackathon</a>.
This page will summarize our progresses and experience.
The hackathon is spread over 2 weeks starting by a meeting on 15 October to explain the GH200 architecture that equip the <a href="https://www.cyfronet.pl/en/19951,artykul,helios_supercomputer.html">Helios HPC</a>, how to connect and run jobs on it, and then discuss with our mentors.
Among the mentors, we are lucky to have an engineer from Nvidia working on <a href="https://developer.nvidia.com/blog/record-breaking-nvidia-cuopt-algorithms-deliver-route-optimization-solutions-100x-faster/">cuOpt</a> and a new secret <a href="https://developer.nvidia.com/blog/accelerate-large-linear-programming-problems-with-nvidia-cuopt/">linear programming solver</a>.
During the meeting, I try to compile Turbo on the HPC and... boom, <code>nvcc</code> is killed by the memory manager because it is using too much memory.
I encountered a similar problem last year and reported the bug to Nvidia.
The bug is still opened, but by adding <code>__noinline__</code> attributes in key places, I could work around it and compile it.
It seems that for <code>sm_90</code> architectures, the compiler is again doing very aggressive optimizations, and Turbo is just too large for it.
By putting the full solver in a single kernel, we avoid the memory transfers between the CPU and GPU, but even when the code is compiling, the bottleneck is the high number of registers per thread and the size of the kernel.
The next meeting is on 22 October, for the whole day.
Without a code that is compiling, it is going to be hard to profile and optimize anything...
After a few days, I managed to develop a new hybrid algorithm where only the propagation loop is on the GPU, and the search is on the CPU.
It is now compiling fine on Helios.
This is the version 1.2.1 of Turbo, against which we will compare the progresses made during this Hackathon.</p>
<h2 id="turbo-v121-hybrid-dive-and-solve-algorithm"><a class="header" href="#turbo-v121-hybrid-dive-and-solve-algorithm">Turbo v1.2.1: Hybrid Dive and Solve Algorithm</a></h2>
<p>If you don't know the "propagate-and-search" algorithm of constraint programming, please watch <a href="http://hyc.io/videos/aaai2022.mp4">this video</a> I made for a conference (thanks Covid), starting at 5'30''.
It also explains how this algorithm is executed on parallel on GPU.</p>
<p>We keep the same algorithm as full-GPU Turbo but only performs the propagation on the GPU.
The algorithm consists of two parts:</p>
<ol>
<li><code>dive(root, path)</code>: From the root of the search tree, commit to the path given to reach a node <code>subroot</code> at a fixed depth.</li>
<li><code>solve(subroot)</code>: Solve the subproblem <code>subroot</code> by propagate and search.</li>
<li>When a subproblem has been completely explored, we take a new path to explore if any is left.</li>
</ol>
<p>During the dive and solve operations, the propagation step is always executed on the GPU, by calling a kernel parametrized with a single block.</p>
<p>To execute this algorithm on multiple blocks, we create <code>N</code> CPU threads that will explore in parallel different <code>path</code> and solve different subproblems.
The file <code>https://github.com/ptal/turbo/blob/v1.2.1/include/hybrid_dive_and_solve.hpp</code> documents this algorithm in more detail.</p>
<p>... benchmarks result on Helios and on my desktop to compare to come...</p>
<h2 id="how-to-compile-and-run-turbo-on-helios"><a class="header" href="#how-to-compile-and-run-turbo-on-helios">How to compile and run Turbo on Helios</a></h2>
<p>First, download the project and its dependencies:</p>
<pre><code>mkdir lattice-land
cd lattice-land
git clone git@github.com:NVIDIA/cccl.git
git clone git@github.com:xcsp3team/XCSP3-CPP-Parser.git
git clone git@github.com:ptal/cpp-peglib.git
git clone git@github.com:lattice-land/cuda-battery.git
git clone git@github.com:lattice-land/lala-core.git
git clone git@github.com:lattice-land/lattice-land.github.io.git
git clone git@github.com:lattice-land/lala-pc.git
git clone git@github.com:lattice-land/lala-power.git
git clone git@github.com:lattice-land/lala-parsing.git
git clone git@github.com:lattice-land/.github.git
git clone --recursive git@github.com:lattice-land/bench.git
git clone --recursive git@github.com:ptal/turbo.git
</code></pre>
<p>Next, go on the Helios branch of Turbo:</p>
<pre><code>cd lattice-land/turbo
git checkout helios
</code></pre>
<p>To compile:</p>
<pre><code>sbatch compile-helios.sh helios.sh
</code></pre>
<p>And to run on an example:</p>
<pre><code>sbatch run-helios.sh helio.sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>The lattice land project is developed at the University of Luxembourg by a wonderful team:</p>
<ul>
<li><a href="http://hyc.io">Pierre Talbot</a>, research scientist.</li>
<li><a href="https://www.uni.lu/snt-en/people/thibault-falque/">Thibault Falque</a>, postdoctoral researcher.</li>
<li><a href="https://www.uni.lu/fstm-en/people/yi-nung-tsao/">Yi-Nung Tsao</a>, PhD candidate.</li>
</ul>
<img src="pierre.jpg" alt="isolated" width="180" style="border-radius: 50%;"/>
<img src="thibault.jpg" alt="isolated" width="180" style="border-radius: 50%;"/>
<img src="yinung.jpg" alt="isolated" width="180" style="border-radius: 50%;"/>
<h2 id="our-sponsors"><a class="header" href="#our-sponsors">Our Sponsors</a></h2>
<p>This project occurs in the context of the project COMOC (ref. C21/IS/16101289), 2021-2025.
We thank the Luxembourg National Research Fund (FNR) for this opportunity.</p>
<img src="FNR.png" alt="isolated" width="300"/>
<img src="unilu.svg" alt="isolated" width="200"/>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
