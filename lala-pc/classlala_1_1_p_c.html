<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice land propagators completion library: lala::PC&lt; A, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lattice land propagators completion library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classlala_1_1_p_c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlala_1_1_p_c-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lala::PC&lt; A, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="pc_8hpp_source.html">pc.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_p_c_1_1interpreted__type.html">interpreted_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlala_1_1_p_c_1_1snapshot__type.html">snapshot_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a176f99e59ee2c29d8f4bc4bab672e3fc" id="r_a176f99e59ee2c29d8f4bc4bab672e3fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a176f99e59ee2c29d8f4bc4bab672e3fc">sub_type</a> = A</td></tr>
<tr class="separator:a176f99e59ee2c29d8f4bc4bab672e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b447c428d8003a9ccea091230303a8" id="r_a65b447c428d8003a9ccea091230303a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a65b447c428d8003a9ccea091230303a8">universe_type</a> = typename A::universe_type</td></tr>
<tr class="separator:a65b447c428d8003a9ccea091230303a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad80287a2bb1dbf74270d8b24deec861" id="r_aad80287a2bb1dbf74270d8b24deec861"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> = Allocator</td></tr>
<tr class="separator:aad80287a2bb1dbf74270d8b24deec861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb0fe6062ff62a2cde6962902a534f3" id="r_a3fb0fe6062ff62a2cde6962902a534f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a> = typename A::allocator_type</td></tr>
<tr class="separator:a3fb0fe6062ff62a2cde6962902a534f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a40be7ccc8955bfd5475bfd7a20a7d" id="r_ae7a40be7ccc8955bfd5475bfd7a20a7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> = <a class="el" href="classlala_1_1_p_c.html">PC</a>&lt; <a class="el" href="classlala_1_1_p_c.html#a176f99e59ee2c29d8f4bc4bab672e3fc">sub_type</a>, <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &gt;</td></tr>
<tr class="separator:ae7a40be7ccc8955bfd5475bfd7a20a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9efdcb9d42e5808d8b1350c01f81ac" id="r_aec9efdcb9d42e5808d8b1350c01f81ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aec9efdcb9d42e5808d8b1350c01f81ac">sub_ptr</a> = abstract_ptr&lt; <a class="el" href="classlala_1_1_p_c.html#a176f99e59ee2c29d8f4bc4bab672e3fc">sub_type</a> &gt;</td></tr>
<tr class="separator:aec9efdcb9d42e5808d8b1350c01f81ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a91532a01a881e2ee99bbc46ea1dec" id="r_af8a91532a01a881e2ee99bbc46ea1dec"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:af8a91532a01a881e2ee99bbc46ea1dec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a> = <a class="el" href="structlala_1_1_p_c_1_1interpreted__type.html">interpreted_type</a>&lt; Alloc2, typename sub_type::template <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &gt;</td></tr>
<tr class="separator:af8a91532a01a881e2ee99bbc46ea1dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f8b2ca2c7096a75d9a140e37e7afa" id="r_a113f8b2ca2c7096a75d9a140e37e7afa"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a113f8b2ca2c7096a75d9a140e37e7afa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a113f8b2ca2c7096a75d9a140e37e7afa">ask_type</a> = <a class="el" href="structlala_1_1_p_c_1_1interpreted__type.html">interpreted_type</a>&lt; Alloc2, typename sub_type::template <a class="el" href="classlala_1_1_p_c.html#a113f8b2ca2c7096a75d9a140e37e7afa">ask_type</a>&lt; Alloc2 &gt; &gt;</td></tr>
<tr class="separator:a113f8b2ca2c7096a75d9a140e37e7afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb68ff37c16a8f59159054db6dfc70f" id="r_aadb68ff37c16a8f59159054db6dfc70f"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:aadb68ff37c16a8f59159054db6dfc70f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aadb68ff37c16a8f59159054db6dfc70f">iresult_tell</a> = IResult&lt; <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; typename Env::allocator_type &gt;, F &gt;</td></tr>
<tr class="separator:aadb68ff37c16a8f59159054db6dfc70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77941cdddb16ebf399223b6f751d33e" id="r_ae77941cdddb16ebf399223b6f751d33e"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:ae77941cdddb16ebf399223b6f751d33e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ae77941cdddb16ebf399223b6f751d33e">iresult_ask</a> = IResult&lt; <a class="el" href="classlala_1_1_p_c.html#a113f8b2ca2c7096a75d9a140e37e7afa">ask_type</a>&lt; typename Env::allocator_type &gt;, F &gt;</td></tr>
<tr class="separator:ae77941cdddb16ebf399223b6f751d33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9c5eb06b9f1de0ecda67170b9b50c0c" id="r_ab9c5eb06b9f1de0ecda67170b9b50c0c"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ab9c5eb06b9f1de0ecda67170b9b50c0c">PC</a> (AType atype, <a class="el" href="classlala_1_1_p_c.html#aec9efdcb9d42e5808d8b1350c01f81ac">sub_ptr</a> sub, const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;alloc=<a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>())</td></tr>
<tr class="separator:ab9c5eb06b9f1de0ecda67170b9b50c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f6a165daed474dde7d809d4aa7f9c" id="r_a2a5f6a165daed474dde7d809d4aa7f9c"><td class="memItemLeft" align="right" valign="top">CUDA&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a2a5f6a165daed474dde7d809d4aa7f9c">PC</a> (<a class="el" href="classlala_1_1_p_c.html">PC</a> &amp;&amp;other)</td></tr>
<tr class="separator:a2a5f6a165daed474dde7d809d4aa7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa36c427921bfd46949190240a05dc56" id="r_aaa36c427921bfd46949190240a05dc56"><td class="memTemplParams" colspan="2">template&lt;class A2 , class Alloc2 , class... Allocators&gt; </td></tr>
<tr class="memitem:aaa36c427921bfd46949190240a05dc56"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aaa36c427921bfd46949190240a05dc56">PC</a> (const <a class="el" href="classlala_1_1_p_c.html">PC</a>&lt; A2, Alloc2 &gt; &amp;other, AbstractDeps&lt; Allocators... &gt; &amp;deps)</td></tr>
<tr class="separator:aaa36c427921bfd46949190240a05dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b907e4da5dff6d2790330c7197138ae" id="r_a1b907e4da5dff6d2790330c7197138ae"><td class="memItemLeft" align="right" valign="top">CUDA <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a1b907e4da5dff6d2790330c7197138ae">get_allocator</a> () const</td></tr>
<tr class="separator:a1b907e4da5dff6d2790330c7197138ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3886a47416bd3ae0ecbbfb5650b10" id="r_a0bf3886a47416bd3ae0ecbbfb5650b10"><td class="memItemLeft" align="right" valign="top">CUDA AType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a0bf3886a47416bd3ae0ecbbfb5650b10">aty</a> () const</td></tr>
<tr class="separator:a0bf3886a47416bd3ae0ecbbfb5650b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c21ee893e70a51d7edc301427b2e6" id="r_aa77c21ee893e70a51d7edc301427b2e6"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:aa77c21ee893e70a51d7edc301427b2e6"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_p_c.html#aadb68ff37c16a8f59159054db6dfc70f">iresult_tell</a>&lt; F, Env &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aa77c21ee893e70a51d7edc301427b2e6">interpret_tell_in</a> (const F &amp;f, Env &amp;env)</td></tr>
<tr class="separator:aa77c21ee893e70a51d7edc301427b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14639fa5276e02cd59955e4e4609bdc" id="r_ad14639fa5276e02cd59955e4e4609bdc"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:ad14639fa5276e02cd59955e4e4609bdc"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI <a class="el" href="classlala_1_1_p_c.html#ae77941cdddb16ebf399223b6f751d33e">iresult_ask</a>&lt; F, Env &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ad14639fa5276e02cd59955e4e4609bdc">interpret_ask_in</a> (const F &amp;f, const Env &amp;env) const</td></tr>
<tr class="separator:ad14639fa5276e02cd59955e4e4609bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e187205ac887590bbf829517dc39ff6" id="r_a3e187205ac887590bbf829517dc39ff6"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 , class Mem &gt; </td></tr>
<tr class="memitem:a3e187205ac887590bbf829517dc39ff6"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a3e187205ac887590bbf829517dc39ff6">tell</a> (const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;t, BInc&lt; Mem &gt; &amp;has_changed)</td></tr>
<tr class="separator:a3e187205ac887590bbf829517dc39ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7ebed271b386f128740950d0b8bd4b" id="r_a6e7ebed271b386f128740950d0b8bd4b"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a6e7ebed271b386f128740950d0b8bd4b"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a6e7ebed271b386f128740950d0b8bd4b">tell</a> (const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;t)</td></tr>
<tr class="separator:a6e7ebed271b386f128740950d0b8bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a04d0a29b1eaf0bfdae2e885fc7e77e" id="r_a4a04d0a29b1eaf0bfdae2e885fc7e77e"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a4a04d0a29b1eaf0bfdae2e885fc7e77e"><td class="memTemplItemLeft" align="right" valign="top">CUDA local::BInc&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a4a04d0a29b1eaf0bfdae2e885fc7e77e">ask</a> (const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;t) const</td></tr>
<tr class="separator:a4a04d0a29b1eaf0bfdae2e885fc7e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac46ee1fafe414e2006c2ae907e161a" id="r_a8ac46ee1fafe414e2006c2ae907e161a"><td class="memItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a8ac46ee1fafe414e2006c2ae907e161a">num_refinements</a> () const</td></tr>
<tr class="separator:a8ac46ee1fafe414e2006c2ae907e161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8b87ad88928e5bfc2729d594a170eb" id="r_a9b8b87ad88928e5bfc2729d594a170eb"><td class="memTemplParams" colspan="2">template&lt;class Mem &gt; </td></tr>
<tr class="memitem:a9b8b87ad88928e5bfc2729d594a170eb"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a9b8b87ad88928e5bfc2729d594a170eb">refine</a> (size_t i, BInc&lt; Mem &gt; &amp;has_changed)</td></tr>
<tr class="separator:a9b8b87ad88928e5bfc2729d594a170eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702acca7ed494e416e6065a627073237" id="r_a702acca7ed494e416e6065a627073237"><td class="memItemLeft" align="right" valign="top">CUDA local::BInc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a702acca7ed494e416e6065a627073237">is_top</a> () const</td></tr>
<tr class="separator:a702acca7ed494e416e6065a627073237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4238cef38fad79db9bebd7b42868ad1f" id="r_a4238cef38fad79db9bebd7b42868ad1f"><td class="memItemLeft" align="right" valign="top">CUDA local::BDec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a4238cef38fad79db9bebd7b42868ad1f">is_bot</a> () const</td></tr>
<tr class="separator:a4238cef38fad79db9bebd7b42868ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15da122f79b0ced73783e1d272cebde" id="r_ab15da122f79b0ced73783e1d272cebde"><td class="memItemLeft" align="right" valign="top">CUDA const <a class="el" href="classlala_1_1_p_c.html#a65b447c428d8003a9ccea091230303a8">universe_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ab15da122f79b0ced73783e1d272cebde">operator[]</a> (int x) const</td></tr>
<tr class="separator:ab15da122f79b0ced73783e1d272cebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1eb41aa3e2ad56ac592d81c066c72f" id="r_a7f1eb41aa3e2ad56ac592d81c066c72f"><td class="memItemLeft" align="right" valign="top">CUDA const <a class="el" href="classlala_1_1_p_c.html#a65b447c428d8003a9ccea091230303a8">universe_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a7f1eb41aa3e2ad56ac592d81c066c72f">project</a> (AVar x) const</td></tr>
<tr class="separator:a7f1eb41aa3e2ad56ac592d81c066c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861e868b5d54f011d689c026711390c" id="r_a0861e868b5d54f011d689c026711390c"><td class="memItemLeft" align="right" valign="top">CUDA size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a0861e868b5d54f011d689c026711390c">vars</a> () const</td></tr>
<tr class="separator:a0861e868b5d54f011d689c026711390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ed6976b30e5a92c1157c3e4479d89e" id="r_ad0ed6976b30e5a92c1157c3e4479d89e"><td class="memTemplParams" colspan="2">template&lt;class Alloc2  = allocator_type&gt; </td></tr>
<tr class="memitem:ad0ed6976b30e5a92c1157c3e4479d89e"><td class="memTemplItemLeft" align="right" valign="top">CUDA <a class="el" href="structlala_1_1_p_c_1_1snapshot__type.html">snapshot_type</a>&lt; Alloc2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ad0ed6976b30e5a92c1157c3e4479d89e">snapshot</a> (const Alloc2 &amp;alloc=Alloc2()) const</td></tr>
<tr class="separator:ad0ed6976b30e5a92c1157c3e4479d89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f021acea093e476316a6ac9f8d66c9" id="r_ae4f021acea093e476316a6ac9f8d66c9"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:ae4f021acea093e476316a6ac9f8d66c9"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ae4f021acea093e476316a6ac9f8d66c9">restore</a> (const <a class="el" href="structlala_1_1_p_c_1_1snapshot__type.html">snapshot_type</a>&lt; Alloc2 &gt; &amp;snap)</td></tr>
<tr class="separator:ae4f021acea093e476316a6ac9f8d66c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f07d99f5622fb2d90398937dbe8160" id="r_a74f07d99f5622fb2d90398937dbe8160"><td class="memTemplParams" colspan="2">template&lt;class ExtractionStrategy  = NonAtomicExtraction&gt; </td></tr>
<tr class="memitem:a74f07d99f5622fb2d90398937dbe8160"><td class="memTemplItemLeft" align="right" valign="top">CUDA bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a74f07d99f5622fb2d90398937dbe8160">is_extractable</a> (const ExtractionStrategy &amp;strategy=ExtractionStrategy()) const</td></tr>
<tr class="separator:a74f07d99f5622fb2d90398937dbe8160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6c76fca395e6c7986cbdaaa6d2378" id="r_a7fb6c76fca395e6c7986cbdaaa6d2378"><td class="memTemplParams" colspan="2">template&lt;class B &gt; </td></tr>
<tr class="memitem:a7fb6c76fca395e6c7986cbdaaa6d2378"><td class="memTemplItemLeft" align="right" valign="top">CUDA void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a7fb6c76fca395e6c7986cbdaaa6d2378">extract</a> (B &amp;ua) const</td></tr>
<tr class="separator:a7fb6c76fca395e6c7986cbdaaa6d2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2446dd26cdc0475a781e0f7dc68096d" id="r_ae2446dd26cdc0475a781e0f7dc68096d"><td class="memTemplParams" colspan="2">template&lt;class Env &gt; </td></tr>
<tr class="memitem:ae2446dd26cdc0475a781e0f7dc68096d"><td class="memTemplItemLeft" align="right" valign="top">CUDA NI TFormula&lt; typename Env::allocator_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#ae2446dd26cdc0475a781e0f7dc68096d">deinterpret</a> (const Env &amp;env) const</td></tr>
<tr class="separator:ae2446dd26cdc0475a781e0f7dc68096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b4f9d8b6790eac90d5d18306871474c" id="r_a1b4f9d8b6790eac90d5d18306871474c"><td class="memItemLeft" align="right" valign="top">static CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a1b4f9d8b6790eac90d5d18306871474c">bot</a> (AType atype=UNTYPED, const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;alloc=<a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>(), const <a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a> &amp;sub_alloc=<a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a>())</td></tr>
<tr class="separator:a1b4f9d8b6790eac90d5d18306871474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2444e974c596ae61bd760f07fbe072" id="r_aba2444e974c596ae61bd760f07fbe072"><td class="memItemLeft" align="right" valign="top">static CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aba2444e974c596ae61bd760f07fbe072">top</a> (AType atype=UNTYPED, const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;alloc=<a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>(), const <a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a> &amp;sub_alloc=<a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a>())</td></tr>
<tr class="separator:aba2444e974c596ae61bd760f07fbe072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e32a84e02bd9c6d1dd21322806cf75" id="r_a04e32a84e02bd9c6d1dd21322806cf75"><td class="memTemplParams" colspan="2">template&lt;class F , class Env &gt; </td></tr>
<tr class="memitem:a04e32a84e02bd9c6d1dd21322806cf75"><td class="memTemplItemLeft" align="right" valign="top">CUDA static NI IResult&lt; <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a>, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a04e32a84e02bd9c6d1dd21322806cf75">interpret_tell</a> (const F &amp;f, Env &amp;env, <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> alloc=<a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>())</td></tr>
<tr class="separator:a04e32a84e02bd9c6d1dd21322806cf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a139e35dab7a551c92c7738eff0ce87eb" id="r_a139e35dab7a551c92c7738eff0ce87eb"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#a139e35dab7a551c92c7738eff0ce87eb">name</a> = &quot;PC&quot;</td></tr>
<tr class="separator:a139e35dab7a551c92c7738eff0ce87eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa75ccac8f1abff5d2868e936da050144" id="r_aa75ccac8f1abff5d2868e936da050144"><td class="memTemplParams" colspan="2">template&lt;class A2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:aa75ccac8f1abff5d2868e936da050144"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlala_1_1_p_c.html#aa75ccac8f1abff5d2868e936da050144">PC</a></td></tr>
<tr class="separator:aa75ccac8f1abff5d2868e936da050144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class A, class Allocator = typename A::allocator_type&gt;<br />
class lala::PC&lt; A, Allocator &gt;</div><p><a class="el" href="classlala_1_1_p_c.html">PC</a> is an abstract transformer built on top of an abstract domain <code>A</code>. It is expected that <code>A</code> has a projection function <code>u = project(x)</code>. We also expect a <code>tell(x, u, has_changed)</code> function to join the abstract universe <code>u</code> in the domain of the variable <code>x</code>. An example of abstract domain satisfying these requirements is <code>VStore&lt;Interval&lt;ZInc&gt;&gt;</code>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a176f99e59ee2c29d8f4bc4bab672e3fc" name="a176f99e59ee2c29d8f4bc4bab672e3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176f99e59ee2c29d8f4bc4bab672e3fc">&#9670;&#160;</a></span>sub_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::sub_type =  A</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65b447c428d8003a9ccea091230303a8" name="a65b447c428d8003a9ccea091230303a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b447c428d8003a9ccea091230303a8">&#9670;&#160;</a></span>universe_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::universe_type =  typename A::universe_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad80287a2bb1dbf74270d8b24deec861" name="aad80287a2bb1dbf74270d8b24deec861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad80287a2bb1dbf74270d8b24deec861">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::allocator_type =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fb0fe6062ff62a2cde6962902a534f3" name="a3fb0fe6062ff62a2cde6962902a534f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb0fe6062ff62a2cde6962902a534f3">&#9670;&#160;</a></span>sub_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::sub_allocator_type =  typename A::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7a40be7ccc8955bfd5475bfd7a20a7d" name="ae7a40be7ccc8955bfd5475bfd7a20a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a40be7ccc8955bfd5475bfd7a20a7d">&#9670;&#160;</a></span>this_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::this_type =  <a class="el" href="classlala_1_1_p_c.html">PC</a>&lt;<a class="el" href="classlala_1_1_p_c.html#a176f99e59ee2c29d8f4bc4bab672e3fc">sub_type</a>, <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec9efdcb9d42e5808d8b1350c01f81ac" name="aec9efdcb9d42e5808d8b1350c01f81ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9efdcb9d42e5808d8b1350c01f81ac">&#9670;&#160;</a></span>sub_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::sub_ptr =  abstract_ptr&lt;<a class="el" href="classlala_1_1_p_c.html#a176f99e59ee2c29d8f4bc4bab672e3fc">sub_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a91532a01a881e2ee99bbc46ea1dec" name="af8a91532a01a881e2ee99bbc46ea1dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a91532a01a881e2ee99bbc46ea1dec">&#9670;&#160;</a></span>tell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::tell_type =  <a class="el" href="structlala_1_1_p_c_1_1interpreted__type.html">interpreted_type</a>&lt;Alloc2, typename sub_type::template <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt;Alloc2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a113f8b2ca2c7096a75d9a140e37e7afa" name="a113f8b2ca2c7096a75d9a140e37e7afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f8b2ca2c7096a75d9a140e37e7afa">&#9670;&#160;</a></span>ask_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::ask_type =  <a class="el" href="structlala_1_1_p_c_1_1interpreted__type.html">interpreted_type</a>&lt;Alloc2, typename sub_type::template <a class="el" href="classlala_1_1_p_c.html#a113f8b2ca2c7096a75d9a140e37e7afa">ask_type</a>&lt;Alloc2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadb68ff37c16a8f59159054db6dfc70f" name="aadb68ff37c16a8f59159054db6dfc70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb68ff37c16a8f59159054db6dfc70f">&#9670;&#160;</a></span>iresult_tell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::iresult_tell =  IResult&lt;<a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt;typename Env::allocator_type&gt;, F&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae77941cdddb16ebf399223b6f751d33e" name="ae77941cdddb16ebf399223b6f751d33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77941cdddb16ebf399223b6f751d33e">&#9670;&#160;</a></span>iresult_ask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::iresult_ask =  IResult&lt;<a class="el" href="classlala_1_1_p_c.html#a113f8b2ca2c7096a75d9a140e37e7afa">ask_type</a>&lt;typename Env::allocator_type&gt;, F&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9c5eb06b9f1de0ecda67170b9b50c0c" name="ab9c5eb06b9f1de0ecda67170b9b50c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c5eb06b9f1de0ecda67170b9b50c0c">&#9670;&#160;</a></span>PC() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::PC </td>
          <td>(</td>
          <td class="paramtype">AType&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_p_c.html#aec9efdcb9d42e5808d8b1350c01f81ac">sub_ptr</a>&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a5f6a165daed474dde7d809d4aa7f9c" name="a2a5f6a165daed474dde7d809d4aa7f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5f6a165daed474dde7d809d4aa7f9c">&#9670;&#160;</a></span>PC() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::PC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlala_1_1_p_c.html">PC</a>&lt; A, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa36c427921bfd46949190240a05dc56" name="aaa36c427921bfd46949190240a05dc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa36c427921bfd46949190240a05dc56">&#9670;&#160;</a></span>PC() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class A2 , class Alloc2 , class... Allocators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::PC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html">PC</a>&lt; A2, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AbstractDeps&lt; Allocators... &gt; &amp;&#160;</td>
          <td class="paramname"><em>deps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b907e4da5dff6d2790330c7197138ae" name="a1b907e4da5dff6d2790330c7197138ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b907e4da5dff6d2790330c7197138ae">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf3886a47416bd3ae0ecbbfb5650b10" name="a0bf3886a47416bd3ae0ecbbfb5650b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf3886a47416bd3ae0ecbbfb5650b10">&#9670;&#160;</a></span>aty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA AType <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::aty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4f9d8b6790eac90d5d18306871474c" name="a1b4f9d8b6790eac90d5d18306871474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f9d8b6790eac90d5d18306871474c">&#9670;&#160;</a></span>bot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::bot </td>
          <td>(</td>
          <td class="paramtype">AType&#160;</td>
          <td class="paramname"><em>atype</em> = <code>UNTYPED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2444e974c596ae61bd760f07fbe072" name="aba2444e974c596ae61bd760f07fbe072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2444e974c596ae61bd760f07fbe072">&#9670;&#160;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::top </td>
          <td>(</td>
          <td class="paramtype">AType&#160;</td>
          <td class="paramname"><em>atype</em> = <code>UNTYPED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#a3fb0fe6062ff62a2cde6962902a534f3">sub_allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A special symbolic element representing top. </p>

</div>
</div>
<a id="aa77c21ee893e70a51d7edc301427b2e6" name="aa77c21ee893e70a51d7edc301427b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77c21ee893e70a51d7edc301427b2e6">&#9670;&#160;</a></span>interpret_tell_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_p_c.html#aadb68ff37c16a8f59159054db6dfc70f">iresult_tell</a>&lt; F, Env &gt; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::interpret_tell_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classlala_1_1_p_c.html">PC</a> expects a conjunction of the form \( c_1 \land \ldots \land c_n \) where sub-formulas \( c_i \) can either be interpreted in the sub-domain <code>A</code> or in the current domain. Moreover, we only treat exact conjunction (no under- or over-approximation of the conjunction). For now, \( T \neq k \) is not supported where \( T \) is an arithmetic term, containing function symbols supported in <code><a class="el" href="terms_8hpp.html">terms.hpp</a></code>. </p>

</div>
</div>
<a id="a04e32a84e02bd9c6d1dd21322806cf75" name="a04e32a84e02bd9c6d1dd21322806cf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e32a84e02bd9c6d1dd21322806cf75">&#9670;&#160;</a></span>interpret_tell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA static NI IResult&lt; <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a>, F &gt; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::interpret_tell </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classlala_1_1_p_c.html#aad80287a2bb1dbf74270d8b24deec861">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an abstract domain and interpret the formulas <code>f</code> in this abstract domain. The sub abstract domain is supposed to be able to represent variables, and its constructor is assumed to take a size, like for <code>VStore</code>. </p>

</div>
</div>
<a id="ad14639fa5276e02cd59955e4e4609bdc" name="ad14639fa5276e02cd59955e4e4609bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14639fa5276e02cd59955e4e4609bdc">&#9670;&#160;</a></span>interpret_ask_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class F , class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI <a class="el" href="classlala_1_1_p_c.html#ae77941cdddb16ebf399223b6f751d33e">iresult_ask</a>&lt; F, Env &gt; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::interpret_ask_in </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e187205ac887590bbf829517dc39ff6" name="a3e187205ac887590bbf829517dc39ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e187205ac887590bbf829517dc39ff6">&#9670;&#160;</a></span>tell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 , class Mem &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> &amp; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::tell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BInc&lt; Mem &gt; &amp;&#160;</td>
          <td class="paramname"><em>has_changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Note that we cannot add propagators in parallel (but modifying the underlying domain is ok). This is a current limitation that we should fix later on. Notes for later: To implement "telling of propagators", we would need to check if a propagator has already been added or not (for idempotency).</p><ol type="1">
<li>Walk through the existing propagators to check which ones are already in.</li>
<li>If a propagator has the same shape but different constant <code>U</code>, join them in place. <br  />
 </li>
</ol>

</div>
</div>
<a id="a6e7ebed271b386f128740950d0b8bd4b" name="a6e7ebed271b386f128740950d0b8bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7ebed271b386f128740950d0b8bd4b">&#9670;&#160;</a></span>tell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="classlala_1_1_p_c.html#ae7a40be7ccc8955bfd5475bfd7a20a7d">this_type</a> &amp; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::tell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a04d0a29b1eaf0bfdae2e885fc7e77e" name="a4a04d0a29b1eaf0bfdae2e885fc7e77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a04d0a29b1eaf0bfdae2e885fc7e77e">&#9670;&#160;</a></span>ask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA local::BInc <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::ask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_p_c.html#af8a91532a01a881e2ee99bbc46ea1dec">tell_type</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ac46ee1fafe414e2006c2ae907e161a" name="a8ac46ee1fafe414e2006c2ae907e161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac46ee1fafe414e2006c2ae907e161a">&#9670;&#160;</a></span>num_refinements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::num_refinements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8b87ad88928e5bfc2729d594a170eb" name="a9b8b87ad88928e5bfc2729d594a170eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8b87ad88928e5bfc2729d594a170eb">&#9670;&#160;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Mem &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::refine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BInc&lt; Mem &gt; &amp;&#160;</td>
          <td class="paramname"><em>has_changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a702acca7ed494e416e6065a627073237" name="a702acca7ed494e416e6065a627073237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702acca7ed494e416e6065a627073237">&#9670;&#160;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA local::BInc <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::is_top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>true</code> if the underlying abstract element is top, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a4238cef38fad79db9bebd7b42868ad1f" name="a4238cef38fad79db9bebd7b42868ad1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4238cef38fad79db9bebd7b42868ad1f">&#9670;&#160;</a></span>is_bot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA local::BDec <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::is_bot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>true</code> if the underlying abstract element is bot and there is no refinement function, <code>false</code> otherwise. </p>

</div>
</div>
<a id="ab15da122f79b0ced73783e1d272cebde" name="ab15da122f79b0ced73783e1d272cebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15da122f79b0ced73783e1d272cebde">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="classlala_1_1_p_c.html#a65b447c428d8003a9ccea091230303a8">universe_type</a> &amp; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f1eb41aa3e2ad56ac592d81c066c72f" name="a7f1eb41aa3e2ad56ac592d81c066c72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1eb41aa3e2ad56ac592d81c066c72f">&#9670;&#160;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA const <a class="el" href="classlala_1_1_p_c.html#a65b447c428d8003a9ccea091230303a8">universe_type</a> &amp; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::project </td>
          <td>(</td>
          <td class="paramtype">AVar&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0861e868b5d54f011d689c026711390c" name="a0861e868b5d54f011d689c026711390c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0861e868b5d54f011d689c026711390c">&#9670;&#160;</a></span>vars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA size_t <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0ed6976b30e5a92c1157c3e4479d89e" name="ad0ed6976b30e5a92c1157c3e4479d89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ed6976b30e5a92c1157c3e4479d89e">&#9670;&#160;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2  = allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA <a class="el" href="structlala_1_1_p_c_1_1snapshot__type.html">snapshot_type</a>&lt; Alloc2 &gt; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const Alloc2 &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Alloc2()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4f021acea093e476316a6ac9f8d66c9" name="ae4f021acea093e476316a6ac9f8d66c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f021acea093e476316a6ac9f8d66c9">&#9670;&#160;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::restore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_p_c_1_1snapshot__type.html">snapshot_type</a>&lt; Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>snap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f07d99f5622fb2d90398937dbe8160" name="a74f07d99f5622fb2d90398937dbe8160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f07d99f5622fb2d90398937dbe8160">&#9670;&#160;</a></span>is_extractable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class ExtractionStrategy  = NonAtomicExtraction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA bool <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::is_extractable </td>
          <td>(</td>
          <td class="paramtype">const ExtractionStrategy &amp;&#160;</td>
          <td class="paramname"><em>strategy</em> = <code>ExtractionStrategy()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An abstract element is extractable when it is not equal to top, if all propagators are entailed and if the underlying abstract element is extractable. </p>

</div>
</div>
<a id="a7fb6c76fca395e6c7986cbdaaa6d2378" name="a7fb6c76fca395e6c7986cbdaaa6d2378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb6c76fca395e6c7986cbdaaa6d2378">&#9670;&#160;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA void <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">B &amp;&#160;</td>
          <td class="paramname"><em>ua</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract the current element into <code>ua</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="classlala_1_1_p_c.html#a74f07d99f5622fb2d90398937dbe8160">is_extractable()</a></code> must be <code>true</code>. For efficiency reason, if <code>B</code> is a propagator completion, the propagators are not copied in <code>ua</code>. (It is OK, since they are entailed, they don't bring information anymore.) </dd></dl>

</div>
</div>
<a id="ae2446dd26cdc0475a781e0f7dc68096d" name="ae2446dd26cdc0475a781e0f7dc68096d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2446dd26cdc0475a781e0f7dc68096d">&#9670;&#160;</a></span>deinterpret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class Env &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUDA NI TFormula&lt; typename Env::allocator_type &gt; <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::deinterpret </td>
          <td>(</td>
          <td class="paramtype">const Env &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa75ccac8f1abff5d2868e936da050144" name="aa75ccac8f1abff5d2868e936da050144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75ccac8f1abff5d2868e936da050144">&#9670;&#160;</a></span>PC</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<div class="memtemplate">
template&lt;class A2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classlala_1_1_p_c.html">PC</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a139e35dab7a551c92c7738eff0ce87eb" name="a139e35dab7a551c92c7738eff0ce87eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139e35dab7a551c92c7738eff0ce87eb">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class Allocator  = typename A::allocator_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="classlala_1_1_p_c.html">lala::PC</a>&lt; A, Allocator &gt;::name = &quot;PC&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/lala/<a class="el" href="pc_8hpp_source.html">pc.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li><li class="navelem"><a class="el" href="classlala_1_1_p_c.html">PC</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
