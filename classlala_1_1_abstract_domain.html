<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice land core library: lala::AbstractDomain&lt; LE, VD &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice land core library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classlala_1_1_abstract_domain.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlala_1_1_abstract_domain-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lala::AbstractDomain&lt; LE, VD &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="abstract__domain_8hpp_source.html">abstract_domain.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9e62cdc7387406a4ed10f264b30dd1c"><td class="memItemLeft" align="right" valign="top">typedef LE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a></td></tr>
<tr class="separator:af9e62cdc7387406a4ed10f264b30dd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b35167f322bcdf1196dafd44c1d9a7"><td class="memItemLeft" align="right" valign="top">typedef VD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a></td></tr>
<tr class="separator:a09b35167f322bcdf1196dafd44c1d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a45d8cb8d826a42373673df9c5a36b473"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> thrust::optional&lt; <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a45d8cb8d826a42373673df9c5a36b473">interpret</a> (<a class="el" href="namespacelala.html#aeecfc640d117a6c1efb50d5a90f8a369">Approx</a> appx, const <a class="el" href="structlala_1_1_formula.html">Formula</a> &amp;f)=0</td></tr>
<tr class="separator:a45d8cb8d826a42373673df9c5a36b473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616913c0342c6b67e1b11bf6a72cabef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a616913c0342c6b67e1b11bf6a72cabef">join</a> (const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;other)=0</td></tr>
<tr class="separator:a616913c0342c6b67e1b11bf6a72cabef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af085aa91f974b389dd27ebc74ecbd0e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#af085aa91f974b389dd27ebc74ecbd0e1">meet</a> (const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;other)=0</td></tr>
<tr class="separator:af085aa91f974b389dd27ebc74ecbd0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3e77663770fc095ab30203d76727e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#add3e77663770fc095ab30203d76727e0">refine</a> ()=0</td></tr>
<tr class="separator:add3e77663770fc095ab30203d76727e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e37618d61cf35664affff9119ea09b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a3e37618d61cf35664affff9119ea09b5">entailment</a> (const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;element) const =0</td></tr>
<tr class="separator:a3e37618d61cf35664affff9119ea09b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454aa61d13ac4f1592d053c6d1e8e4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#af454aa61d13ac4f1592d053c6d1e8e4e">project</a> (const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;x) const =0</td></tr>
<tr class="separator:af454aa61d13ac4f1592d053c6d1e8e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec8a681016febbe2ca73b9732c82d8b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a9ec8a681016febbe2ca73b9732c82d8b">embed</a> (<a class="el" href="namespacelala.html#a2d894c71bdf0a6c9efb342cfe4c9af0c">AVar</a> x, const <a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a> &amp;dom) const =0</td></tr>
<tr class="separator:a9ec8a681016febbe2ca73b9732c82d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806fc638093b14beb72b1ba2c179065d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> ecuda::vector&lt; <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a806fc638093b14beb72b1ba2c179065d">split</a> () const =0</td></tr>
<tr class="separator:a806fc638093b14beb72b1ba2c179065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986108afc8a6e495ded55db3a4daf80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a6986108afc8a6e495ded55db3a4daf80">is_underappx</a> () const =0</td></tr>
<tr class="separator:a6986108afc8a6e495ded55db3a4daf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3795a57069265a193794f60b90f697b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#ae3795a57069265a193794f60b90f697b">reset</a> (const <a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a> &amp;b)=0</td></tr>
<tr class="separator:ae3795a57069265a193794f60b90f697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc50a074e86b4bd7ab194eba217d65a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#acdc50a074e86b4bd7ab194eba217d65a">clone</a> () const =0</td></tr>
<tr class="separator:acdc50a074e86b4bd7ab194eba217d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee2bb4db22179d7764bbedba2fea2fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="structlala_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#acee2bb4db22179d7764bbedba2fea2fa">deinterpret</a> () const =0</td></tr>
<tr class="separator:acee2bb4db22179d7764bbedba2fea2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916750dcfb5bafbb755234cba2c91b90"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlala_1_1_abstract_domain.html#a916750dcfb5bafbb755234cba2c91b90">print</a> () const =0</td></tr>
<tr class="separator:a916750dcfb5bafbb755234cba2c91b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename LE, typename VD&gt;<br />
class lala::AbstractDomain&lt; LE, VD &gt;</h3>

<p>An abstract domain is a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a> with additional operations including an interpretation function, a refinement operator and a split operator. We now explain the main idea of this abstract framework, although it is not possible to be very precise here, for more information on the theory, please contact Pierre Talbot (<a href="#" onclick="location.href='mai'+'lto:'+'pie'+'rr'+'e.t'+'al'+'bot'+'@u'+'ni.'+'lu'; return false;">pierr<span style="display: none;">.nosp@m.</span>e.ta<span style="display: none;">.nosp@m.</span>lbot@<span style="display: none;">.nosp@m.</span>uni.<span style="display: none;">.nosp@m.</span>lu</a>). We have three entities playing a role in our framework: logical formulas, abstract domains and the concrete domain. The concrete domain is a mathematical object, possibly infinite and not computable, which is not explicitly represented in the code. The concrete domain is however crucial to establish the proofs of soundness and completeness of our abstract domains. We will write the concrete domain \( D^\flat \) and an abstract domain \( A \). We can interpret a logical formula \( \varphi \) in the concrete domain with \([\![\varphi]\!]^\flat\), and this element contains all the solutions of \(\varphi\). We connect the concrete and abstract worlds using a monotone concretization function \(\gamma: A \to D^\flat\) which turns an abstract element into a concrete element. The concretization is useful to establish two properties. Let \( \varphi \) be a formula and \( a \in A \) an abstract element, then:</p><ul>
<li>\(a\) is an under-approximation if \(\gamma(a) \subseteq [\![\varphi]\!]^\flat \) (soundness).</li>
<li>\(a\) is an over-approximation if \(\gamma(a) \supseteq [\![\varphi]\!]^\flat \) (completeness).</li>
<li>\(a \) is an exact representation of \(\varphi\) if it is both an under- and over-approximation.</li>
</ul>
<p>In brief, an under-approximating element guarantees we have only solutions of \(\varphi\) represented in the abstract element \(a\), but not necessarily all. Whereas an over-approximating element guarantees we have all solutions of \(\varphi\) but possibly with extra non-solution elements.</p>
<p>This class exists only for documentation purposes as abstract domains will be combined using templates, and not by relying on inheritance from an abstract class. Ideally, <code><a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a></code> should be a C++20 concept, but it is not yet possible because neither NVCC or Doxygen support concepts yet. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af9e62cdc7387406a4ed10f264b30dd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e62cdc7387406a4ed10f264b30dd1c">&#9670;&nbsp;</a></span>LogicalElement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef LE <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::<a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>LogicalElement</code> is an intermediate representation between a logical formula (see <code><a class="el" href="structlala_1_1_formula.html">Formula</a></code>) and an abstract element. The design rational is that we want to avoid manipulating <code><a class="el" href="structlala_1_1_formula.html">Formula</a></code> during solving for efficiency purposes (since <a class="el" href="structlala_1_1_formula.html">Formula</a> contains dynamic arrays, string representation of operators, ...). Therefore, we can create the logical elements at the beginning, and adding them in the abstract element later on, when appropriate. </p>

</div>
</div>
<a id="a09b35167f322bcdf1196dafd44c1d9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b35167f322bcdf1196dafd44c1d9a7">&#9670;&nbsp;</a></span>VarDom</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VD <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::<a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variable domain (<code>VarDom</code>) is the underlying representation of a single variable inside this abstract element. It can be an interval or a set of values for instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45d8cb8d826a42373673df9c5a36b473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d8cb8d826a42373673df9c5a36b473">&#9670;&nbsp;</a></span>interpret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> thrust::optional&lt;<a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a>&gt; <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::interpret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#aeecfc640d117a6c1efb50d5a90f8a369">Approx</a>&#160;</td>
          <td class="paramname"><em>appx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlala_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A partial interpretation function \([\![\varphi]\!]_a^\updownarrow \) turns the logical formula \(\varphi\) (<code>f</code>) into a logical element according to the current abstract element \(a\) and the approximation kind \(\updownarrow\) (<code>appx</code>). See also <code>LogicalElement</code>. The approximation kind is not necessarily bound to an abstract element. For instance, let an abstract element \(a\) under-approximating a logical formula \(\varphi\). We can still add over-approximating <em>redundant constraints</em> in \(a\), which will not impact the under-approximating property of \(a\) w.r.t. \(\varphi\). </p><dl class="section return"><dt>Returns</dt><dd>An empty optional if the formula cannot be interpreted in the abstract domain. Otherwise, it returns the interpreted formula. </dd></dl>

</div>
</div>
<a id="a616913c0342c6b67e1b11bf6a72cabef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616913c0342c6b67e1b11bf6a72cabef">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute \( a \sqcup [\![\varphi]\!] \) where \(a\) is the current element and \( [\![\varphi]\!] \) an interpreted formula. </p>

</div>
</div>
<a id="af085aa91f974b389dd27ebc74ecbd0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af085aa91f974b389dd27ebc74ecbd0e1">&#9670;&nbsp;</a></span>meet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::meet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute \( a \sqcap [\![\varphi]\!] \), see also <code>join</code>. </p>

</div>
</div>
<a id="add3e77663770fc095ab30203d76727e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3e77663770fc095ab30203d76727e0">&#9670;&nbsp;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::refine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>refine</code> is an extensive function ( \(\forall{a \in A},~\mathit{refine}(a) \geq a \)) refining an abstract element \(a\). It can have additional properties such as under- or over-approximation depending on the abstract domain. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the abstract element has changed and <code>false</code> if we reached a fixed point. </dd></dl>

</div>
</div>
<a id="a3e37618d61cf35664affff9119ea09b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e37618d61cf35664affff9119ea09b5">&#9670;&nbsp;</a></span>entailment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::entailment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The entailment, formally written \(a \models \varphi\), is <code>true</code> whenever we can deduce a formula \(\varphi\) from an abstract element \(a\), i.e., \(\gamma(a) \subseteq [\![\varphi]\!]\). Note that if it returns <code>false</code>, it can either mean \(\lnot\varphi\) is entailed, or that we do not know yet if it is entailed or not. Therefore, to test for <em>disentailment</em>, you should ask if the negation of the formula is entailed. </p>

</div>
</div>
<a id="af454aa61d13ac4f1592d053c6d1e8e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af454aa61d13ac4f1592d053c6d1e8e4e">&#9670;&nbsp;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a> <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The projection of term onto the underlying variable domain <code>VarDom</code>. A common example is to project the domain of a variable <code>x</code> or a term such as <code>x + y</code> onto an interval or set variable domain. If you want to project a formula onto a Boolean, you should use <code>entailment</code> instead. </p>

</div>
</div>
<a id="a9ec8a681016febbe2ca73b9732c82d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec8a681016febbe2ca73b9732c82d8b">&#9670;&nbsp;</a></span>embed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::embed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelala.html#a2d894c71bdf0a6c9efb342cfe4c9af0c">AVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html#a09b35167f322bcdf1196dafd44c1d9a7">VarDom</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function <code>embed(x, dom)</code> is similar to \( a \sqcup [\![\varphi]\!] \) where \(\varphi\) is a formula with a single variable equals to \( x \) and interpretable in <code>VarDom</code>. Here, the underlying element <code>VarDom</code> has already been created. </p>

</div>
</div>
<a id="a806fc638093b14beb72b1ba2c179065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806fc638093b14beb72b1ba2c179065d">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> ecuda::vector&lt;<a class="el" href="classlala_1_1_abstract_domain.html#af9e62cdc7387406a4ed10f264b30dd1c">LogicalElement</a>&gt; <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>split</code> is an extensive function, i.e., \( \forall{a \in A},~\forall{b \in \mathit{split}(a)},~a \leq b \), that divides an abstract element into a set of subelements. We call <em>unsplittable elements</em> the elements such that \(\mathit{split}(a) \) is a singleton. We require \(\mathit{split}(a) = \{a\} \) for all unsplittable elements \(a \in A \). An additional usage of <code>split</code> is to detect unsatisfiability of over-approximation, and satisfiability of under-approximation:</p><ul>
<li>In case of an over-approximating element \(a\), we have \(\mathit{split}(a) = \{\} \Rightarrow \gamma(a) = \{\} \).</li>
<li>In case of an under-approximating element \(a\), we have \(\mathit{split}(a) \neq \{\} \Rightarrow \gamma(a) \neq \{\} \land \gamma(a) \subseteq [\![\varphi]\!]^\flat\).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A list of logical elements (possibly complementary, but not necessarily) that can be joined in an abstract element to further refine its state. </dd></dl>

</div>
</div>
<a id="a6986108afc8a6e495ded55db3a4daf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6986108afc8a6e495ded55db3a4daf80">&#9670;&nbsp;</a></span>is_underappx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> bool <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::is_underappx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An abstract domain can be <em>eventually under-approximating</em> which means that after a sufficient number of split and refine operations, it always reach an under-approximating element. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if \(\gamma(a) \subseteq [\![\varphi]\!]^\flat\). <code>false</code> is returned whenever <code>a</code> is an over-approximation or if we do not know whether <code>a</code> is an under-approximation. </dd></dl>

</div>
</div>
<a id="ae3795a57069265a193794f60b90f697b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3795a57069265a193794f60b90f697b">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a>&lt; LE, VD &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method resets the current abstract element to an anterior state \(b \). Therefore, this operation is similar to computing \( a \sqcap b \) where \( a \geq b \). </p>

</div>
</div>
<a id="acdc50a074e86b4bd7ab194eba217d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc50a074e86b4bd7ab194eba217d65a">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a> <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A copy of the current abstract element. </dd></dl>

</div>
</div>
<a id="acee2bb4db22179d7764bbedba2fea2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee2bb4db22179d7764bbedba2fea2fa">&#9670;&nbsp;</a></span>deinterpret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> <a class="el" href="structlala_1_1_formula.html">Formula</a> <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::deinterpret </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the inverse of <code>interpret</code>, but directly maps to a general <code><a class="el" href="structlala_1_1_formula.html">Formula</a></code>. Let \( a = [\![\varphi]\!]_A \), then we must have \( \gamma(a) = [\![[\![a]\!]^{-1}]\!]^\flat \). </p>

</div>
</div>
<a id="a916750dcfb5bafbb755234cba2c91b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916750dcfb5bafbb755234cba2c91b90">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LE , typename VD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="cuda__helper_8hpp.html#a7b01e29f669d6beed251f1b2a547ca93">CUDA</a> void <a class="el" href="classlala_1_1_abstract_domain.html">lala::AbstractDomain</a>&lt; LE, VD &gt;::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the current element with the logical name of the variables. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="abstract__domain_8hpp_source.html">abstract_domain.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelala.html">lala</a></li><li class="navelem"><a class="el" href="classlala_1_1_abstract_domain.html">AbstractDomain</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
